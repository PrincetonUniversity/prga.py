# -*- encoding: ascii -*-
# Python 2 and 3 compatible
from __future__ import division, absolute_import, print_function
from prga.compatible import *

from prga.flow.context import ArchitectureContext
from prga.util import enable_stdout_logging

import re   # for the simple FASM, regexp processing is good enough
import struct
from bitarray import bitarray
import logging

__all__ = ['bitgen_bitchain']

_logger = logging.getLogger(__name__)
_reprog_lut = re.compile("^b(?P<offset>\d+)\[\d+:0\]=(?P<width>\d+)'b(?P<content>[01]+)$")

def bitgen_bitchain(context     # architecture context
        , istream               # input file-like object
        , ostream               # output file-like object
        ):
    """Generate bitstream for bitchain-styled configuration circuitry.

    Args:
        context (`ArchitectureContext`):
        istream (file-like object):
        ostream (file-like object):
    """
    total_config_bits = context.config_circuitry_delegate.total_config_bits
    qwords = total_config_bits // 64
    remainder = total_config_bits % 64 
    if remainder > 0:
        qwords += 1
    bits = bitarray('0', endian='little') * (qwords * 64)
    # process features
    for line in istream:
        segments = line.strip().split('.')
        if segments[-1] == 'ignored':
            continue
        base = sum(int(segment[1:]) for segment in segments[:-1])
        if '[' in segments[-1]:
            matched = _reprog_lut.match(segments[-1])
            base += int(matched.group('offset'))
            bits[base: base + int(matched.group('width'))] = bitarray(matched.group('content'))
        else:
            bits[base + int(segments[-1][1:])] = True
    # emit lines in quad words
    for i in range(qwords):
        ostream.write('{:0>16x}'.format(struct.unpack('<Q', bits[i*64:(i + 1)*64].tobytes())[0]) + '\n')

import argparse
parser = argparse.ArgumentParser(
        description="Bitstream generator for bitchain-style configuration circuitry")

parser.add_argument('context', type=argparse.FileType(OpenMode.r),
        help="Pickled architecture context object")
parser.add_argument('fasm', type=argparse.FileType('r'),
        help="FASM generated by the genfasm util of VPR")
parser.add_argument('memh', type=argparse.FileType('w'),
        help="Generated bitstream in MEMH format for Verilog simulation")

if __name__ == '__main__':
    args = parser.parse_args()
    enable_stdout_logging(__name__, logging.INFO)
    context = ArchitectureContext.unpickle(args.context)
    _logger.info("Architecture context parsed")
    _logger.info("Total number of configuration bits: {}"
            .format(context.config_circuitry_delegate.total_config_bits))
    bitgen_bitchain(context, args.fasm, args.memh)
    _logger.info("Bitstream generated. Bye")
