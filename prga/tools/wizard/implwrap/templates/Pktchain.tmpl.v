// Automatically generated by PRGA implementation wrapper generator
//
//  Programming circuitry type: 'pktchain'
`include "pktchain.vh"
module implwrap (
    input wire tb_clk
    , input wire tb_rst
    , output reg tb_prog_done
    , input wire [31:0] tb_verbosity
    , input wire [31:0] tb_cycle_cnt
    {%- for name, port in app.ports.items() %}
    , {{ port.direction.case("input", "output") }} wire
        {%- if port.range_ is not none %} [{{ port.range_.stop - port.range_.step }}:{{ port.range_.start }}]{% endif %} {{ name }}
    {%- endfor %}
    );

    // Bitstream stuff
    localparam  MAX_BS_FILESIZE_DWORDS  = 131072;   // max. 1GB bitstream

    // Programming protocol
    localparam  INIT                    = 3'd0,
                RESET                   = 3'd1,
                PROG_WAIT               = 3'd2,
                PROG_HDR                = 3'd3,
                PROG_PLD                = 3'd4,
                PROG_STABLIZING         = 3'd5,
                PROG_DONE               = 3'd6;

    reg [2:0]       state;
    reg [31:0]      wait_cnt;
    reg [31:0]      bs_data [0:MAX_BS_FILESIZE_DWORDS-1];

    wire            disasm_full, asm_empty;
    reg             disasm_wr, asm_rd;
    wire [31:0]     pkt, bsresp;

    wire [`PRGA_PKTCHAIN_PHIT_WIDTH-1:0]    phit_i, phit_o;
    wire phit_i_wr, phit_o_full, phit_i_full, phit_o_wr;

    reg [(1 << (`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2)) - 1:0]  pending_leaves;
    reg [`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2 - 1:0]           pending_cnt;
    reg set_pending, unset_pending;

    integer         num_frames;
    integer         prog_progress;
    reg [15:0]      payload;
    reg reset_payload, dec_payload;

    wire [`PRGA_PKTCHAIN_CHAIN_ID_WIDTH - 1:0]  pkt_branch, pkt_leaf, bsresp_branch, bsresp_leaf;
    assign pkt = bs_data[prog_progress];
    assign pkt_branch = pkt[`PRGA_PKTCHAIN_BRANCH_ID_INDEX];
    assign pkt_leaf = pkt[`PRGA_PKTCHAIN_LEAF_ID_INDEX];
    assign bsresp_branch = bsresp[`PRGA_PKTCHAIN_BRANCH_ID_INDEX];
    assign bsresp_leaf = `PRGA_PKTCHAIN_NUM_LEAVES - 1 - bsresp[`PRGA_PKTCHAIN_LEAF_ID_INDEX];

    // assembler & disassembler
    pktchain_frame_disassemble disasm (
        .prog_clk               (tb_clk)
        ,.prog_rst              (tb_rst)
        ,.frame_full            (disasm_full)
        ,.frame_wr              (disasm_wr)
        ,.frame_i               (pkt)
        ,.phit_wr               (phit_i_wr)
        ,.phit_full             (phit_i_full)
        ,.phit_o                (phit_i)
        );

    pktchain_frame_assemble asm (
        .prog_clk               (tb_clk)
        ,.prog_rst              (tb_rst)
        ,.phit_full             (phit_o_full)
        ,.phit_wr               (phit_o_wr)
        ,.phit_i                (phit_o)
        ,.frame_empty           (asm_empty)
        ,.frame_rd              (asm_rd)
        ,.frame_o               (bsresp)
        );

    // FPGA instance
    {{ summary.top }} dut (
        .prog_clk(tb_clk)
        ,.prog_rst(tb_rst)
        ,.prog_done(state == PROG_DONE)
        ,.phit_i(phit_i)
        ,.phit_i_wr(phit_i_wr)
        ,.phit_i_full(phit_i_full)
        ,.phit_o(phit_o)
        ,.phit_o_wr(phit_o_wr)
        ,.phit_o_full(phit_o_full)
        {%- for port in app.ports.values() %}
            {%- for idx, ((x, y), subtile) in port.iter_io_constraints() %}
        ,.{{- port.direction.case("ipin", "opin") }}_x{{ x }}y{{ y }}_{{ subtile }}({{ port.name }}{%- if idx is not none %}[{{ idx }}]{%- endif %})
            {%- endfor %}
        {%- endfor %}
        );

    // Initialization
    initial begin
        tb_prog_done = 1'b0;

        state = INIT;
        wait_cnt = 0;
        disasm_wr = 1'b0;
        asm_rd = 1'b0;
        pending_leaves = { (1 << (`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2)) {1'b0} };
        pending_cnt = { (`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2) {1'b0} };
        set_pending = 1'b0;
        unset_pending = 1'b0;
        payload = 0;
        reset_payload = 1'b0;
        dec_payload = 1'b0;

        if (tb_verbosity > 0)
            $display("[INFO] Bitstream: %s", `BITSTREAM);

        $readmemh(`BITSTREAM, bs_data);
        for (num_frames = 0; num_frames < MAX_BS_FILESIZE_DWORDS && bs_data[num_frames] !== 32'bx;
            num_frames = num_frames + 1) begin
        end
    end

    // Sequential logic
    always @(posedge tb_clk) begin
        if (tb_rst) begin
            pending_cnt <= 0;
            prog_progress <= 0;
            payload <= 0;
        end else begin
            if (~disasm_full && disasm_wr) begin
                prog_progress <= prog_progress + 1;
            end

            if (set_pending) begin
                pending_leaves[{pkt_branch, pkt_leaf}] <= 1'b1;
                pending_cnt <= pending_cnt + 1;
            end else if (unset_pending) begin
                pending_leaves[{bsresp_branch, bsresp_leaf}] <= 1'b0;
                pending_cnt <= pending_cnt - 1;
            end

            if (reset_payload) begin
                payload <= bs_data[prog_progress][`PRGA_PKTCHAIN_PAYLOAD_INDEX];
            end else if (dec_payload) begin
                payload <= payload - 1;
            end
        end
    end

    // Programming FSM
    always @(posedge tb_clk) begin
        if (tb_rst) begin
            state <= RESET;
            wait_cnt <= 0;
        end else begin
            case (state)
                RESET:  state <= PROG_WAIT;
                PROG_WAIT: begin
                    if (wait_cnt == 100) begin
                        state <= PROG_HDR;
                    end else begin
                        wait_cnt <= wait_cnt + 1;
                    end
                end
                PROG_HDR: begin
                    if (~asm_empty) begin
                        if (bsresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] != 0) begin
                            $display("[ERROR] [Cycle %04d] Response payload (%d) > 0", tb_cycle_cnt, bsresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX]);
                            $finish;
                        end else if (bsresp_branch >= `PRGA_PKTCHAIN_NUM_BRANCHES) begin
                            $display("[ERROR] [Cycle %04d] Response BRANCH_ID (%d) > #branches (%d)", tb_cycle_cnt, bsresp_branch, `PRGA_PKTCHAIN_NUM_BRANCHES);
                            $finish;
                        end else if (bsresp_leaf >= `PRGA_PKTCHAIN_NUM_LEAVES) begin
                            $display("[ERROR] [Cycle %04d] Response LEAF_ID (%d) > #leaves (%d)", tb_cycle_cnt, bsresp_leaf, `PRGA_PKTCHAIN_NUM_LEAVES);
                            $finish;
                        end else if (!pending_leaves[{bsresp_branch, bsresp_leaf}]) begin
                            $display("[ERROR] [Cycle %04d] Not expecting response from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                            $finish;
                        end else begin
                            case (bsresp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE: begin
                                    $display("[ERROR] [Cycle %04d] Unknown msg type error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_ECHO_MISMATCH: begin
                                    $display("[ERROR] [Cycle %04d] Echo mismatch error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_CHECKSUM_MISMATCH: begin
                                    $display("[ERROR] [Cycle %04d] Checksum mismatch error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK: begin
                                    $display("[INFO] [Cycle %04d] DATA_ACK received from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                end
                                default: begin
                                    $display("[ERROR] [Cycle %04d] Unknown response: %08x", tb_cycle_cnt, bsresp);
                                    $finish;
                                end
                            endcase
                        end
                    end else if (bs_data[prog_progress] === 32'bx) begin
                        $display("[INFO] [Cycle %04d] Bitstream writing complete", tb_cycle_cnt);
                        state <= PROG_STABLIZING;
                    end else begin
                        if (pkt_branch >= `PRGA_PKTCHAIN_NUM_BRANCHES) begin
                            $display("[ERROR] [Cycle %04d] Packet BRANCH_ID (%d) > #branches (%d)", tb_cycle_cnt, pkt_branch, `PRGA_PKTCHAIN_NUM_BRANCHES);
                            $finish;
                        end else if (pkt_leaf >= `PRGA_PKTCHAIN_NUM_LEAVES) begin
                            $display("[ERROR] [Cycle %04d] Packet LEAF_ID (%d) > #leaves (%d)", tb_cycle_cnt, pkt_leaf, `PRGA_PKTCHAIN_NUM_LEAVES);
                            $finish;
                        end else if (pending_leaves[{pkt_branch, pkt_leaf}]) begin
                            $display("[ERROR] [Cycle %04d] CHECKSUM already sent to (%d, %d)", tb_cycle_cnt, pkt_branch, pkt_leaf);
                            $finish;
                        end else begin
                            if (~disasm_full) begin
                                case (pkt[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                                    `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT: begin
                                        $display("[INFO] [Cycle %04d] INIT sent to (%d, %d)", tb_cycle_cnt, pkt_branch, pkt_leaf);
                                    end
                                    `PRGA_PKTCHAIN_MSG_TYPE_DATA: begin
                                        $display("[INFO] [Cycle %04d] DATA sent to (%d, %d)", tb_cycle_cnt, pkt_branch, pkt_leaf);
                                    end
                                    `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM: begin
                                        $display("[INFO] [Cycle %04d] CHECKSUM sent to (%d, %d)", tb_cycle_cnt, pkt_branch, pkt_leaf);
                                    end
                                    `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM: begin
                                        $display("[INFO] [Cycle %04d] INIT_CHECKSUM sent to (%d, %d)", tb_cycle_cnt, pkt_branch, pkt_leaf);
                                    end
                                    default: begin
                                        $display("[ERROR] [Cycle %04d] Unknown packet: %08x", tb_cycle_cnt, pkt);
                                        $finish;
                                    end
                                endcase

                                if (pkt[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                                    state <= PROG_PLD;
                                end
                            end
                        end
                    end
                end
                PROG_PLD: begin
                    if (bs_data[prog_progress] === 32'bx) begin
                        $display("[ERROR] [Cycle %04d] Incomplete packet, %d frames left", tb_cycle_cnt, payload);
                        $finish;
                    end else if (~disasm_full && payload == 1) begin
                        state <= PROG_HDR;
                    end
                end
                PROG_STABLIZING: begin
                    if (pending_cnt == 0) begin
                        $display("[INFO] [Cycle %04d] Bitstream loading complete", tb_cycle_cnt);
                        state <= PROG_DONE;
                    end else if (~asm_empty) begin
                        if (bsresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] != 0) begin
                            $display("[ERROR] [Cycle %04d] Response payload (%d) > 0", tb_cycle_cnt, bsresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX]);
                            $finish;
                        end else if (bsresp_branch >= `PRGA_PKTCHAIN_NUM_BRANCHES) begin
                            $display("[ERROR] [Cycle %04d] Response BRANCH_ID (%d) > #branches (%d)", tb_cycle_cnt, bsresp_branch, `PRGA_PKTCHAIN_NUM_BRANCHES);
                            $finish;
                        end else if (bsresp_leaf >= `PRGA_PKTCHAIN_NUM_LEAVES) begin
                            $display("[ERROR] [Cycle %04d] Response LEAF_ID (%d) > #leaves (%d)", tb_cycle_cnt, bsresp_leaf, `PRGA_PKTCHAIN_NUM_LEAVES);
                            $finish;
                        end else if (!pending_leaves[{bsresp_branch, bsresp_leaf}]) begin
                            $display("[ERROR] [Cycle %04d] Not expecting response from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                            $finish;
                        end else begin
                            case (bsresp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE: begin
                                    $display("[ERROR] [Cycle %04d] Unknown msg type error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_ECHO_MISMATCH: begin
                                    $display("[ERROR] [Cycle %04d] Echo mismatch error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_ERROR_CHECKSUM_MISMATCH: begin
                                    $display("[ERROR] [Cycle %04d] Checksum mismatch error from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                    $finish;
                                end
                                `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK: begin
                                    $display("[INFO] [Cycle %04d] DATA_ACK received from (%d, %d)", tb_cycle_cnt, bsresp_branch, bsresp_leaf);
                                end
                                default: begin
                                    $display("[ERROR] [Cycle %04d] Unknown response: %08x", tb_cycle_cnt, bsresp);
                                    $finish;
                                end
                            endcase
                        end
                    end
                end
            endcase
        end
    end

    // Programming data
    always @* begin
        disasm_wr = 'b0;
        asm_rd = 'b0;
        set_pending = 'b0;
        unset_pending = 'b0;
        reset_payload = 'b0;
        dec_payload = 'b0;

        case (state)
            PROG_HDR: begin
                if (~asm_empty) begin
                    if (bsresp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK) begin
                        asm_rd = 'b1;
                        unset_pending = 'b1;
                    end
                end else begin
                    disasm_wr = 'b1;

                    if (~disasm_full) begin
                        reset_payload = 'b1;
                        set_pending = (pkt[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM ||
                                      pkt[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM);
                    end
                end
            end
            PROG_PLD: begin
                disasm_wr = 'b1;
                dec_payload = ~disasm_full;
            end
            PROG_STABLIZING: begin
                if (~asm_empty && bsresp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK) begin
                    asm_rd = 'b1;
                    unset_pending = 'b1;
                end
            end
        endcase
    end

    // Progress tracking
    reg [7:0]   prog_percentage;

    always @(posedge tb_clk) begin
        if (tb_rst) begin
            prog_percentage <= 8'b0;
        end else begin
            if (prog_progress * 100 / num_frames > prog_percentage) begin
                prog_percentage <= prog_percentage + 1;

                if (tb_verbosity > 0)
                    $display("[INFO] Programming progress: %02d%%", prog_percentage + 1);
            end
        end
    end

    // tb prog_done
    reg [31:0]  prog_done_cnt;

    always @(posedge tb_clk) begin
        if (tb_rst) begin
            prog_done_cnt <= 100;
            tb_prog_done <= 1'b0;
        end else if (state == PROG_DONE && prog_done_cnt > 0) begin
            prog_done_cnt <= prog_done_cnt - 1;

            if (prog_done_cnt == 1)
                tb_prog_done <= 1'b1;
        end
    end

endmodule
