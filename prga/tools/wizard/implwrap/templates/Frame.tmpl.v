// Automatically generated by PRGA implementation wrapper generator
//
//  Programming circuitry type: 'frame'
`include "prga_frame.vh"
module implwrap (
    input wire tb_clk
    , input wire tb_rst
    , output reg tb_prog_done
    , input wire [31:0] tb_verbosity
    , input wire [31:0] tb_cycle_cnt
    {%- for name, port in app.ports.items() %}
    , {{ port.direction.case("input", "output") }} wire
        {%- if port.range_ is not none %} [{{ port.range_.stop - port.range_.step }}:{{ port.range_.start }}]{% endif %} {{ name }}
    {%- endfor %}
    );

    // Bitstream stuff
    localparam  MAX_BS_FILESIZE_DWORDS  = 131072;   // max. 1GB bitstream

    // FSM
    localparam  INIT                    = 3'd0,
                RESET                   = 3'd1,
                PROG_WAIT               = 3'd2,
                PROG_INST               = 3'd3,
                PROG_DATA               = 3'd4,
                PROG_STABLIZING         = 3'd5,
                PROG_DONE               = 3'd6;

    reg [2:0]       state, state_next;
    reg [31:0]      wait_cnt;
    reg [31:0]      bs_data [0:MAX_BS_FILESIZE_DWORDS-1];

    reg                                 prog_ce;
    reg                                 prog_we;
    reg [71:0]                          prog_addr, prog_addr_next;
    reg [`PRGA_FRAME_DATA_WIDTH-1:0]    prog_din;

    reg [23:0]                          word_cnt, word_cnt_next;

    integer num_dwords, pc, pc_next;

    wire [31:0]      inst;
    assign inst = bs_data[pc];

    // Initialization
    initial begin
        tb_prog_done = 1'b0;
        state = INIT;

        if (tb_verbosity > 0)
            $display("[INFO] Bitstream: %s", `BITSTREAM);

        $readmemh(`BITSTREAM, bs_data);
        for (num_dwords = 0; num_dwords < MAX_BS_FILESIZE_DWORDS && bs_data[num_dwords] !== 32'bx;
            num_dwords = num_dwords + 1) begin
        end
    end

    // Buffer
    reg [63:0]                          buffer, buffer_next;
    reg [6:0]                           buffer_size, buffer_size_next;
    reg                                 buffer_push, buffer_clear;

    always @(posedge tb_clk) begin
        if (tb_rst) begin
            buffer      <= 64'd0;
            buffer_size <= 7'd0;
        end else begin
            buffer      <= buffer_next;
            buffer_size <= buffer_size_next;
        end
    end

    always @* begin
        buffer_next = buffer;
        buffer_size_next = buffer_size;
        prog_din = buffer[0 +: `PRGA_FRAME_DATA_WIDTH];

        if (buffer_clear) begin
            buffer_next = 64'd0;
            buffer_size_next = 7'd0;
        end else begin
            if (prog_ce && prog_we) begin
                buffer_next = buffer >> `PRGA_FRAME_DATA_WIDTH;
                buffer_size_next = buffer_size - `PRGA_FRAME_DATA_WIDTH;
            end

            if (buffer_push) begin
                buffer_next[buffer_size_next+:32] = inst;
                buffer_size_next = buffer_size_next + 32;
            end
        end

    end

    // Sequential logic
    always @(posedge tb_clk) begin
        if (tb_rst) begin
            state           <= RESET;
            pc              <= 0;
            wait_cnt        <= 32'd0;
            prog_addr       <= 72'h0;
            word_cnt        <= 24'd0;
        end else begin
            state           <= state_next;
            pc              <= pc_next;
            prog_addr       <= prog_addr_next;
            word_cnt        <= word_cnt_next;

            if (state == PROG_WAIT || state == PROG_STABLIZING) begin
                wait_cnt    <= wait_cnt + 1;
            end else begin
                wait_cnt    <= 32'd0;
            end
        end
    end

    // FSM
    always @* begin
        state_next = state;
        pc_next = pc;
        prog_ce = 1'b0;
        prog_we = 1'b0;
        prog_addr_next = prog_addr;
        word_cnt_next = word_cnt;
        buffer_push = 1'b0;
        buffer_clear = 1'b1;

        case (state)
            RESET: begin
                state_next = PROG_WAIT;
            end
            PROG_WAIT: begin
                if (wait_cnt == 32'd99) begin
                    state_next = PROG_INST;
                end
            end
            PROG_INST: begin
                pc_next = pc + 1;

                // parity check the instruction
                if (^{inst[16+:8], inst[`PRGA_FRAME_INST_PARITY_BYTE2]}) begin
                    $display("[ERROR] [BS DWORD %06d] Parity check failed w/ Byte 2", pc);
                    $finish;
                end else if (^{inst[8+:8], inst[`PRGA_FRAME_INST_PARITY_BYTE1]}) begin
                    $display("[ERROR] [BS DWORD %06d] Parity check failed w/ Byte 1", pc);
                    $finish;
                end else if (^{inst[0+:8], inst[`PRGA_FRAME_INST_PARITY_BYTE0]}) begin
                    $display("[ERROR] [BS DWORD %06d] Parity check failed w/ Byte 0", pc);
                    $finish;
                end else if (^inst[24+:8]) begin
                    $display("[ERROR] [BS DWORD %06d] Parity check failed w/ Header", pc);
                    $finish;
                end else begin
                    case (inst[`PRGA_FRAME_INST_OPCODE_BASE +: `PRGA_FRAME_INST_OPCODE_WIDTH])
                        `PRGA_FRAME_INST_OPCODE_SOB: begin
                            if (inst[0+:24] != `PRGA_FRAME_INST_MAGIC_SOB) begin
                                $display("[ERROR] [BS DWORD %06d] Magic number mismatch (SOB: 0x%h)",
                                    pc, `PRGA_FRAME_INST_MAGIC_SOB);
                                $finish;
                            end else begin
                                prog_addr_next = 72'h0;
                            end
                        end
                        `PRGA_FRAME_INST_OPCODE_NOP: begin
                            if (inst[0+:24] != `PRGA_FRAME_INST_MAGIC_NOP) begin
                                $display("[ERROR] [BS DWORD %06d] Magic number mismatch (NOP: 0x%h)",
                                    pc, `PRGA_FRAME_INST_MAGIC_NOP);
                                $finish;
                            end
                        end
                        `PRGA_FRAME_INST_OPCODE_EOB: begin
                            if (inst[0+:24] != `PRGA_FRAME_INST_MAGIC_EOB) begin
                                $display("[ERROR] [BS DWORD %06d] Magic number mismatch (EOB: 0x%h)",
                                    pc, `PRGA_FRAME_INST_MAGIC_EOB);
                                $finish;
                            end else begin
                                state_next = PROG_STABLIZING;
                            end
                        end
                        `PRGA_FRAME_INST_OPCODE_JR: begin
                            // signed extension
                            prog_addr_next = prog_addr + { {48{inst[23]}}, inst[0+:24] };
                        end
                        `PRGA_FRAME_INST_OPCODE_JAL: begin
                            prog_addr_next[ 0+:24] = inst[0+:24];
                        end
                        `PRGA_FRAME_INST_OPCODE_JAH: begin
                            prog_addr_next[24+:24] = inst[0+:24];
                        end
                        `PRGA_FRAME_INST_OPCODE_JAE: begin
                            prog_addr_next[48+:24] = inst[0+:24];
                        end
                        `PRGA_FRAME_INST_OPCODE_DATA: begin
                            word_cnt_next = inst[0+:24];
                            state_next = PROG_DATA;
                        end
                        default: begin
                            $display("[ERROR] [BS DWORD %06d] Unsupported or unknown opcode: 0x%01h",
                                pc, inst[`PRGA_FRAME_INST_OPCODE_BASE +: `PRGA_FRAME_INST_OPCODE_WIDTH]);
                            $finish;
                        end
                    endcase
                end
            end
            PROG_DATA: begin
                buffer_clear = 1'b0;

                if (buffer_size >= `PRGA_FRAME_DATA_WIDTH) begin
                    prog_ce = 1'b1;
                    prog_we = 1'b1;
                    prog_addr_next = prog_addr + 1;

                    if (word_cnt == 0) begin
                        buffer_clear = 1'b1;
                        state_next = PROG_INST;
                    end else begin
                        word_cnt_next = word_cnt - 1;

                        if (buffer_size < 2 * `PRGA_FRAME_DATA_WIDTH) begin
                            buffer_push = 1'b1;
                            pc_next = pc + 1;
                        end
                    end
                end else begin
                    buffer_push = 1'b1;
                    pc_next = pc + 1;
                end
            end
            PROG_STABLIZING: begin
                if (wait_cnt == 32'd99) begin
                    state_next = PROG_DONE;
                end
            end
        endcase
    end

    // FPGA instance
    {{ summary.top }} dut (
        .prog_clk(tb_clk)
        ,.prog_rst(tb_rst)
        ,.prog_done(state == PROG_DONE)
        ,.prog_ce(prog_ce)
        ,.prog_we(prog_we)
        ,.prog_addr(prog_addr[0 +: `PRGA_FRAME_ADDR_WIDTH])
        ,.prog_din(prog_din)
        ,.prog_dout()
        {%- for port in app.ports.values() %}
            {%- for idx, ((x, y), subtile) in port.iter_io_constraints() %}
        ,.{{- port.direction.case("ipin", "opin") }}_x{{ x }}y{{ y }}_{{ subtile }}({{ port.name }}{%- if idx is not none %}[{{ idx }}]{%- endif %})
            {%- endfor %}
        {%- endfor %}
        );

    // Progress tracking
    reg [7:0]   prog_percentage;

    always @(posedge tb_clk) begin
        if (tb_rst) begin
            prog_percentage <= 8'b0;
        end else begin
            if (pc * 100 / num_dwords > prog_percentage) begin
                prog_percentage <= prog_percentage + 1;

                if (tb_verbosity > 0)
                    $display("[INFO] Programming progress: %02d%%", prog_percentage + 1);
            end
        end
    end

    // Magic checker
    prga_magic_bitstream_checker i_checker ();

    // tb prog_done
    reg [31:0]  prog_done_cnt;

    always @(posedge tb_clk) begin
        if (tb_rst) begin
            prog_done_cnt <= 100;
            tb_prog_done <= 1'b0;
        end else if (state == PROG_DONE && prog_done_cnt > 0) begin
            prog_done_cnt <= prog_done_cnt - 1;

            if (prog_done_cnt == 1)
                tb_prog_done <= 1'b1;
        end
    end

endmodule
