// Automatically generated by PRGA's RTL generator
{% set width = module.ports.bits_in|length -%}
{% set cfg_width = module.ports.cfg_i|length -%}
`timescale 1ns/1ps
module {{ module.name }} (
    input wire [{{ width - 1 }}:0] bits_in,
    output reg [0:0] out,

    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_e,
    input wire [0:0] cfg_we,
    input wire [{{ cfg_width - 1 }}:0] cfg_i,
    output wire [{{ cfg_width - 1 }}:0] cfg_o
    );

    wire [{{ module.cfg_bitcount - 1 }}:0] cfg_d;
    reg [{{ width - 1 }}:0] internal_in;
    
    // synopsys translate_off
    // in case the sensitivity list is never triggered
    initial begin
        internal_in = 6'b0;
    end
    // synopsys translate_on

    always @* begin
        internal_in = bits_in;

        // synopsys translate_off
        // in simulation, force unconnected LUT input to be zeros
        {%- for i in range(width) %}
        if (bits_in[{{ i }}] === 1'bx) begin
            internal_in[{{ i }}] = 1'b0;
        end
        {%- endfor %}
        // synopsys translate_on
    end

    always @* begin
        if (cfg_e) begin        // avoid program-time oscillating
            out = 1'b0;
        end else begin
            case (internal_in)  // synopsys infer_mux
                {%- for i in range(2 ** width) %}
                {{ width }}'d{{ i }}: out = cfg_d[{{ i }}];
                {%- endfor %}
            endcase
        end
    end

    {{ module.instances.i_cfg_data.model.name }} i_cfg_data (
        .cfg_clk            (cfg_clk)
        ,.cfg_e             (cfg_e)
        ,.cfg_we            (cfg_we)
        ,.cfg_i             (cfg_i)
        ,.cfg_o             (cfg_o)
        ,.cfg_d             (cfg_d)
        );

endmodule
