// Automatically generated by PRGA's RTL generator
{%- set cfg_width = module.ports.cfg_i|length %}
`timescale 1ns/1ps
module mdff (
    // user accessible ports
    input wire [0:0] clk,
    input wire [0:0] D,
    output reg [0:0] Q,
    input wire [0:0] ce,
    input wire [0:0] sr,

    // configuartion ports
    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_e,
    input wire [0:0] cfg_we,
    input wire [{{ cfg_width - 1 }}:0] cfg_i,
    output wire [{{ cfg_width - 1 }}:0] cfg_o
    );

    localparam ENABLE_CE = 0;
    localparam ENABLE_SR = 1;
    localparam SR_SET = 2;

    wire [2:0] cfg_d;
    reg internal_ce, internal_sr;

    always @* begin
        internal_ce = ce;
        internal_sr = sr;

        // synopsys translate_off
        // in simulation, pre-process ce and sr to avoid X-propagation
        if (ce === 1'bx) begin
            internal_ce = 1'b0;
        end

        if (sr === 1'bx) begin
            internal_sr = 1'b0;
        end
        // synopsys translate_on
    end

    always @(posedge clk) begin
        if (cfg_e) begin    // avoid pre-programming oscillation
            Q <= 1'b0;
        end else if (~cfg_d[ENABLE_CE] || internal_ce) begin
            if (cfg_d[ENABLE_SR] && internal_sr) begin
                Q <= cfg_d[SR_SET];
            end else begin
                Q <= D;
            end
        end
    end

    {{ module.instances.i_cfg_data.model.name }} i_cfg_data (
        .cfg_clk            (cfg_clk)
        ,.cfg_e             (cfg_e)
        ,.cfg_we            (cfg_we)
        ,.cfg_i             (cfg_i)
        ,.cfg_o             (cfg_o)
        ,.cfg_d             (cfg_d)
        );

endmodule
