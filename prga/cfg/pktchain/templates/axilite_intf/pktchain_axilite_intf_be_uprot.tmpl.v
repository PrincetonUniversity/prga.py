// Automatically generated by PRGA's RTL generator
`include "pktchain_axilite_intf.vh"
`timescale 1ns/1ps
module pktchain_axilite_intf_be_uprot (
    // system ctrl signals
    input wire [0:0] clk,
    input wire [0:0] rst,

    // async FIFO interfaces
    // write request
    input wire [0:0] wreq_empty,
    output wire [0:0] wreq_rd,
    input wire [`PRGA_AXI_ADDR_WIDTH - 1:0] wreq_addr,
    input wire [`PRGA_BYTES_PER_AXI_DATA - 1:0] wreq_strb,
    input wire [`PRGA_AXI_DATA_WIDTH - 1:0] wreq_data,

    // read request
    input wire [0:0] rreq_empty,
    output wire [0:0] rreq_rd,
    input wire [`PRGA_AXI_ADDR_WIDTH - 1:0] rreq_addr,

    // read response
    input wire [0:0] rresp_full,
    output reg [0:0] rresp_wr,
    output reg [`PRGA_AXI_DATA_WIDTH - 1:0] rresp_data,

    // == AXI4-Lite User Interface ===========================================
    output reg [0:0] urst_n,

    output reg [0:0] u_AWVALID,
    input wire [0:0] u_AWREADY,
    output wire [`PRGA_AXI_ADDR_WIDTH - 1:0] u_AWADDR,
    output wire [2:0] u_AWPROT,

    // write data channel
    output reg [0:0] u_WVALID,
    input wire [0:0] u_WREADY,
    output wire [`PRGA_AXI_DATA_WIDTH - 1:0] u_WDATA,
    output wire [`PRGA_BYTES_PER_AXI_DATA - 1:0] u_WSTRB,

    // write response channel
    input wire [0:0] u_BVALID,
    output reg [0:0] u_BREADY,
    input wire [1:0] u_BRESP,

    // read address channel
    output reg [0:0] u_ARVALID,
    input wire [0:0] u_ARREADY,
    output wire [`PRGA_AXI_ADDR_WIDTH - 1:0] u_ARADDR,
    output wire [2:0] u_ARPROT,

    // read data channel
    input wire [0:0] u_RVALID,
    output reg [0:0] u_RREADY,
    input wire [`PRGA_AXI_DATA_WIDTH - 1:0] u_RDATA,
    input wire [1:0] u_RRESP
    );

    // Timeout limit
    reg [`PRGA_TIMER_WIDTH - 1:0] timeout_limit;
    wire [`PRGA_TIMER_WIDTH - 1:0] timeout_limit_next;
    wire timeout_limit_update;

    always @(posedge clk) begin
        if (rst) begin
            timeout_limit <= 'b0;
        end else if (timeout_limit_update) begin
            timeout_limit <= timeout_limit_next;
        end
    end

    // User Error FIFO
    wire uerr_fifo_clr, uerr_fifo_empty, uerr_fifo_full;
    reg uerr_fifo_rd, uerr_fifo_wr;
    wire [`PRGA_AXI_DATA_WIDTH - 1:0] uerr_fifo_dout;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] uerr_fifo_din;

    prga_fifo #(
        .DATA_WIDTH                     (`PRGA_AXI_DATA_WIDTH)
        ,.LOOKAHEAD                     (1)
        ,.DEPTH_LOG2                    (`PRGA_ERR_FIFO_DEPTH_LOG2)
    ) uerr_fifo (
        .clk                            (clk)
        ,.rst                           (rst || uerr_fifo_clr)
        ,.full                          (uerr_fifo_full)
        ,.wr                            (uerr_fifo_wr)
        ,.din                           (uerr_fifo_din)
        ,.empty                         (uerr_fifo_empty)
        ,.rd                            (uerr_fifo_rd)
        ,.dout                          (uerr_fifo_dout)
        );

    // User Reset
    reg [`PRGA_TIMER_WIDTH - 1:0] urst_countdown, urst_countdown_update;

    always @(posedge clk) begin
        if (rst) begin
            urst_n <= 'b0;
            urst_countdown <= 'b0;
        end else begin
            if (urst_countdown_update > 0) begin
                urst_n <= 'b0;
                urst_countdown <= urst_countdown_update;
            end else if (urst_countdown > 0) begin
                urst_countdown <= urst_countdown - 1;

                if (urst_countdown == 1) begin
                    urst_n <= 'b1;
                end
            end
        end
    end

    // user application timed out
    reg utimeout_f;
    reg wreq_timeout, wresp_timeout, rreq_timeout, rresp_timeout;

    always @(posedge clk) begin
        if (urst_n) begin
            utimeout_f <= 'b0;
        end else if (wreq_timeout || wresp_timeout || rreq_timeout || rresp_timeout) begin
            utimeout_f <= 'b1;
        end
    end

    // =======================================================================
    // -- Write Pipeline -----------------------------------------------------
    // =======================================================================
    // Forward declaration of valid/stall signals
    //  fetch,                        execute,  error
    reg stall_wf_addr, stall_wf_data, stall_wx, stall_we;
    reg val_wf;

    // -- Fetch/post stage ---------------------------------------------------
    reg [`PRGA_TIMER_WIDTH - 1:0] wreq_timer;
    reg [`PRGA_AXI_ADDR_WIDTH - 1:0] addr_wf;
    reg [`PRGA_BYTES_PER_AXI_DATA - 1:0] strb_wf;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] data_wf;
    reg addr_val_wf, data_val_wf;
    
    localparam  WF_OP_INVAL         = 2'h0,
                WF_OP_UREG          = 2'h1,
                WF_OP_CERR          = 2'h2,
                WF_OP_UREQ_TIMEOUT  = 2'h3;
    reg [1:0] op_wf;

    always @* begin
        val_wf = addr_val_wf || data_val_wf;
    end

    always @(posedge clk) begin
        if (rst) begin
            addr_wf <= 'b0;
            strb_wf <= 'b0;
            data_wf <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
            addr_val_wf <= 'b0;
            data_val_wf <= 'b0;
            wreq_timer <= 'b0;
        end else begin
            if (~wreq_empty && wreq_rd) begin
                addr_wf <= wreq_addr;
                strb_wf <= wreq_strb;
                data_wf <= wreq_data;
                addr_val_wf <= 'b1;
                data_val_wf <= 'b1;
                wreq_timer <= timeout_limit;
            end else begin
                if (~stall_wf_addr) begin
                    addr_val_wf <= 'b0;
                end

                if (~stall_wf_data) begin
                    data_val_wf <= 'b0;
                end

                if ((u_AWVALID || u_WVALID) && wreq_timer > 0) begin
                    wreq_timer <= wreq_timer - 1;
                end
            end
        end
    end

    assign wreq_rd = (~addr_val_wf || ~stall_wf_addr) && (~data_val_wf || ~stall_wf_data);
    assign u_AWADDR = addr_wf;
    assign u_AWPROT = 'b0;
    assign u_WDATA = data_wf;
    assign u_WSTRB = strb_wf;
    assign timeout_limit_next = data_wf[0 +: `PRGA_TIMER_WIDTH];
    assign timeout_limit_update = val_wf && ~(stall_wf_addr || stall_wf_data) && addr_wf == {`PRGA_CTRL_ADDR_PREFIX, `PRGA_CTRL_ADDR_UREG_TIMEOUT};
    assign uerr_fifo_clr = val_wf && ~(stall_wf_addr || stall_wf_data) && addr_wf == {`PRGA_CTRL_ADDR_PREFIX, `PRGA_CTRL_ADDR_UERR_FIFO};

    always @* begin
        urst_countdown_update = 'b0;
        wreq_timeout = 'b0;
        op_wf = WF_OP_INVAL;
        stall_wf_addr = 'b0;
        stall_wf_data = 'b0;
        u_AWVALID = 'b0;
        u_WVALID = 'b0;

        if (stall_wx) begin
            stall_wf_addr = 'b1;
            stall_wf_data = 'b1;
        end else if (val_wf) begin
            if (addr_wf[`PRGA_AXI_ADDR_WIDTH - 1:`PRGA_CTRL_ADDR_WIDTH] != `PRGA_CTRL_ADDR_PREFIX) begin    // user register
                if (utimeout_f) begin                   // user application has timed out before
                    op_wf = WF_OP_INVAL;
                end else if (wreq_timer == 0) begin     // user application just timed out
                    wreq_timeout = 'b1;
                    op_wf = WF_OP_UREQ_TIMEOUT;
                end else begin
                    u_AWVALID = addr_val_wf;
                    u_WVALID = data_val_wf;
                    stall_wf_addr = addr_val_wf && ~u_AWREADY;
                    stall_wf_data = data_val_wf && ~u_WREADY;
                    op_wf = WF_OP_UREG;
                end
            end else begin                                                                                  // ctrl register
                case (addr_wf[`PRGA_CTRL_ADDR_WIDTH])
                    `PRGA_CTRL_ADDR_URST: begin
                        op_wf = WF_OP_INVAL;
                        urst_countdown_update = data_wf;
                    end
                    `PRGA_CTRL_ADDR_UREG_TIMEOUT,
                    `PRGA_CTRL_ADDR_UERR_FIFO: begin
                        op_wf = WF_OP_INVAL;
                    end
                    default: begin
                        op_wf = WF_OP_CERR;
                    end
                endcase
            end
        end
    end

    // -- Execute/Collect stage ----------------------------------------------
    reg [`PRGA_TIMER_WIDTH - 1:0] wresp_timer;
    reg [`PRGA_AXI_ADDR_WIDTH - 1:0] addr_wx;

    localparam  WX_OP_INVAL             = 3'h0,
                WX_OP_UREG              = 3'h1,
                WX_OP_CERR              = 3'h2,
                WX_OP_UREQ_TIMEOUT      = 3'h3,
                WX_OP_URESP_TIMEOUT     = 3'h4;
    reg [1:0] op_wx_i;
    reg [2:0] op_wx_o;

    always @(posedge clk) begin
        if (rst) begin
            addr_wx <= 'b0;
            op_wx_i <= WF_OP_INVAL;
            wresp_timer <= 'b0;
        end else begin
            if (op_wf != WF_OP_INVAL && ~stall_wf_addr && ~stall_wf_data) begin
                addr_wx <= addr_wf;
                op_wx_i <= op_wf;
            end else if (~stall_wx) begin
                op_wx_i <= WF_OP_INVAL;
            end

            if (op_wf == WF_OP_UREG && ~stall_wf_addr && ~stall_wf_data) begin
                wresp_timer <= timeout_limit;
            end else if (u_BREADY && wresp_timer > 0) begin
                wresp_timer <= wresp_timer - 1;
            end
        end
    end

    always @* begin
        wresp_timeout = 'b0;
        stall_wx = 'b0;
        u_BREADY = 'b0;
        op_wx_o = WX_OP_INVAL;

        if (stall_we) begin
            stall_wx = 'b1;
        end else begin
            case (op_wx_i)
                WF_OP_UREG: begin
                    if (utimeout_f) begin                   // user application has timed out before
                        op_wx_o = WX_OP_INVAL;
                    end else if (wresp_timer == 0) begin    // user application just timed out
                        wresp_timeout = 'b1;
                        op_wx_o = WX_OP_URESP_TIMEOUT;
                    end else begin
                        u_BREADY = 'b1;
                        stall_wx = ~u_BVALID;
                        op_wx_o = WX_OP_UREG;
                    end
                end
                WF_OP_CERR: begin
                    op_wx_o = WX_OP_CERR;
                end
                WF_OP_UREQ_TIMEOUT: begin
                    op_wx_o = WX_OP_UREQ_TIMEOUT;
                end
            endcase
        end
    end

    // =======================================================================
    // -- Read Pipeline ------------------------------------------------------
    // =======================================================================
    // Forward declaration of stall signals
    //  fetch,    execute,  respond,  error
    reg stall_rf, stall_rx, stall_rr, stall_re;
    reg val_rf, val_rx, val_rr, val_re;

    // -- Fetch/post stage ---------------------------------------------------
    reg [`PRGA_TIMER_WIDTH - 1:0] rreq_timer;
    reg [`PRGA_AXI_ADDR_WIDTH - 1:0] addr_rf;

    localparam  RF_OP_CREG          = 2'h0,
                RF_OP_UREG          = 2'h1,
                RF_OP_UAPP_TIMEOUT  = 2'h2,
                RF_OP_UREQ_TIMEOUT  = 2'h3;
    reg [1:0] op_rf;

    always @(posedge clk) begin
        if (rst) begin
            addr_rf <= 'b0;
            val_rf <= 'b0;
            rreq_timer <= 'b0;
        end else begin
            if (~rreq_empty && rreq_rd) begin
                addr_rf <= rreq_addr;
                val_rf <= 'b1;
                rreq_timer <= timeout_limit;
            end else begin
                if (~stall_rf) begin
                    val_rf <= 'b0;
                end

                if (u_ARVALID && rreq_timer > 0) begin
                    rreq_timer <= rreq_timer - 1;
                end
            end
        end
    end

    assign rreq_rd = ~val_rf || ~stall_rf;
    assign u_ARADDR = addr_rf;
    assign u_ARPROT = 'b0;

    always @* begin
        rreq_timeout = 'b0;
        op_rf = RF_OP_CREG;
        stall_rf = 'b0;
        u_ARVALID = 'b0;

        if (stall_rx) begin
            stall_rf = 'b1;
        end else if (val_rf) begin
            if (addr_rf[`PRGA_AXI_ADDR_WIDTH - 1:`PRGA_CTRL_ADDR_WIDTH] != `PRGA_CTRL_ADDR_PREFIX) begin    // user register
                if (utimeout_f) begin
                    op_rf = RF_OP_UAPP_TIMEOUT;
                end else if (rreq_timer == 0) begin     // user application just timed out
                    rreq_timeout = 'b1;
                    op_rf = RF_OP_UREQ_TIMEOUT;
                end else begin
                    u_ARVALID = 'b1;
                    stall_rf = ~u_ARREADY;
                    op_rf = RF_OP_UREG;
                end
            end else begin                                                                                  // ctrl register
                op_rf = RF_OP_CREG;
            end
        end
    end

    // -- Execute/Collect stage ----------------------------------------------
    reg [`PRGA_TIMER_WIDTH - 1:0] rresp_timer;
    reg [`PRGA_AXI_ADDR_WIDTH - 1:0] addr_rx;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] data_rx;

    localparam  RX_OP_INVAL         = 2'h0,
                RX_OP_PLAIN         = 2'h1,
                RX_OP_ERR           = 2'h2;
    reg [1:0] op_rx_i;
    reg [1:0] op_rx_o;

    always @(posedge clk) begin
        if (rst) begin
            addr_rx <= 'b0;
            val_rx <= 'b0;
            op_rx_i <= 'b0;
            rresp_timer <= 'b0;
        end else begin
            if (val_rf && ~stall_rf) begin
                addr_rx <= addr_rf;
                val_rx <= 'b1;
                op_rx_i <= op_rf;
            end else if (~stall_rx) begin
                val_rx <= 'b0;
            end

            if (val_rf && op_rf == RF_OP_UREG && ~stall_rf) begin
                rresp_timer <= timeout_limit;
            end else if (u_RREADY && rresp_timer > 0) begin
                rresp_timer <= rresp_timer - 1;
            end
        end
    end

    always @* begin
        rresp_timeout = 'b0;
        stall_rx = 'b0;
        u_RREADY = 'b0;
        uerr_fifo_rd = 'b0;
        data_rx = {`PRGA_AXI_DATA_WIDTH{1'b0}};
        op_rx_o = RX_OP_INVAL;

        if (stall_rr) begin
            stall_rx = 'b1;
        end else if (val_rx) begin
            case (op_rx_i)
                RF_OP_CREG: begin
                    case (addr_rx)
                        `PRGA_CTRL_ADDR_UREG_TIMEOUT: begin
                            data_rx[0 +: `PRGA_TIMER_WIDTH] = timeout_limit;
                            op_rx_o = RX_OP_PLAIN;
                        end
                        `PRGA_CTRL_ADDR_UERR_FIFO: begin
                            uerr_fifo_rd = 'b1;
                            op_rx_o = RX_OP_PLAIN;

                            if (~uerr_fifo_empty) begin
                                data_rx = uerr_fifo_dout;
                            end
                        end
                        default: begin
                            data_rx[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_INVAL_RD;
                            data_rx[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_rx;
                            op_rx_o = RX_OP_ERR;
                        end
                    endcase
                end
                RF_OP_UREG: begin
                    if (utimeout_f) begin
                        op_rx_o = RX_OP_INVAL;
                    end else if (rresp_timer == 0) begin
                        rresp_timeout = 'b1;
                        data_rx[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_RD;
                        data_rx[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_rx;
                        data_rx[`PRGA_AXI_ADDR_WIDTH +: 4] = 4'b0100;
                        op_rx_o = RX_OP_ERR;
                    end else begin
                        u_RREADY = 'b1;
                        
                        if (u_RVALID) begin
                            if (u_RRESP == 2'h0) begin
                                data_rx = u_RDATA;
                                op_rx_o = RX_OP_PLAIN;
                            end else begin
                                data_rx[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_RD;
                                data_rx[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_rx;
                                data_rx[`PRGA_AXI_ADDR_WIDTH +: 4] = {2'b0, u_RRESP};
                                op_rx_o = RX_OP_ERR;
                            end
                        end else begin
                            stall_rx = 'b1;
                        end
                    end
                end
                RF_OP_UREQ_TIMEOUT: begin
                    data_rx[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_RD;
                    data_rx[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_rx;
                    data_rx[`PRGA_AXI_ADDR_WIDTH +: 4] = 4'b1000;
                    op_rx_o = RX_OP_ERR;
                end
                RF_OP_UAPP_TIMEOUT: begin
                    op_rx_o = RX_OP_PLAIN;
                end
            endcase
        end
    end

    // -- Respond stage ------------------------------------------------------
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] data_rr;
    reg [1:0] op_rr_i;

    always @(posedge clk) begin
        if (rst) begin
            data_rr <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
            op_rr_i <= RX_OP_INVAL;
        end else begin
            if (op_rx_o != RX_OP_INVAL && ~stall_rx) begin
                data_rr <= data_rx;
                op_rr_i <= op_rx_o;
            end else if (~stall_rr) begin
                op_rr_i <= RX_OP_INVAL;
            end
        end
    end

    always @* begin
        rresp_wr = 'b0;
        rresp_data = {`PRGA_AXI_DATA_WIDTH{1'b0}};
        stall_rr = 'b0;
        val_rr = 'b0;

        case (op_rr_i)
            RX_OP_PLAIN: begin
                rresp_wr = 'b1;
                rresp_data = data_rr;
                stall_rr = rresp_full;
            end
            RX_OP_ERR: begin
                rresp_wr = 'b1;
                stall_rr = rresp_full;
                val_rr = 'b1;
            end
        endcase
    end

    // =======================================================================
    // -- Error Pipeline -----------------------------------------------------
    // =======================================================================
    // write error
    reg [`PRGA_AXI_ADDR_WIDTH - 1:0] addr_we;
    reg [2:0] op_we;
    reg [1:0] uresp_we;

    // read error
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] err_re;

    always @(posedge clk) begin
        if (rst) begin
            addr_we <= 'b0;
            op_we <= WX_OP_INVAL;
            uresp_we <= 'b0;
            err_re <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
            val_re <= 'b0;
        end else begin
            if (op_wx_o != WX_OP_INVAL && ~stall_wx) begin
                addr_we <= addr_wx;
                op_we <= op_wx_o;
                uresp_we <= u_BRESP;
            end else if (~stall_we) begin
                op_we <= WX_OP_INVAL;
            end

            if (val_rr && ~stall_rr) begin
                err_re <= data_rr;
                val_re <= 'b1;
            end else if (~stall_re) begin
                val_re <= 'b0;
            end
        end
    end

    always @* begin
        uerr_fifo_wr = 'b0;
        uerr_fifo_din = {`PRGA_AXI_DATA_WIDTH{1'b0}};
        stall_we = 'b0;
        stall_re = 'b0;

        // report read error first
        if (val_re) begin
            uerr_fifo_wr = 'b1;
            uerr_fifo_din = err_re;
        end

        // report write errors
        case (op_we)
            WX_OP_UREG: if (uresp_we != 2'h0) begin
                if (~uerr_fifo_wr) begin
                    uerr_fifo_wr = 'b1;
                    uerr_fifo_din[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_WR;
                    uerr_fifo_din[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_we;
                    uerr_fifo_din[`PRGA_AXI_ADDR_WIDTH +: 4] = {2'b0, uresp_we};
                    // don't stall on uerr_fifo_full
                end else begin
                    stall_we = 'b1;
                end
            end
            WX_OP_CERR: if (~uerr_fifo_wr) begin
                uerr_fifo_wr = 'b1;
                uerr_fifo_din[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_INVAL_WR;
                uerr_fifo_din[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_we;
                // don't stall on uerr_fifo_full
            end else begin
                stall_we = 'b1;
            end
            WX_OP_UREQ_TIMEOUT: if (~uerr_fifo_wr) begin
                uerr_fifo_wr = 'b1;
                uerr_fifo_din[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_WR;
                uerr_fifo_din[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_we;
                uerr_fifo_din[`PRGA_AXI_ADDR_WIDTH +: 4] = 4'b1000;
                // don't stall on uerr_fifo_full
            end else begin
                stall_we = 'b1;
            end
            WX_OP_URESP_TIMEOUT: if (~uerr_fifo_wr) begin
                uerr_fifo_wr = 'b1;
                uerr_fifo_din[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_UREG_WR;
                uerr_fifo_din[0 +: `PRGA_AXI_ADDR_WIDTH] = addr_we;
                uerr_fifo_din[`PRGA_AXI_ADDR_WIDTH +: 4] = 4'b0100;
                // don't stall on uerr_fifo_full
            end else begin
                stall_we = 'b1;
            end
        endcase
    end

endmodule
