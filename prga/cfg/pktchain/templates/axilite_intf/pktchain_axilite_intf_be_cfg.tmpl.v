// Automatically generated by PRGA's RTL generator
`include "pktchain_axilite_intf.vh"
`timescale 1ns/1ps
module pktchain_axilite_intf_be_cfg (
    // system ctrl signals
    input wire [0:0] clk,
    input wire [0:0] rst,

    // CREG (Controller Register) write interface
    input wire [0:0] wval,
    output reg [0:0] wrdy,
    input wire [`PRGA_BYTES_PER_AXI_DATA - 1:0] wstrb,
    input wire [`PRGA_AXI_DATA_WIDTH - 1:0] wdata,

    output reg [0:0] programming,   // programming started but not done yet
    output reg [0:0] success,       // end of programming

    // Error FIFO
    input wire [0:0] errfifo_full,
    output reg [0:0] errfifo_wr,
    output reg [`PRGA_AXI_DATA_WIDTH - 1:0] errfifo_data,

    // programming interface
    output reg [0:0] cfg_rst,
    output reg [0:0] cfg_e,

    // configuration output
    input wire [0:0] cfg_phit_o_full,
    output wire [0:0] cfg_phit_o_wr,
    output wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] cfg_phit_o,

    // configuration input
    output wire [0:0] cfg_phit_i_full,
    input wire [0:0] cfg_phit_i_wr,
    input wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] cfg_phit_i
    );

    // =======================================================================
    // -- Shared Resources ---------------------------------------------------
    // =======================================================================
    // Tile status tracker
    localparam  LOG2_PKTCHAIN_X_TILES = `CLOG2(`PRGA_PKTCHAIN_X_TILES),
                LOG2_PKTCHAIN_Y_TILES = `CLOG2(`PRGA_PKTCHAIN_Y_TILES);
    reg [LOG2_PKTCHAIN_X_TILES - 1:0]   tile_status_tracker_rd_xpos,
                                        tile_status_tracker_rd_xpos_f;
    reg [LOG2_PKTCHAIN_Y_TILES - 1:0]   tile_status_tracker_rd_ypos,
                                        tile_status_tracker_rd_ypos_f;
    wire [`PRGA_PKTCHAIN_Y_TILES * `PRGA_TILE_STATUS_TRACKER_WIDTH - 1:0] tile_status_tracker_col_dout;
    reg [`PRGA_PKTCHAIN_Y_TILES * `PRGA_TILE_STATUS_TRACKER_WIDTH - 1:0] tile_status_tracker_col_din;
    reg tile_status_tracker_col_we;

    prga_ram_1r1w #(
        .DATA_WIDTH                 (`PRGA_PKTCHAIN_Y_TILES * `PRGA_TILE_STATUS_TRACKER_WIDTH)
        ,.ADDR_WIDTH                (LOG2_PKTCHAIN_X_TILES)
        ,.RAM_ROWS                  (`PRGA_PKTCHAIN_X_TILES)
    ) tile_status_tracker (
        .clk                        (clk)
        ,.raddr                     (tile_status_tracker_rd_xpos)
        ,.dout                      (tile_status_tracker_col_dout)
        ,.waddr                     (tile_status_tracker_rd_xpos_f)
        ,.din                       (tile_status_tracker_col_din)
        ,.we                        (tile_status_tracker_col_we)
        );

    always @(posedge clk) begin
        if (rst) begin
            tile_status_tracker_rd_xpos_f <= 'b0;
            tile_status_tracker_rd_ypos_f <= 'b0;
        end else begin
            tile_status_tracker_rd_xpos_f <= tile_status_tracker_rd_xpos;
            tile_status_tracker_rd_ypos_f <= tile_status_tracker_rd_ypos;
        end
    end

    reg [`PRGA_TILE_STATUS_TRACKER_WIDTH - 1:0] tile_status_tracker_dout;
    reg [`PRGA_TILE_STATUS_TRACKER_WIDTH - 1:0] tile_status_tracker_din;

    localparam  TILE_STATUS_TRACKER_OP_INVAL        = 2'b00,
                TILE_STATUS_TRACKER_OP_CLEAR        = 2'b10,
                TILE_STATUS_TRACKER_OP_UPDATE       = 2'b11;
    reg [1:0] tile_status_tracker_op;

    always @* begin
        tile_status_tracker_col_we = 'b0;
        tile_status_tracker_dout = tile_status_tracker_col_dout[tile_status_tracker_rd_ypos_f * `PRGA_TILE_STATUS_TRACKER_WIDTH +:
                                   `PRGA_TILE_STATUS_TRACKER_WIDTH];
        tile_status_tracker_col_din = tile_status_tracker_col_dout;

        case (tile_status_tracker_op)
            TILE_STATUS_TRACKER_OP_CLEAR: begin
                tile_status_tracker_col_we = 'b1;
                tile_status_tracker_col_din = 'b0;
            end
            TILE_STATUS_TRACKER_OP_UPDATE: begin
                tile_status_tracker_col_we = 'b1;
                tile_status_tracker_col_din[tile_status_tracker_rd_ypos_f * `PRGA_TILE_STATUS_TRACKER_WIDTH +:
                    `PRGA_TILE_STATUS_TRACKER_WIDTH] = tile_status_tracker_din;
            end
        endcase
    end

    // =======================================================================
    // -- Bitstream Frame Input ----------------------------------------------
    // =======================================================================
    // Raw data fifo
    wire [`PRGA_AXI_DATA_WIDTH + `PRGA_BYTES_PER_AXI_DATA - 1:0] rawq_din, rawq_dout;
    wire rawq_full, rawq_empty, rawq_rd;

    // put byte enable close to each byte (so the resizer can grab those correctly)
    genvar disasm_i;
    generate
        for (disasm_i = 0; disasm_i < `PRGA_BYTES_PER_AXI_DATA; disasm_i = disasm_i + 1) begin: raw_disasm
            assign rawq_din[disasm_i * 9 +: 9] = {wstrb[disasm_i], wdata[disasm_i * 8 +: 8]};
        end
    endgenerate

    prga_fifo #(
        .DATA_WIDTH             (`PRGA_AXI_DATA_WIDTH + `PRGA_BYTES_PER_AXI_DATA)
        ,.LOOKAHEAD             (0)
    ) i_rawq (
        .clk                    (clk)
        ,.rst                   (rst)
        ,.full                  (rawq_full)
        ,.wr                    (wval && wrdy)
        ,.din                   (rawq_din)
        ,.empty                 (rawq_empty)
        ,.rd                    (rawq_rd)
        ,.dout                  (rawq_dout)
        );

    // Resizer
    wire [`PRGA_PKTCHAIN_FRAME_SIZE + `PRGA_BYTES_PER_FRAME - 1:0] resizer_dout;
    wire resizer_empty, resizer_rd;

    prga_fifo_resizer #(
        .DATA_WIDTH             (`PRGA_PKTCHAIN_FRAME_SIZE + `PRGA_BYTES_PER_FRAME)
        ,.INPUT_MULTIPLIER      (`PRGA_FRAMES_PER_AXI_DATA)
        ,.INPUT_LOOKAHEAD       (0)
        ,.OUTPUT_LOOKAHEAD      (1)
    ) i_resizer (
        .clk                    (clk)
        ,.rst                   (rst)
        ,.empty_i               (rawq_empty)
        ,.rd_i                  (rawq_rd)
        ,.dout_i                (rawq_dout)
        ,.empty                 (resizer_empty)
        ,.rd                    (resizer_rd)
        ,.dout                  (resizer_dout)
        );

    // re-assemble bitstream frame
    wire [`PRGA_BYTES_PER_FRAME - 1:0] frame_tmp_mask;
    wire [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] frame_tmp;

    genvar asm_i;
    generate
        for (asm_i = 0; asm_i < `PRGA_BYTES_PER_FRAME; asm_i = asm_i + 1) begin: bsframe_asm
            assign {frame_tmp_mask[asm_i], frame_tmp[asm_i * 8 +: 8]} = resizer_dout[asm_i * 9 +: 9];
        end
    endgenerate

    // register frame
    reg [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] frame_i;
    reg frame_i_val, frame_i_stall;

    always @(posedge clk) begin
        if (rst) begin
            frame_i_val <= 'b0;
            frame_i <= 'b0;
        end else if (~frame_i_stall) begin
            if (~resizer_empty && (&frame_tmp_mask)) begin
                frame_i_val <= 'b1;
                frame_i <= frame_tmp;
            end else begin
                frame_i_val <= 'b0;
            end
        end
    end

    assign resizer_rd = ~( (&frame_tmp_mask) && frame_i_stall );

    // =======================================================================
    // -- Bitstream Frame output ---------------------------------------------
    // =======================================================================
    wire frame_o_stall;
    reg frame_o_val;

    pktchain_frame_disassemble #(
        .DEPTH_LOG2             (11 - `PRGA_PKTCHAIN_PHIT_WIDTH_LOG2)   // buffer capacity: 64 frames
    ) i_frameq (
        .cfg_clk                (clk)
        ,.cfg_rst               (cfg_rst)
        ,.frame_full            (frame_o_stall)
        ,.frame_wr              (frame_o_val)
        ,.frame_i               (frame_i)
        ,.phit_wr               (cfg_phit_o_wr)
        ,.phit_full             (cfg_phit_o_full)
        ,.phit_o                (cfg_phit_o)
        );

    // =======================================================================
    // -- Bitstream Response Input -------------------------------------------
    // =======================================================================
    wire respq_empty, resp_val;
    reg resp_stall;
    wire [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] resp;

    pktchain_frame_assemble #(
        .DEPTH_LOG2             (2)
    ) i_respq (
        .cfg_clk                (clk)
        ,.cfg_rst               (cfg_rst)
        ,.phit_full             (cfg_phit_i_full)
        ,.phit_wr               (cfg_phit_i_wr)
        ,.phit_i                (cfg_phit_i)
        ,.frame_empty           (respq_empty)
        ,.frame_rd              (~resp_stall)
        ,.frame_o               (resp)
        );

    assign resp_val = ~respq_empty;

    // =======================================================================
    // -- Main FSM -----------------------------------------------------------
    // =======================================================================
    // PHASE (state of this configuration backend)
    localparam  PHASE_RST                   = 4'h0,     // system is just reset
                PHASE_CLR_TILE_STAT_TRCKERS = 4'h1,     // clearing tile status trackers
                PHASE_STANDBY               = 4'h2,     // waiting for the SOB packet
                PHASE_PROG                  = 4'h3,     // actively accepting bitstream
                PHASE_STBLIZ                = 4'h4,     // stop accepting bitstream and focus on collecting pending responses
                PHASE_SUCCESS               = 4'h5,     // programming completed successfully
                PHASE_FAIL                  = 4'h6;     // programming failed

    reg [3:0] phase, phase_next;

    reg [`PRGA_PKTCHAIN_POS_WIDTH * 2 - 1:0] init_tiles, init_tiles_next;
    reg [`PRGA_PKTCHAIN_POS_WIDTH * 2 - 1:0] pending_tiles, pending_tiles_next;
    reg [`PRGA_PKTCHAIN_POS_WIDTH * 2 - 1:0] err_tiles, err_tiles_next;

    always @(posedge clk) begin
        if (rst) begin
            phase <= PHASE_RST;
            init_tiles <= 'b0;
            pending_tiles <= 'b0;
            err_tiles <= 'b0;
        end else begin
            phase <= phase_next;
            init_tiles <= init_tiles_next;
            pending_tiles <= pending_tiles_next;
            err_tiles <= err_tiles_next;
        end
    end

    always @* begin
        wrdy = 'b0;
        programming = 'b0;
        success = 'b0;
        cfg_rst = 'b0;
        cfg_e = 'b0;

        case (phase)
            PHASE_RST,
            PHASE_CLR_TILE_STAT_TRCKERS: begin
                cfg_rst = 'b1;
                cfg_e = 'b1;
            end
            PHASE_STANDBY: begin
                wrdy = ~rawq_full;
                cfg_rst = 'b1;
                cfg_e = 'b1;
            end
            PHASE_PROG: begin
                wrdy = ~rawq_full;
                programming = 'b1;
                cfg_e = 'b1;
            end
            PHASE_STBLIZ: begin
                programming = 'b1;
                cfg_e = 'b1;
            end
            PHASE_SUCCESS: begin
                success = 'b1;
            end
        endcase
    end
    
    // =======================================================================
    // -- Error FIFO Arbitration ---------------------------------------------
    // =======================================================================
    reg phase_err_val, phase_err_val_f, phase_err_stall;
    reg resp_err_val, resp_err_val_f, resp_err_stall;
    reg bl_err_val, bl_err_val_f, bl_err_stall;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] phase_err, phase_err_f, resp_err, resp_err_f, bl_err, bl_err_f;

    always @(posedge clk) begin
        if (rst) begin
            phase_err_val_f <= 'b0;
            phase_err_f <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
            resp_err_val_f <= 'b0;
            resp_err_f <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
            bl_err_val_f <= 'b0;
            bl_err_f <= {`PRGA_AXI_DATA_WIDTH{1'b0}};
        end else begin
            if (~phase_err_stall) begin
                if (phase_err_val) begin
                    phase_err_val_f <= 'b1;
                    phase_err_f <= phase_err;
                end else begin
                    phase_err_val_f <= 'b0;
                end
            end

            if (~resp_err_stall) begin
                if (resp_err_val) begin
                    resp_err_val_f <= 'b1;
                    resp_err_f <= resp_err;
                end else begin
                    resp_err_val_f <= 'b0;
                end
            end

            if (~bl_err_stall) begin
                if (bl_err_val) begin
                    bl_err_val_f <= 'b1;
                    bl_err_f <= bl_err;
                end else begin
                    bl_err_val_f <= 'b0;
                end
            end
        end
    end

    always @* begin
        if (phase_err_val_f) begin
            errfifo_wr = 'b1;
            errfifo_data = phase_err_f;
            phase_err_stall = errfifo_full;
            resp_err_stall = resp_err_val_f;
            bl_err_stall = bl_err_val_f;
        end else if (resp_err_val_f) begin
            errfifo_wr = 'b1;
            errfifo_data = resp_err_f;
            phase_err_stall = 'b0;
            resp_err_stall = errfifo_full;
            bl_err_stall = bl_err_val_f;
        end else begin
            errfifo_wr = bl_err_val_f;
            errfifo_data = bl_err_f;
            phase_err_stall = 'b0;
            resp_err_stall = 'b0;
            bl_err_stall = bl_err_val_f && errfifo_full;
        end
    end

    // =======================================================================
    // -- Frame Pipeline -----------------------------------------------------
    // =======================================================================
    localparam  ST_IDLE             = 2'h0,
                ST_HDR              = 2'h1,
                ST_PLD_DUMP         = 2'h2,
                ST_PLD_FWD          = 2'h3;

    reg [1:0] bl_st, bl_st_next, resp_st, resp_st_next;
    reg [`PRGA_PKTCHAIN_PAYLOAD_WIDTH:0] bl_pldcnt, bl_pldcnt_next, resp_pldcnt, resp_pldcnt_next;

    // resource management helpers
    reg tile_status_tracker_busy;

    always @(posedge clk) begin
        if (rst) begin
            bl_st <= ST_IDLE;
            resp_st <= ST_IDLE;
            bl_pldcnt <= 'b0;
            resp_pldcnt <= 'b0;
        end else begin
            bl_st <= bl_st_next;
            resp_st <= resp_st_next;
            bl_pldcnt <= bl_pldcnt_next;
            resp_pldcnt <= resp_pldcnt_next;
        end
    end

    always @* begin
        init_tiles_next = init_tiles;
        pending_tiles_next = pending_tiles;
        err_tiles_next = err_tiles;
        
        tile_status_tracker_rd_xpos = 'b0;
        tile_status_tracker_rd_ypos = 'b0;
        tile_status_tracker_din = tile_status_tracker_dout;
        tile_status_tracker_op = TILE_STATUS_TRACKER_OP_INVAL;
        tile_status_tracker_busy = 'b0;

        // Phase FSM
        phase_next = phase;
        phase_err_val = 'b0;
        phase_err = {`PRGA_AXI_DATA_WIDTH{1'b0}};

        case (phase)
            PHASE_RST: begin
                phase_next = PHASE_CLR_TILE_STAT_TRCKERS;
                init_tiles_next = 'b0;
                pending_tiles_next = 'b0;
                err_tiles_next = 'b0;
                tile_status_tracker_rd_xpos = 'b0;
            end
            PHASE_CLR_TILE_STAT_TRCKERS: begin
                init_tiles_next = 'b0;
                pending_tiles_next = 'b0;
                err_tiles_next = 'b0;
                tile_status_tracker_rd_xpos = tile_status_tracker_rd_xpos_f + 1;
                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_CLEAR;

                if (tile_status_tracker_rd_xpos_f == `PRGA_PKTCHAIN_X_TILES - 1) begin
                    phase_next = PHASE_STANDBY;
                end
            end
            PHASE_STANDBY: begin
                if (bl_st == ST_IDLE && frame_i_val && frame_i == {`PRGA_PKTCHAIN_MSG_TYPE_SOB,
                    {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}}, {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}}, {`PRGA_PKTCHAIN_PAYLOAD_WIDTH{1'b0}}}
                ) begin
                    phase_next = PHASE_PROG;
                end
            end
            PHASE_PROG: begin
                if (bl_st == ST_IDLE && frame_i_val && frame_i == {`PRGA_PKTCHAIN_MSG_TYPE_EOB,
                    {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}}, {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}}, {`PRGA_PKTCHAIN_PAYLOAD_WIDTH{1'b0}}}
                ) begin
                    phase_next = PHASE_STBLIZ;
                end
            end
            PHASE_STBLIZ: begin
                if (pending_tiles == 0) begin
                    if (init_tiles) begin
                        phase_err_val = 'b1;
                        phase_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                        phase_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_INCOMPLETE_TILES;
                        phase_err[0 +: `PRGA_PKTCHAIN_POS_WIDTH * 2] = init_tiles;

                        if (~phase_err_stall) begin
                            phase_next = PHASE_FAIL;
                        end
                    end else if (err_tiles) begin
                        phase_err_val = 'b1;
                        phase_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                        phase_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_ERROR_TILES;
                        phase_err[0 +: `PRGA_PKTCHAIN_POS_WIDTH * 2] = err_tiles;

                        if (~phase_err_stall) begin
                            phase_next = PHASE_FAIL;
                        end
                    end else begin
                        phase_next = PHASE_SUCCESS;
                    end
                end
            end
        endcase

        // Prioritize response handling
        resp_st_next = resp_st;
        resp_pldcnt_next = resp_pldcnt;
        resp_stall = 'b0;
        resp_err_val = 'b0;
        resp_err = {`PRGA_AXI_DATA_WIDTH{1'b0}};

        case (resp_st)
            ST_IDLE: if (resp_err_stall || ~(phase == PHASE_PROG || phase == PHASE_STBLIZ)) begin
                resp_stall = 'b1;
            end else if (resp_val) begin
                // validate header
                if (resp[`PRGA_PKTCHAIN_XPOS_INDEX] < `PRGA_PKTCHAIN_X_TILES &&
                    resp[`PRGA_PKTCHAIN_YPOS_INDEX] < `PRGA_PKTCHAIN_Y_TILES &&
                    resp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] == 0
                ) begin
                    case (resp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                        `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_ECHO_MISMATCH,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_CHECKSUM_MISMATCH,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_FEEDTHRU_PACKET: begin
                            // good header. but let's make sure there's no
                            // conflict on the shared resources
                            if (~tile_status_tracker_busy) begin
                                tile_status_tracker_busy = 'b1;     // grab this resource!
                                tile_status_tracker_rd_xpos = resp[`PRGA_PKTCHAIN_XPOS_INDEX];
                                tile_status_tracker_rd_ypos = `PRGA_PKTCHAIN_Y_TILES - 1 - resp[`PRGA_PKTCHAIN_YPOS_INDEX];
                                resp_st_next = ST_HDR;
                            end

                            resp_stall = 'b1;
                        end
                        default: begin
                            // bad header. Unknown message type
                            resp_err_val = 'b1;
                            resp_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                            resp_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_INVAL_RESP;
                            resp_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = resp;
                        end
                    endcase
                end else begin
                    // bad header
                    resp_err_val = 'b1;
                    resp_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                    resp_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_INVAL_RESP;
                    resp_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = resp;

                    if (resp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                        resp_st_next = ST_PLD_DUMP;
                        resp_pldcnt_next = resp[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
                    end
                end
            end
            ST_HDR: begin
                resp_st_next = ST_IDLE;

                // pre-build error (we might not need it)
                resp_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                resp_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_ERR_RESP;
                resp_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = resp;
                resp_err[`PRGA_PKTCHAIN_FRAME_SIZE +: `PRGA_TILE_STATUS_TRACKER_WIDTH] = tile_status_tracker_dout;

                case (tile_status_tracker_dout)
                    `PRGA_TILE_STATUS_PENDING: if (resp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK) begin
                        tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                        tile_status_tracker_din = `PRGA_TILE_STATUS_DONE;
                        pending_tiles_next = pending_tiles - 1;
                    end else begin
                        tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                        tile_status_tracker_din = `PRGA_TILE_STATUS_ERROR;
                        pending_tiles_next = pending_tiles - 1;
                        err_tiles_next = err_tiles + 1;
                        resp_err_val = 'b1;
                    end
                    `PRGA_TILE_STATUS_ERROR: begin
                        resp_err_val = 'b1;
                    end
                    default: begin
                        tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                        tile_status_tracker_din = `PRGA_TILE_STATUS_ERROR;
                        err_tiles_next = err_tiles + 1;
                        resp_err_val = 'b1;

                        if (tile_status_tracker_dout == `PRGA_TILE_STATUS_PROGRAMMING) begin
                            init_tiles_next = init_tiles - 1;
                        end
                    end
                endcase
            end
            ST_PLD_DUMP: if (resp_val) begin
                if (resp_pldcnt == 1) begin
                    resp_st_next = ST_IDLE;
                end else begin
                    resp_pldcnt_next = resp_pldcnt - 1;
                end
            end
        endcase

        // Frame input handling
        bl_st_next = bl_st;
        bl_pldcnt_next = bl_pldcnt;
        frame_i_stall = 'b0;
        frame_o_val = 'b0;
        bl_err_val = 'b0;
        bl_err = {`PRGA_AXI_DATA_WIDTH{1'b0}};

        case (bl_st)
            ST_IDLE: if (frame_i_val) begin
                case (phase)
                    PHASE_STANDBY: if (frame_i != {
                        `PRGA_PKTCHAIN_MSG_TYPE_SOB,
                        {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}},
                        {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}},
                        {`PRGA_PKTCHAIN_PAYLOAD_WIDTH{1'b0}}
                    }) begin
                        bl_err_val = 'b1;
                        bl_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                        bl_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_EXPECTING_SOB;
                        bl_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = frame_i;

                        if (bl_err_stall) begin
                            frame_i_stall = 'b1;
                        end else if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            bl_st_next = ST_PLD_DUMP;
                            bl_pldcnt_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
                        end
                    end
                    PHASE_PROG: if (frame_i == {
                        `PRGA_PKTCHAIN_MSG_TYPE_EOB,
                        {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}},
                        {`PRGA_PKTCHAIN_POS_WIDTH{1'b0}},
                        {`PRGA_PKTCHAIN_PAYLOAD_WIDTH{1'b0}}
                    }) begin
                        frame_i_stall = 'b0;
                    end else if (frame_i[`PRGA_PKTCHAIN_XPOS_INDEX] < `PRGA_PKTCHAIN_X_TILES &&
                        frame_i[`PRGA_PKTCHAIN_YPOS_INDEX] < `PRGA_PKTCHAIN_Y_TILES && (
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM)
                    ) begin
                        if (~bl_err_stall && ~tile_status_tracker_busy) begin
                            tile_status_tracker_busy = 'b1;
                            tile_status_tracker_rd_xpos = frame_i[`PRGA_PKTCHAIN_XPOS_INDEX];
                            tile_status_tracker_rd_ypos = frame_i[`PRGA_PKTCHAIN_YPOS_INDEX];
                            bl_st_next = ST_HDR;
                        end

                        frame_i_stall = 'b1;
                    end else begin
                        bl_err_val = 'b1;
                        bl_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                        bl_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_INVAL_PKT;
                        bl_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = frame_i;

                        if (bl_err_stall) begin
                            frame_i_stall = 'b1;
                        end else if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            bl_st_next = ST_PLD_DUMP;
                            bl_pldcnt_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
                        end
                    end
                    PHASE_FAIL: begin
                        frame_i_stall = 'b0;
                    end
                    default: begin
                        frame_i_stall = 'b1;
                    end
                endcase
            end
            ST_HDR: begin
                // pre-build error
                bl_err[`PRGA_ERR_TYPE_INDEX] = `PRGA_ERR_BITSTREAM;
                bl_err[`PRGA_ERR_BITSTREAM_SUBTYPE_INDEX] = `PRGA_ERR_BITSTREAM_SUBTYPE_ERR_PKT;
                bl_err[0 +: `PRGA_PKTCHAIN_FRAME_SIZE] = frame_i;
                bl_err[`PRGA_PKTCHAIN_FRAME_SIZE +: `PRGA_TILE_STATUS_TRACKER_WIDTH] = tile_status_tracker_dout;

                case (tile_status_tracker_dout)
                    `PRGA_TILE_STATUS_RESET: begin
                        case (frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT: begin
                                init_tiles_next = init_tiles + 1;
                                tile_status_tracker_din = `PRGA_TILE_STATUS_PROGRAMMING;
                                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                                frame_o_val = 'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM: begin
                                pending_tiles_next = pending_tiles + 1;
                                tile_status_tracker_din = `PRGA_TILE_STATUS_PENDING;
                                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                                frame_o_val = 'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA,
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM: begin
                                err_tiles_next = err_tiles + 1;
                                tile_status_tracker_din = `PRGA_TILE_STATUS_ERROR;
                                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                            end
                        endcase
                    end
                    `PRGA_TILE_STATUS_PROGRAMMING: begin
                        case (frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA: begin
                                frame_o_val = 'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM: begin
                                init_tiles_next = init_tiles - 1;
                                pending_tiles_next = pending_tiles + 1;
                                tile_status_tracker_din = `PRGA_TILE_STATUS_PENDING;
                                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                                frame_o_val = 'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT,
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM: begin
                                init_tiles_next = init_tiles - 1;
                                err_tiles_next = err_tiles + 1;
                                tile_status_tracker_din = `PRGA_TILE_STATUS_ERROR;
                                tile_status_tracker_op = TILE_STATUS_TRACKER_OP_UPDATE;
                            end
                        endcase
                    end
                endcase

                if (frame_o_val) begin
                    if (frame_o_stall) begin
                        frame_i_stall = 'b1;
                        bl_pldcnt_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] + 1;
                    end else begin
                        bl_pldcnt_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
                    end

                    if (bl_pldcnt_next > 0) begin
                        bl_st_next = ST_PLD_FWD;
                    end else begin
                        bl_st_next = ST_IDLE;
                    end
                end else begin
                    bl_err_val = 'b1;
                    bl_st_next = ST_IDLE;
                end
            end
            ST_PLD_DUMP: if (frame_i_val) begin
                if (bl_pldcnt == 1) begin
                    bl_st_next = ST_IDLE;
                end else begin
                    bl_pldcnt_next = bl_pldcnt - 1;
                end
            end
            ST_PLD_FWD: if (frame_i_val) begin
                frame_o_val = 'b1;

                if (frame_o_stall) begin
                    frame_i_stall = 'b1;
                end else if (bl_pldcnt == 1) begin
                    bl_st_next = ST_IDLE;
                end else begin
                    bl_pldcnt_next = bl_pldcnt - 1;
                end
            end
        endcase
    end

endmodule
