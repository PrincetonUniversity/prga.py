// Automatically generated by PRGA's RTL generator
{%- set frame_size = 32 %}
{%- set phit_width = module.ports.phit_i|length %}
{%- set cfg_width = module.ports.cfg_i|length %}
`define PHIT_WIDTH {{ phit_width }}
`define CFG_WIDTH {{ cfg_width }}
`define FRAME_SIZE {{ frame_size }}

`define MSG_TYPE_WIDTH 8
`define POS_WIDTH 8
`define PAYLOAD_WIDTH 8

`define PAYLOAD_BASE 0
`define YPOS_BASE (`PAYLOAD_BASE + `PAYLOAD_WIDTH)
`define XPOS_BASE (`YPOS_BASE + `POS_WIDTH)
`define MSG_TYPE_BASE (`XPOS_BASE + `POS_WIDTH)

`define PAYLOAD_INDEX `PAYLOAD_BASE+:`PAYLOAD_WIDTH
`define YPOS_INDEX `YPOS_BASE+:`POS_WIDTH
`define XPOS_INDEX `XPOS_BASE+:`POS_WIDTH
`define MSG_TYPE_INDEX `MSG_TYPE_BASE+:`MSG_TYPE_WIDTH 

module {{ module.name }} (
    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_rst,

    // noc inputs
    output wire [0:0] phit_i_full,
    input wire [0:0] phit_i_wr,
    input wire [`PHIT_WIDTH - 1:0] phit_i,

    // noc outputs
    input wire [0:0] phit_o_full,
    output wire [0:0] phit_o_wr,
    output wire [`PHIT_WIDTH - 1:0] phit_o,

    // chain inputs & outputs
    input wire [0:0] cfg_we_i,
    input wire [`CFG_WIDTH-1:0] cfg_i,

    output wire [0:0] cfg_we_o,
    output wire [`CFG_WIDTH-1:0] cfg_o
    );

    // Physical-level protocol:
    //  phit size = PHIT_WIDTH
    //
    // Link-level protocol:
    //  frame size = 32b (e.g. 4 phits if PHIT_WIDTH == 8)
    //
    // Data-level protocol:
    //  header frame:
    //      8b: message type
    //      8b: x position
    //      8b: y position
    //      8b: payload size (#frames)
    
    {% if frame_size % phit_width != 0 %}
    // The frame size ({{ frame_size }}) is not a multiple of phit width ({{ phit_width }})
    __PRGA_RTLGEN_ERROR__ __PKTCHAIN_UNSUPPORTED_PHIT_WIDTH__();
    {%- endif %}
    {% if cfg_width not in (1, 2, 4) %}
    // The configuration chain width ({{ cfg_width }}) is unsupported (Accepted values: 1, 2, 4)
    __PRGA_RTLGEN_ERROR__ __PKTCHAIN_UNSUPPORTED_CFG_WIDTH__();
    {%- endif %}
    localparam  MSG_TYPE_INVAL                      = `MSG_TYPE_WIDTH'h00,

                // DATA messages
                MSG_TYPE_DATA                       = `MSG_TYPE_WIDTH'h08,
                MSG_TYPE_DATA_INIT                  = `MSG_TYPE_WIDTH'h09,
                MSG_TYPE_DATA_CHECKSUM              = `MSG_TYPE_WIDTH'h0A,
                MSG_TYPE_DATA_INIT_CHECKSUM         = `MSG_TYPE_WIDTH'h0B,
                MSG_TYPE_DATA_ACK                   = `MSG_TYPE_WIDTH'h0F,

                // Control messages
                MSG_TYPE_TEST                       = `MSG_TYPE_WIDTH'h40,

                // error messages
                MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE     = `MSG_TYPE_WIDTH'h80,
                MSG_TYPE_ERROR_ECHO_MISMATCH        = `MSG_TYPE_WIDTH'h81,
                MSG_TYPE_ERROR_CHECKSUM_MISMATCH    = `MSG_TYPE_WIDTH'h82;

    wire frame_i_empty, frame_o_full;
    wire [`FRAME_SIZE - 1:0] frame_i;
    reg [`FRAME_SIZE - 1:0] frame_o;
    reg frame_i_rd, frame_o_wr, frame_clasp_empty;
    reg clasp_init, clasp_checksum;
    wire clasp_programming, clasp_echo_mismatch, clasp_checksum_mismatch;

    pktchain_fifo ififo (
        .cfg_clk        (cfg_clk)
        ,.cfg_rst       (cfg_rst)
        ,.phit_full     (phit_i_full)
        ,.phit_wr       (phit_i_wr)
        ,.phit_i        (phit_i)
        ,.frame_empty   (frame_i_empty)
        ,.frame_rd      (frame_i_rd)
        ,.frame_o       (frame_i)
        );

    pktchain_frame_sender ofifo (
        .cfg_clk        (cfg_clk)
        ,.cfg_rst       (cfg_rst)
        ,.frame_full    (frame_o_full)
        ,.frame_wr      (frame_o_wr)
        ,.frame_i       (frame_o)
        ,.phit_full     (phit_o_full)
        ,.phit_wr       (phit_o_wr)
        ,.phit_o        (phit_o)
        );

    pktchain_clasp clasp (
        .cfg_clk            (cfg_clk)
        ,.cfg_rst           (cfg_rst)
        ,.frame_empty       (frame_clasp_empty)
        ,.frame_rd          (frame_clasp_rd)
        ,.frame_i           (frame_i)
        ,.ctrl_init         (clasp_init)
        ,.ctrl_checksum     (clasp_checksum)
        ,.programming       (clasp_programming)
        ,.echo_mismatch     (clasp_echo_mismatch)
        ,.checksum_mismatch (clasp_checksum_mismatch)
        ,.cfg_we_i          (cfg_we_i)
        ,.cfg_i             (cfg_i)
        ,.cfg_we_o          (cfg_we_o)
        ,.cfg_o             (cfg_o)
        );

    localparam  STATE_RESET                     = 4'h0,
                STATE_IDLE                      = 4'h1,
                STATE_CLASP                     = 4'h2,
                STATE_FORWARDING                = 4'h3,
                STATE_DUMPING                   = 4'h4;

    reg [3:0] state, state_next;
    reg [`PAYLOAD_WIDTH - 1:0] payload;
    reg checksum_pending, checksum_checked;
    reg payload_rst, start_clasp_trx;

    always @(posedge cfg_clk or posedge cfg_rst) begin
        if (cfg_rst) begin
            state <= STATE_RESET;
            payload <= 'b0;
            checksum_pending <= 'b0;
            clasp_init <= 'b0;
        end else begin
            state <= state_next;

            if (payload_rst) begin
                payload <= frame_i[`PAYLOAD_INDEX];
            end else if (payload > 0 && !frame_i_empty && frame_i_rd) begin
                payload <= payload - 1;
            end

            if (start_clasp_trx) begin
                clasp_init <= (frame_i[`MSG_TYPE_INDEX] == MSG_TYPE_DATA_INIT ||
                              frame_i[`MSG_TYPE_INDEX] == MSG_TYPE_DATA_INIT_CHECKSUM);
            end else if (!frame_clasp_empty && frame_clasp_rd) begin
                clasp_init <= 'b0;
            end

            if (start_clasp_trx) begin
                checksum_pending <= (frame_i[`MSG_TYPE_INDEX] == MSG_TYPE_DATA_CHECKSUM ||
                                    frame_i[`MSG_TYPE_INDEX] == MSG_TYPE_DATA_INIT_CHECKSUM);
            end else if (checksum_checked) begin
                checksum_pending <= 'b0;
            end
        end
    end

    always @* begin
        state_next = state;
        frame_i_rd = 'b0;
        frame_o_wr = 'b0;
        frame_o = frame_i;
        frame_clasp_empty = 'b1;
        payload_rst = 'b0;
        clasp_checksum = 'b0;
        checksum_checked = 'b0;
        start_clasp_trx = 'b0;

        case (state)
            STATE_RESET: begin
                state_next = STATE_IDLE;
            end
            STATE_IDLE: begin
                if (checksum_pending && ~clasp_programming) begin
                    frame_o_wr = 'b1;
                    frame_o = ( clasp_echo_mismatch ? MSG_TYPE_ERROR_ECHO_MISMATCH :
                            clasp_checksum_mismatch ? MSG_TYPE_ERROR_CHECKSUM_MISMATCH :
                                                      MSG_TYPE_DATA_ACK ) << `MSG_TYPE_BASE;
                    checksum_checked = ~frame_o_full;
                end else if (~frame_i_empty) begin  // valid input frame
                    case (frame_i[`MSG_TYPE_INDEX])
                        MSG_TYPE_DATA,
                        MSG_TYPE_DATA_INIT,
                        MSG_TYPE_DATA_CHECKSUM,
                        MSG_TYPE_DATA_INIT_CHECKSUM: begin
                            if (frame_i[`YPOS_INDEX] == 0) begin    // this message is for me
                                if (~checksum_pending) begin        // only react if I'm not waiting for the checksum
                                    state_next = STATE_CLASP;
                                    frame_i_rd = 'b1;               // discard message header
                                    payload_rst = 'b1;
                                    start_clasp_trx = 'b1;
                                end
                            end else begin                          // this message is not for me
                                if (~frame_o_full) begin
                                    frame_i_rd = 'b1;
                                    state_next = STATE_FORWARDING;
                                end

                                frame_o_wr = 'b1;
                                frame_o = frame_i - (1 << `YPOS_BASE);
                                payload_rst = 'b1;
                            end
                        end
                        MSG_TYPE_TEST,
                        MSG_TYPE_DATA_ACK,
                        MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE,
                        MSG_TYPE_ERROR_ECHO_MISMATCH,
                        MSG_TYPE_ERROR_CHECKSUM_MISMATCH: begin
                            if (~frame_o_full) begin
                                frame_i_rd = 'b1;
                            end

                            frame_o_wr = 'b1;
                            frame_o = frame_i + (1 << `YPOS_BASE);
                        end
                        default: begin
                            if (~frame_o_full) begin
                                frame_i_rd = 'b1;

                                if (frame_i[`PAYLOAD_INDEX] > 0) begin
                                    state_next = STATE_DUMPING;
                                end
                            end

                            frame_o_wr = 'b1;
                            frame_o = MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE << `MSG_TYPE_BASE;
                            payload_rst = 'b1;
                        end
                    endcase
                end
            end
            STATE_CLASP: begin
                frame_i_rd = frame_clasp_rd;
                frame_clasp_empty = frame_i_empty;
                clasp_checksum = checksum_pending && payload == 1;

                if (payload == 1 && !frame_i_empty && frame_clasp_rd) begin
                    state_next = STATE_IDLE;
                end
            end
            STATE_FORWARDING: begin
                if (payload == 1 && !frame_i_empty && !frame_o_full) begin
                    state_next = STATE_IDLE;
                end

                frame_o_wr = !frame_i_empty;
                frame_i_rd = !frame_o_full;
            end
            STATE_DUMPING: begin
                if (payload == 1 && !frame_i_empty) begin
                    state_next = STATE_IDLE;
                end

                frame_i_rd = 'b1;
            end
        endcase
    end

endmodule
