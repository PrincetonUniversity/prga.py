// Automatically generated by PRGA's RTL generator
{%- macro fill(width, pat) -%}
{ {{- width -}} { {{- pat -}} {{- '}}' }}
{%- endmacro %}
{%- set cfg_width = module.ports.cfg_i|length %}
module {{ module.name }} #(
    localparam CFG_WIDTH = {{ cfg_width }}
) (
    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_e,

    // data from external controller or previous router
    input wire [CFG_WIDTH-1:0] cfg_i,

    // data to external controller or next router
    output reg [CFG_WIDTH-1:0] cfg_o,

    // data to local chain
    output reg [0:0] cfg_we_o,
    output reg [CFG_WIDTH-1:0] cfg_dout,

    input wire [0:0] cfg_we_i,
    input wire [CFG_WIDTH-1:0] cfg_din
    );

    {% if not 1 <= cfg_width <= 8 %}
    // Supported configuration width: [1, 8]
    __PRGA_RTLGEN_ERROR__ __PKTCHAIN_UNSUPPORTED_CFG_WIDTH_{{ cfg_width }}__();
    {%- endif %}

    // =======================================================================
    // Configuration Chain Settings
    // =======================================================================
    //  Physical-level protocol:
    //      phit size = config width
    //
    //  Link-level protocol: frame size = 10x phits
    //      start phit: full-width ones
    //   8x data phits:
    //     parity phit: parity bit per chain
    //
    //  Data-level protocol:
    //    header frame(s): 32b
    //         ...: padding for frame alignment
    //      [[data messages]]
    //          4b: message type
    //         12b: remaining hops to destination tile
    //         16b: payload size (#frames)
    //      [[ctrl messages]]
    //          4b: message type
    //         ...: additional info
    //      [[error messages]]
    //          4b: message type
    //         12b: hops from the source tile
    //         16b: additional info
    //
    //    data frame(s):
    // NxCFG_WIDTH: echo word repeated at least once. More repeats for frame alignment
    //         ...: actual bitstream for the tile
    //
    //    footer frame: 1 frame
    // 8xCFG_WIDTH: CRC-8 checksum (per bit in CFG_WIDTH)

    // =======================================================================
    // Link-level implementation: Frame input
    // =======================================================================
    localparam DATA_PHIT_COUNT_LOG2 = 3;
    localparam DATA_PHIT_COUNT = 1 << DATA_PHIT_COUNT_LOG2;
    localparam FRAME_SIZE = DATA_PHIT_COUNT * CFG_WIDTH;

    reg [CFG_WIDTH-1:0] iphit_buf, iphit_parity;
    reg [1:0] ilnk_state, ilnk_state_next;

    reg [FRAME_SIZE-1:0] iframe;
    reg [DATA_PHIT_COUNT_LOG2-1:0] iphit_cnt;
    reg iframe_val;

    localparam  ILNK_STATE_IDLE         = 2'h0,
                ILNK_STATE_DATA         = 2'h1,
                ILNK_STATE_PARITY       = 2'h2,
                ILNK_STATE_PARITY_ERR   = 2'h3;     // what to do when this happens?
        
    always @(posedge cfg_clk) begin
        iphit_buf <= cfg_i;

        if (~cfg_e) begin
            ilnk_state <= ILNK_STATE_IDLE;
            iphit_parity <= 'b0;
            iframe <= 'b0;
            iphit_cnt <= 'b0;
        end else begin
            ilnk_state <= ilnk_state_next;

            if (ilnk_state == ILNK_STATE_IDLE) begin
                iphit_parity <= 'b0;
                iframe <= 'b0;
                iphit_cnt <= 'b0;
            end else if (ilnk_state == ILNK_STATE_DATA) begin
                iphit_parity <= iphit_parity ^ iphit_buf;
                iframe <= {iframe, iphit_buf};
                iphit_cnt <= iphit_cnt + 1;
            end
        end
    end

    always @* begin
        ilnk_state_next = ilnk_state;
        iframe_val = 'b0;

        case (ilnk_state)
            ILNK_STATE_IDLE: begin
                if (&iphit_buf) begin
                    ilnk_state_next = ILNK_STATE_DATA;
                end
            end
            ILNK_STATE_DATA: begin
                if (&iphit_cnt) begin
                    ilnk_state_next = ILNK_STATE_PARITY;
                end
            end
            ILNK_STATE_PARITY: begin
                if (|(iphit_parity ^ iphit_buf)) begin
                    ilnk_state_next = ILNK_STATE_PARITY_ERR;
                end else begin
                    iframe_val = 'b1;
                    ilnk_state_next = ILNK_STATE_IDLE;
                end
            end
        endcase
    end

    // =======================================================================
    // Link-level implementation: Frame output
    // =======================================================================
    reg [FRAME_SIZE-1:0] oframe, oframe_buf;
    reg oframe_val, oframe_rdy;
    reg [1:0] olnk_state, olnk_state_next;

    reg [CFG_WIDTH-1:0] ophit_parity;
    reg [DATA_PHIT_COUNT_LOG2-1:0] ophit_cnt;

    localparam  OLNK_STATE_IDLE         = 2'h0,
                OLNK_STATE_DATA         = 2'h1,
                OLNK_STATE_PARITY       = 2'h2;

    always @(posedge cfg_clk) begin
        if (~cfg_e) begin
            olnk_state <= OLNK_STATE_IDLE;
            oframe_buf <= 'b0;
            ophit_parity <= 'b0;
            ophit_cnt <= 'b0;
        end else begin
            olnk_state <= olnk_state_next;

            if (olnk_state == OLNK_STATE_IDLE) begin
                ophit_parity <= 'b0;
                ophit_cnt <= 'b0;
                oframe_buf <= oframe;
            end else if (olnk_state == OLNK_STATE_DATA) begin
                ophit_parity <= ophit_parity ^ cfg_o;
                ophit_cnt <= ophit_cnt + 1;
                oframe_buf <= {oframe_buf, {{ fill("CFG_WIDTH", "1'b0") }}};
            end
        end
    end

    always @* begin
        cfg_o = 'b0;
        olnk_state_next = olnk_state;
        oframe_rdy = 'b0;

        case (olnk_state)
            OLNK_STATE_IDLE: begin
                oframe_rdy = 'b1;
                if (oframe_val) begin
                    cfg_o = 'b1;                        // start phit
                    olnk_state_next = OLNK_STATE_DATA;
                end
            end
            OLNK_STATE_DATA: begin
                cfg_o = oframe_buf[FRAME_SIZE-1-:CFG_WIDTH];

                if (&ophit_cnt) begin
                    olnk_state_next = OLNK_STATE_PARITY;
                end
            end
            OLNK_STATE_PARITY: begin
                cfg_o = ophit_parity;
                olnk_state_next = OLNK_STATE_IDLE;
            end
        endcase
    end

    // =======================================================================
    // Data-level implementation
    // =======================================================================
    localparam  MSG_TYPE_WIDTH                  = 4;
    localparam  MSG_HOPCOUNT_WIDTH              = 12;
    localparam  MSG_PAYLOAD_OR_INFO_WIDTH       = 16;
    localparam  MSG_HEADER_WIDTH                = MSG_TYPE_WIDTH + MSG_HOPCOUNT_WIDTH + MSG_PAYLOAD_OR_INFO_WIDTH;
    {# msg header is 32b. get enough buffering space for it. #}
    {%- set buffer_depth = (4.0 / cfg_width) | round(0, "ceil") | int %}
    {%- set buffer_depth_log2 = buffer_depth.bit_length() %}
    localparam  BUFFER_DEPTH                    = {{ buffer_depth }};
    localparam  BUFFER_SIZE                     = BUFFER_DEPTH * FRAME_SIZE;

    // frame buffer
    reg [BUFFER_SIZE - 1:0] frame_buf, frame_buf_next;
    reg [{{ buffer_depth_log2 - 1 }}:0] frame_buf_cnt;
    reg frame_buf_deq_all, frame_buf_deq_one;

    always @(posedge cfg_clk) begin
        if (~cfg_e) begin
            frame_buf <= 'b0;
            frame_buf_cnt <= 'b0;
        end else begin
            if (iframe_val) begin
                frame_buf <= {frame_buf_next, iframe};
            end else begin
                frame_buf <= frame_buf_next;
            end

            case ({iframe_val, frame_buf_deq_all, frame_buf_deq_one})
                3'b001: begin
                    frame_buf_cnt <= frame_buf_cnt - 1;
                end
                3'b010,
                3'b011: begin
                    frame_buf_cnt <= 0;
                end
                3'b100: begin
                    frame_buf_cnt <= frame_buf_cnt + 1;
                end
                3'b110,
                3'b111: begin
                    frame_buf_cnt <= 1;
                end
            endcase
        end
    end

    // disassemble frames
    wire [FRAME_SIZE - 1:0] frame_buf_frames [BUFFER_DEPTH - 1:0];
    {%- for i in range(buffer_depth) %}
    assign frame_buf_frames[{{ i }}] = frame_buf[{{ i }} * FRAME_SIZE +: FRAME_SIZE];
    {%- endfor %}

    // disassemble the first frame in queue down to phits
    wire [CFG_WIDTH - 1:0] first_frame_phits [DATA_PHIT_COUNT - 1:0];
    {%- for i in range(8) %}
    assign first_frame_phits[{{ i }}] = frame_buf_frames[frame_buf_cnt - 1][{{ i }} * CFG_WIDTH +: CFG_WIDTH];
    {%- endfor %}

    // output
    always @* begin
        oframe = frame_buf_frames[frame_buf_cnt - 1];
    end

    // logic
    localparam  MSG_TYPE_DATA                   = 4'h0,
                MSG_TYPE_DATA_ACK               = 4'h1,
                MSG_TYPE_EOP                    = 4'h2,         // end of programming
                MSG_TYPE_ERROR_CHECKSUM         = 4'h8,         // checksum mismatch
                MSG_TYPE_ERROR_ECHO             = 4'h9,         // echo mismatch
                MSG_TYPE_ERROR_UNKNOWN_STATE    = 4'hA,         // router stuck in an unknown state
                MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE = 4'hB;         // unknown message type

    localparam  DATA_STATE_IDLE                 = 4'h0,         // waiting for frame buffer to be filled
                DATA_STATE_PROGRAMMING          = 4'h1,         // programming this tile
                DATA_STATE_SAVE_ECHO_REF        = 4'h2,         // save the reference echo word
                DATA_STATE_FORWARDING           = 4'h3,         // forwarding a message
                DATA_STATE_EOP_FORWARDING       = 4'h4,         // forwarding an EOP message
                DATA_STATE_EOP                  = 4'h5,         // locked by EOP message
                DATA_STATE_MSG_SENDING          = 4'h6,         // sending a message
                DATA_STATE_ERROR_SENDING        = 4'h7,         // sending an error
                DATA_STATE_ERROR                = 4'h8,         // locked in an error state
                DATA_STATE_CRC_CHECK            = 4'h9,         // CRC check
                DATA_STATE_ECHO_CHECK           = 4'hA;         // echo check

    reg [3:0] data_state, data_state_next;
    reg [MSG_PAYLOAD_OR_INFO_WIDTH:0] payload, payload_next;
    reg [CFG_WIDTH - 1:0] echo_back, echo_ref;
    reg [DATA_PHIT_COUNT_LOG2 - 1:0] prog_phit_cnt, prog_phit_cnt_next;

    wire [CFG_WIDTH - 1:0] current_phit;
    assign current_phit = first_frame_phits[DATA_PHIT_COUNT - 1 - prog_phit_cnt];

    always @* begin
        cfg_dout = current_phit;
    end

    always @(posedge cfg_clk) begin
        if (~cfg_e) begin
            data_state <= DATA_STATE_IDLE;
            payload <= 'b0;
            prog_phit_cnt <= 'b0;
        end else begin
            data_state <= data_state_next;
            payload <= payload_next;
            prog_phit_cnt <= prog_phit_cnt_next;
        end

        if (data_state == DATA_STATE_SAVE_ECHO_REF && cfg_we_o) begin
            echo_ref <= current_phit;
        end

        if (cfg_we_i) begin
            echo_back <= cfg_din;
        end
    end

    reg [7:0] crc [CFG_WIDTH-1:0];
    reg crc_en, crc_rst;

    always @(posedge cfg_clk) begin
        if (~cfg_e || crc_rst) begin
            {%- for i in range(cfg_width) %}
            crc[{{ i }}] <= 'b0;
            {%- endfor %}
        end else if (crc_en) begin
            {%- for i in range(cfg_width) %}
            crc[{{ i }}] <= (crc[{{ i }}] << 1) ^ (crc[{{ i }}][7] ^ current_phit[{{ i }}] ? 8'h07 : 8'b0);
            {% endfor %}
        end
    end

    wire [MSG_TYPE_WIDTH - 1:0] msg_type;
    wire [MSG_HOPCOUNT_WIDTH - 1:0] msg_hopcount;
    wire [MSG_PAYLOAD_OR_INFO_WIDTH - 1:0] msg_payload_or_info;

    assign {msg_type, msg_hopcount, msg_payload_or_info} = frame_buf[0 +: MSG_HEADER_WIDTH];

    always @* begin
        data_state_next = data_state;
        frame_buf_next = frame_buf;
        frame_buf_deq_all = 'b0;
        frame_buf_deq_one = 'b0;
        oframe_val = 'b0;
        payload_next = payload;
        prog_phit_cnt_next = prog_phit_cnt;
        crc_en = 'b0;
        crc_rst = 'b0;
        cfg_we_o = 'b0;

        case (data_state)
            DATA_STATE_IDLE: begin
                prog_phit_cnt_next = 'b0;
                crc_rst = 'b1;

                if (frame_buf_cnt == BUFFER_DEPTH) begin    // we've got the entire header
                    case (msg_type)                         // inspect message type
                        MSG_TYPE_DATA: begin
                            if (msg_hopcount == 0) begin
                                // this tile is the destination
                                data_state_next = DATA_STATE_SAVE_ECHO_REF;
                                payload_next = msg_payload_or_info;

                                // consume the header frame(s)
                                frame_buf_deq_all = 'b1;
                            end else begin
                                // this tile is not the destination
                                data_state_next = DATA_STATE_FORWARDING;
                                payload_next = BUFFER_DEPTH + msg_payload_or_info + 1;     // extra frames: header & checksum
                                frame_buf_next = frame_buf - (1 << MSG_PAYLOAD_OR_INFO_WIDTH);
                            end
                        end
                        MSG_TYPE_EOP: begin
                            data_state_next = DATA_STATE_EOP_FORWARDING;
                            payload_next = BUFFER_DEPTH;
                        end
                        MSG_TYPE_DATA_ACK,
                        MSG_TYPE_ERROR_CHECKSUM,
                        MSG_TYPE_ERROR_ECHO,
                        MSG_TYPE_ERROR_UNKNOWN_STATE,
                        MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE: begin
                            data_state_next = DATA_STATE_FORWARDING;
                            payload_next = BUFFER_DEPTH;
                            frame_buf_next = frame_buf + (1 << MSG_PAYLOAD_OR_INFO_WIDTH);
                        end
                        default: begin
                            data_state_next = DATA_STATE_ERROR_SENDING;
                            payload_next = BUFFER_DEPTH;
                            frame_buf_next = ((MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE << MSG_PAYLOAD_OR_INFO_WIDTH) | {msg_type, msg_hopcount});
                        end
                    endcase
                end
            end
            DATA_STATE_SAVE_ECHO_REF,
            DATA_STATE_PROGRAMMING: begin
                if (frame_buf_cnt > 0) begin    // we have a valid frame buffered
                    data_state_next = DATA_STATE_PROGRAMMING;
                    cfg_we_o = 'b1;
                    crc_en = 'b1;
                    prog_phit_cnt_next = prog_phit_cnt + 1;

                    if (prog_phit_cnt == DATA_PHIT_COUNT - 1) begin
                        frame_buf_deq_one = 'b1;
                        payload_next = payload - 1;

                        if (payload == 1) begin
                            data_state_next = DATA_STATE_CRC_CHECK;
                        end
                    end
                end
            end
            DATA_STATE_CRC_CHECK: begin
                if (frame_buf_cnt > 0) begin
                    crc_en = 'b1;
                    prog_phit_cnt_next = prog_phit_cnt + 1;

                    if (prog_phit_cnt == DATA_PHIT_COUNT - 1) begin
                        frame_buf_deq_one = 'b1;
                        data_state_next = DATA_STATE_ECHO_CHECK;
                    end
                end
            end
            DATA_STATE_ECHO_CHECK: begin
                if (|{
                    {%- set crc_joiner = joiner(", ") %}
                    {%- for i in range(cfg_width) -%}
                    {{ crc_joiner() }}crc[{{ i }}]
                    {%- endfor %}
                }) begin
                    data_state_next = DATA_STATE_ERROR_SENDING;
                    frame_buf_next = MSG_TYPE_ERROR_CHECKSUM << MSG_PAYLOAD_OR_INFO_WIDTH;
                    payload_next = BUFFER_DEPTH;
                end else if (~cfg_we_i) begin
                    if (echo_back == echo_ref) begin
                        data_state_next = DATA_STATE_MSG_SENDING;
                        frame_buf_next = MSG_TYPE_DATA_ACK << MSG_PAYLOAD_OR_INFO_WIDTH;
                        payload_next = BUFFER_DEPTH;
                    end else begin
                        data_state_next = DATA_STATE_ERROR_SENDING;
                        frame_buf_next = MSG_TYPE_ERROR_ECHO << MSG_PAYLOAD_OR_INFO_WIDTH;
                        payload_next = BUFFER_DEPTH;
                    end
                end
            end
            DATA_STATE_MSG_SENDING,
            DATA_STATE_FORWARDING: begin
                oframe_val = 'b1;

                if (oframe_rdy) begin
                    frame_buf_deq_one = 'b1;
                    payload_next = payload - 1;

                    if (payload == 1) begin
                        data_state_next = DATA_STATE_IDLE;
                    end
                end
            end
            DATA_STATE_EOP_FORWARDING: begin
                oframe_val = 'b1;

                if (oframe_rdy) begin
                    frame_buf_deq_one = 'b1;
                    payload_next = payload - 1;

                    if (payload == 1) begin
                        data_state_next = DATA_STATE_EOP;
                    end
                end
            end
            DATA_STATE_ERROR_SENDING: begin
                oframe_val = 'b1;

                if (oframe_rdy) begin
                    frame_buf_deq_one = 'b1;
                    payload_next = payload - 1;

                    if (payload == 1) begin
                        data_state_next = DATA_STATE_ERROR;
                    end
                end
            end
            DATA_STATE_EOP,
            DATA_STATE_ERROR: begin
                // locked! do nothing
            end
            default: begin
                data_state_next = DATA_STATE_ERROR_SENDING;
                payload_next = BUFFER_DEPTH;
                frame_buf_next = MSG_TYPE_ERROR_UNKNOWN_STATE << MSG_PAYLOAD_OR_INFO_WIDTH;
            end
        endcase
    end

endmodule
