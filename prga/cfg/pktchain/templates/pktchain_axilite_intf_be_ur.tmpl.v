// Automatically generated by PRGA's RTL generator
`include "pktchain_axilite_intf.vh"
module {{ module.name }} (
    // system ctrl signals (in user clock domain)
    input wire [0:0] clk,
    input wire [0:0] rst,

    // == Main Controller Interface ==========================================
    // read request
    input wire [0:0] rval,
    output reg [0:0] rrdy,
    input wire [`PRGA_USER_ADDR_WIDTH - 1:0] raddr,

    // read response
    output reg [0:0] rresp_val,
    output reg [1:0] rresp,
    output reg [`PRGA_USER_DATA_WIDTH - 1:0] rdata,
    output reg [0:0] req_timeout,
    output reg [0:0] resp_timeout,

    // other signals
    input wire [`PRGA_TIMER_WIDTH - 1:0] timeout_limit,

    // == AXI4-Lite User Interface ===========================================
    // read address channel
    output reg [0:0] u_ARVALID,
    input wire [0:0] u_ARREADY,
    output reg [`PRGA_USER_ADDR_WIDTH - 1:0] u_ARADDR,
    output reg [2:0] u_ARPROT,

    // read data channel
    input wire [0:0] u_RVALID,
    output reg [0:0] u_RREADY,
    input wire [`PRGA_USER_DATA_WIDTH - 1:0] u_RDATA,
    input wire [1:0] u_RRESP
    );

    assign u_ARPROT = 'b0;

    // == Stall Signal Declaration ===========================================
    reg stall_resp;

    // == Request Posting Stage ==============================================
    reg [`PRGA_TIMER_WIDTH - 1:0] req_timer;
    reg raddr_val;

    always @(posedge clk) begin
        if (rst) begin
            req_timer <= 'b0;
            req_timeout <= 'b0;
            raddr_val <= 'b0;
            u_ARADDR <= raddr;
        end else begin
            if (rval && rrdy) begin
                req_timer <= timeout_limit;
                raddr_val <= 'b1;
                u_ARADDR <= raddr;
            end else if (~stall_resp) begin
                if (u_ARREADY || req_timer == 0) begin
                    raddr_val <= 'b0;
                end

                if (req_timer > 0) begin
                    req_timer <= req_timer - 1;
                end else if (raddr_val && ~u_ARREADY) begin
                    req_timeout <= 'b1;
                end
            end
        end
    end

    assign rrdy = ~rst && (~raddr_val || (~stall_resp && u_ARREADY));
    assign u_ARVALID = raddr_val && ~stall_resp;

    // == Response Collecting Stage ==========================================
    reg [`PRGA_TIMER_WIDTH - 1:0] resp_timer;
    reg resp_val;   // response stage valid

    always @(posedge clk) begin
        if (rst) begin
            resp_timer <= 'b0;
            resp_timeout <= 'b0;
            resp_val <= 'b0;
            rresp_val <= 'b0;
            rresp <= 'b0;
            rdata <= 'b0;
        end else begin
            if (u_ARVALID && u_ARREADY) begin
                resp_timer <= timeout_limit;
                resp_val <= 'b1;
            end else if (resp_val) begin
                if (u_RVALID) begin
                    resp_val <= 'b0;
                end else if (resp_timer == 0) begin
                    resp_val <= 'b0;
                    resp_timeout <= 'b1;
                end else begin
                    resp_timer <= resp_timer - 1;
                end
            end

            if (u_RREADY && u_RVALID) begin
                rresp_val <= 'b1;
                rresp <= u_RRESP;
                rdata <= u_RDATA;
            end else begin
                rresp_val <= 'b0;
            end
        end
    end

    assign u_RREADY = resp_val;
    assign stall_resp = rst || resp_timeout || (resp_val && ~u_RVALID);

endmodule
