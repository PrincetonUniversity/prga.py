// Automatically generated by PRGA's RTL generator
`include "pktchain_axilite_intf.vh"
// Slave channel timer
module pktchain_axilite_intf_sch_timer #(
    parameter   DATA_WIDTH = 32
) (
    // system ctrl signals
    input wire [0:0] clk,
    input wire [0:0] rst,

    // == Upstream Interface =================================================
    input wire [0:0] exp_i,     // active "rdy"
        // When asserted, the upstream is not just ready but actually expecting something
    output reg [0:0] ack_o,
    output reg [DATA_WIDTH - 1:0] data_o,   // 1 cycle after `ack_o` is asserted

    // timeout
    input wire [`PRGA_TIMER_WIDTH - 1:0] timeout_limit,
    output reg [0:0] timeout_o, // report if the previous transaction timed out

    // == Downstream Interface ===============================================
    output reg [0:0] rdy_o,
    input wire [0:0] val_i,
    input wire [DATA_WIDTH - 1:0] data_i
    );

    reg [`PRGA_TIMER_WIDTH - 1:0] timer;

    always @(posedge clk) begin
        if (rst) begin
            timer <= 'b0;
            timeout_o <= 'b0;
            rdy_o <= 'b0;
            data_o <= 'b0;
        end else begin
            // new expectation coming in
            if (exp_i && (~rdy_o || ack_o)) begin
                timer <= timeout_limit;
                timeout_o <= 'b0;
                rdy_o <= 'b1;
            end
            // pending expectation
            else if (rdy_o) begin
                if (val_i) begin
                    rdy_o <= 'b0;
                    data_o <= data_i;
                    timeout_o <= 'b0;
                end else if (timer == 0) begin
                    rdy_o <= 'b0;
                    timeout_o <= 'b1;
                end else begin
                    timer <= timer - 1;
                end
            end

            if (rdy_o && val_i) begin
                data_o <= data_i;
            end
        end
    end

    always @* begin
        ack_o = rdy_o && val_i;
    end

endmodule
