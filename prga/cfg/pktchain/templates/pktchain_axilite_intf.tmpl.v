// Automatically generated by PRGA's RTL generator
`include "pktchain_axilite_intf.vh"
module {{ module.name }} (
    // system ctrl signals
    input wire [0:0] clk,
    input wire [0:0] rst,

    // AXI4-Lite Follower Interface
    // write address channel
    input wire [0:0] m_axi_awvalid,
    output reg [0:0] m_axi_awready,
    input wire [`PRGA_AXI_ADDR_WIDTH - 1:0] m_axi_awaddr,
    input wire [2:0] m_axi_awprot,

    // write data channel
    input wire [0:0] m_axi_wvalid,
    output reg [0:0] m_axi_wready,
    input wire [`PRGA_AXI_DATA_WIDTH - 1:0] m_axi_wdata,
    input wire [`PRGA_AXI_DATA_BYTES - 1:0] m_axi_wstrb,

    // write response channel
    output reg [0:0] m_axi_bvalid,
    input wire [0:0] m_axi_bready,
    output reg [1:0] m_axi_bresp,

    // read address channel
    input wire [0:0] m_axi_arvalid,
    output reg [0:0] m_axi_arready,
    input wire [`PRGA_AXI_ADDR_WIDTH - 1:0] m_axi_araddr,
    input wire [2:0] m_axi_arprot,

    // read data channel
    output reg [0:0] m_axi_rvalid,
    input wire [0:0] m_axi_rready,
    output reg [`PRGA_AXI_DATA_WIDTH:0] m_axi_rdata,
    output reg [1:0] m_axi_rresp,

    // PRGA Reconfiguration Controller Interface
    output reg [0:0] cfg_rst,
    output reg [0:0] cfg_e,

    // configuration output
    input wire [0:0] cfg_phit_o_full,
    output wire [0:0] cfg_phit_o_wr,
    output wire [`PHIT_WIDTH - 1:0] cfg_phit_o,

    // configuration input
    output wire [0:0] cfg_phit_i_full,
    input wire [0:0] cfg_phit_i_wr,
    input wire [`PHIT_WIDTH - 1:0] cfg_phit_i

    // TODO: Supervising control over PRGA User-Register Interface
    // TODO: Supervising control over PRGA Coherent Memory Interface
    );

    // CREG basic interface
    wire creg_wreq_valid, creg_rreq_valid;
    reg creg_wreq_accept, creg_wreq_ignore, creg_rreq_accept;

    // AXI write request FIFOs
    wire axi_waddr_fifo_full, axi_waddr_fifo_empty;
    wire [`PRGA_AXI_ADDR_WIDTH - 1:0] creg_wreq_addr;

    pktchain_fifo #(
        DATA_WIDTH = `PRGA_AXI_ADDR_WIDTH
    ) axi_waddr_fifo (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.full                      (axi_waddr_fifo_full)
        ,.wr                        (m_axi_awvalid)
        ,.din                       (m_axi_awaddr)
        ,.empty                     (axi_waddr_fifo_empty)
        ,.rd                        (creg_wreq_accept || creg_wreq_ignore)
        ,.dout                      (creg_wreq_addr)
        );

    wire axi_wdata_fifo_full, axi_wdata_fifo_empty;
    wire [`PRGA_AXI_DATA_BYTES - 1:0] creg_wreq_mask;
    wire [`PRGA_AXI_DATA_WIDTH - 1:0] creg_wreq_data;

    pktchain_fifo #(
        DATA_WIDTH = `PRGA_AXI_DATA_BYTES + `PRGA_AXI_DATA_WIDTH
    ) axi_wdata_fifo (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.full                      (axi_wdata_fifo_full)
        ,.wr                        (m_axi_wvalid)
        ,.din                       ({m_axi_wstrb, m_axi_wdata})
        ,.empty                     (axi_wdata_fifo_empty)
        ,.rd                        (creg_wreq_accept || creg_wreq_ignore)
        ,.dout                      ({creg_wreq_mask, creg_wreq_data})
        );

    assign creg_wreq_valid = ~axi_waddr_fifo_empty && ~axi_wdata_fifo_empty;

    // AXI write response FIFOs
    wire axi_wresp_fifo_full, axi_wresp_fifo_empty;

    pktchain_fifo #(
        DATA_WIDTH = 2
    ) axi_wresp_fifo (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.full                      (axi_wresp_fifo_full)
        ,.wr                        (creg_wreq_accept || creg_wreq_ignore)
        ,.din                       (2'b0)  // AXI OKAY
        ,.empty                     (axi_wresp_fifo_empty)
        ,.rd                        (m_axi_bready)
        ,.dout                      (m_axi_bresp)
        );

    // AXI read request FIFOs
    wire axi_raddr_fifo_full, axi_raddr_fifo_empty;
    wire [`PRGA_AXI_ADDR_WIDTH - 1:0] creg_rreq_addr;

    pktchain_fifo #(
        DATA_WIDTH = `PRGA_AXI_ADDR_WIDTH
    ) axi_raddr_fifo (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.full                      (axi_raddr_fifo_full)
        ,.wr                        (m_axi_arvalid)
        ,.din                       (m_axi_araddr)
        ,.empty                     (axi_raddr_fifo_empty)
        ,.rd                        (creg_rreq_accept)
        ,.dout                      (creg_rreq_addr)
        );

    assign creg_rreq_valid = ~axi_raddr_fifo_empty;

    // AXI read response FIFOs
    wire axi_rdata_fifo_full, axi_rdata_fifo_empty;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] creg_rreq_data;

    pktchain_fifo #(
        DATA_WIDTH = `PRGA_AXI_DATA_WIDTH
    ) axi_rdata_fifo (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.full                      (axi_rdata_fifo_full)
        ,.wr                        (creg_rreq_accept)
        ,.din                       (creg_rreq_data)
        ,.empty                     (axi_rdata_fifo_empty)
        ,.rd                        (m_axi_rready)
        ,.dout                      (m_axi_rdata)
        );

    // AXI interface handling
    always @* begin
        m_axi_awready = ~axi_waddr_fifo_full;
        m_axi_wready = ~axi_wdata_fifo_full;
        m_axi_bvalid = ~axi_wresp_fifo_empty;
        m_axi_arready = ~axi_raddr_fifo_full;
        m_axi_rvalid = ~axi_rdata_fifo_empty;
        m_axi_rresp = 2'b0;     // AXI OKAY
    end

    // bitstream FIFO
    wire bitstream_frames_fifo_full;
    reg bitstream_frames_fifo_wr;

    pktchain_frame_disassemble #(
        DEPTH_LOG2 = 4,                         // 16 64-bit entries
        DATA_WIDTH_LOG2 = `PRGA_AXI_DATA_WIDTH_LOG2
    ) bitstream_frames_fifo (
        .cfg_clk                    (clk)
        ,.cfg_rst                   (rst)
        ,.frame_full                (bitstream_frames_fifo_full)
        ,.frame_wr                  (bitstream_frames_fifo_wr)
        ,.frame_i                   (m_axi_wdata)
        ,.phit_full                 (cfg_phit_o_full)
        ,.phit_wr                   (cfg_phit_o_wr)
        ,.phit_o                    (cfg_phit_o)
        );

    // bitstream response collection

    // CREG writes
    reg [`PRGA_CREG_STATE_WIDTH - 1:0] state, state_next;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] creg_err_flags, creg_err_flags_next;
    reg [`PRGA_AXI_DATA_WIDTH - 1:0] creg_bitstream_id;

    // CREG writes that are byte-addressable
    genvar creg_byte_i;
    generate for (creg_byte_i = 0; creg_byte_i < `PRGA_AXI_DATA_BYTES; creg_byte_i = creg_byte_i + 1) begin: creg_byte
        always @(posedge clk or posedge rst) begin
            if (rst) begin
                creg_bitstream_id[creg_byte_i * 8 +: 8] <= 'b0;
            end else if (creg_wreq_valid && creg_wreq_accept) begin
                case (creg_wreq_addr)
                    `PRGA_CREG_ADDR_BITSTREAM_ID: begin
                        creg_bitstream_id[creg_byte_i * 8 +: 8] <= creg_wreq_mask[creg_byte_i] ?
                                                                   creg_wreq_data[creg_byte_i * 8 +: 8] :
                                                                   creg_bitstream_id[creg_byte_i * 8 +: 8];
                    end
                endcase
            end
        end
    end endgenerate

    // CREG writes that are not byte-addressable
    always @(posedge clk or posedge rst) begin
        if (rst) begin
            state <= `PRGA_STATE_RESET;
            creg_err_flags <= 'b0;
        end else begin
            state <= state_next;

            if (creg_wreq_valid && creg_wreq_accept) begin
                case (creg_wreq_addr)
                    `PRGA_CREG_ADDR_ERR: begin
                        creg_err_flags <= creg_wreq_data;
                    end
                endcase
            end else begin
                creg_err_flags <= creg_err_flags_next;
            end
        end
    end
    
    // CREG reads
    always @* begin
        creg_rreq_accept = ~axi_rdata_fifo_full;
        creg_rreq_data = 'b0;

        case (creg_rreq_addr)
            `PRGA_CREG_ADDR_STATE: begin
                creg_rreq_data = `PRGA_AXI_DATA_WIDTH'b0 | state;
            end
            `PRGA_CREG_ADDR_ERR: begin
                creg_rreq_data = creg_err_flags;
            end
            `PRGA_CREG_ADDR_BITSTREAM_ID: begin
                creg_rreq_data = creg_bitstream_id;
            end
        endcase
    end

    // main state machine
    always @* begin
        state_next = state;
        creg_err_flags_next = creg_err_flags;
        bitstream_frames_fifo_wr = 'b0;
        creg_wreq_accept = 'b0;
        creg_wreq_ignore = 'b0;

        case (state)
            `PRGA_STATE_RESET: begin
                state_next = `PRGA_STATE_STANDBY;
            end
            `PRGA_STATE_STANDBY: begin
                if (creg_wreq_valid) begin
                    // some writes would trigger state transition
                    case (creg_wreq_addr)
                        `PRGA_CREG_ADDR_BITSTREAM_ID: begin
                            // bitstream ID specified. Transition to bitstream loading state
                            creg_wreq_accept = 'b1;
                            state_next = `PRGA_STATE_PROGRAMMING;
                        end
                        default: begin
                            creg_err_flags_next = creg_err_flags | `PRGA_ERR_PROTOCOL_VIOLATION;
                            creg_wreq_ignore = 'b1;
                        end
                    endcase
                end
            end
            `PRGA_STATE_PROGRAMMING: begin
                if (creg_wreq_valid) begin
                    case (creg_wreq_addr)
                        `PRGA_CREG_ADDR_BITSTREAM_FIFO: begin
                            // write to bitstream loading FIFO
                            bitstream_frames_fifo_wr = 'b1;
                            creg_wreq_accept = ~bitstream_frames_fifo_full;
                        end
                    endcase
                end
            end
        endcase
    end

endmodule
