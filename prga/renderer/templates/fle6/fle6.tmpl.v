// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps
module fle6 (
    input wire [0:0] clk
    , input wire [5:0] in
    , input wire [0:0] cin
    , output reg [1:0] out
    , output reg [0:0] cout

    , input wire [0:0] prog_done
    , input wire [69:0] prog_data
        // prog_data[31: 0] LUT5A
        // prog_data[63:32] LUT5B
        // prog_data[65:64] adder carry-in select
        // prog_data[   66] FFA disable (FF enabled by default)
        // prog_data[   67] FFB disable (FF enabled by default)
        // prog_data[69:68] FLE6 mode select
    );

    // -- Parameters ---------------------------------------------------------
    localparam LUT5_DATA_WIDTH = 32;
    localparam ADDER_MODE_WIDTH = 2;
    localparam FLE6_MODE_WIDTH = 2;

    // adder carry-in modes
    localparam ADDER_MODE_CONST0 = 2'b00;
    localparam ADDER_MODE_CONST1 = 2'b01;
    localparam ADDER_MODE_CHAIN  = 2'b10;
    localparam ADDER_MODE_FABRIC = 2'b11;

    // fle6 modes
    localparam FLE6_MODE_DISABLED = 2'b00;
    localparam FLE6_MODE_ARITH    = 2'b01;
    localparam FLE6_MODE_LUT6X1   = 2'b10;
    localparam FLE6_MODE_LUT5X2   = 2'b11;

    // prog_data indexing
    localparam LUT5A_DATA = 0;
    localparam LUT5B_DATA = LUT5A_DATA + LUT5_DATA_WIDTH;
    localparam ADDER_MODE = LUT5B_DATA + LUT5_DATA_WIDTH;
    localparam FFA_DISABLE = ADDER_MODE + ADDER_MODE_WIDTH;
    localparam FFB_DISABLE = FFA_DISABLE + 1;
    localparam FLE6_MODE = FFB_DISABLE + 1;

    // -- Internal Signals ---------------------------------------------------
    reg [5:0] internal_in;
    reg internal_cin;
    reg [1:0] internal_lut;
    reg [1:0] internal_sum;
    reg [1:0] internal_ff;

    // -- decode programming data --
    wire [LUT5_DATA_WIDTH-1:0]  lut5a_data;
    wire [LUT5_DATA_WIDTH-1:0]  lut5b_data;
    wire [ADDER_MODE_WIDTH-1:0] adder_mode;
    wire                        ffa_disable;
    wire                        ffb_disable;
    wire [FLE6_MODE_WIDTH-1:0]  fle6_mode;

    assign lut5a_data = prog_data[LUT5A_DATA+:LUT5_DATA_WIDTH];
    assign lut5b_data = prog_data[LUT5B_DATA+:LUT5_DATA_WIDTH];
    assign adder_mode = prog_data[ADDER_MODE+:ADDER_MODE_WIDTH];
    assign ffa_disable = prog_data[FFA_DISABLE];
    assign ffb_disable = prog_data[FFB_DISABLE];
    assign fle6_mode = prog_data[FLE6_MODE+:FLE6_MODE_WIDTH];

    // -- preprocess inputs --
    // in case the sensitivity list is not triggered at the beginning of
    // simulation
    // synopsys translate_off
    initial begin
        internal_in = $random % 64;
    end
    // synopsys translate_on

    always @* begin
        internal_in = in;

        // synopsys translate_off
        // in simulation resolve x to random values
        {%- for i in range(6) %}
        if (in[{{ i }}] === 1'bx) begin
            internal_in[{{ i }}] = $random % 2;
        end
        {%- endfor %}
        // synopsys translate_on
    end

    // -- select carry-in --
    always @* begin
        case (adder_mode)
            ADDER_MODE_CONST0: internal_cin = 1'b0;
            ADDER_MODE_CONST1: internal_cin = 1'b1;
            ADDER_MODE_CHAIN:  internal_cin = cin;
            ADDER_MODE_FABRIC: internal_cin = internal_in[5];
        endcase
    end

    // -- implement LUT5s --
    always @* begin
        case (internal_in[4:0])
            {%- for i in range(32) %}
            5'd{{ i }}: begin
                internal_lut[0] = lut5a_data[{{ i }}];
                internal_lut[1] = lut5b_data[{{ i }}];
            end
            {%- endfor %}
        endcase
    end

    // -- implement adder --
    always @* begin
        internal_sum = internal_lut[0] + internal_lut[1] + internal_cin;
    end

    // -- implement FFs --
    always @(posedge clk) begin
        if (~prog_done) begin
            internal_ff <= 2'b0;
        end else begin
            case (fle6_mode)
                FLE6_MODE_DISABLED: internal_ff <= 2'b0;
                FLE6_MODE_ARITH: internal_ff <= internal_sum;
                FLE6_MODE_LUT6X1: internal_ff <= {1'b0, internal_in[5] ? internal_lut[1] : internal_lut[0]};
                FLE6_MODE_LUT5X2: internal_ff <= internal_lut;
            endcase
        end
    end

    // -- Outputs ------------------------------------------------------------
    always @* begin
        if (prog_done) begin
            case (fle6_mode)
                FLE6_MODE_DISABLED: begin
                    cout = 1'b0;
                    out = 2'b0;
                end
                FLE6_MODE_ARITH: begin
                    cout = internal_sum[1];
                    out[1] = ffb_disable ? internal_sum[1] : internal_ff[1];
                    out[0] = ffa_disable ? internal_sum[0] : internal_ff[0];
                end
                FLE6_MODE_LUT6X1: begin
                    cout = 1'b0;
                    out[1] = 1'b0;

                    case ({ffa_disable, internal_in[5]})
                        2'b00, 2'b01: out[0] = internal_ff[0];
                        2'b10:        out[0] = internal_lut[0];
                        2'b11:        out[0] = internal_lut[1];
                    endcase
                end
                FLE6_MODE_LUT5X2: begin
                    cout = 1'b0;
                    out[1] = ffb_disable ? internal_lut[1] : internal_ff[1];
                    out[0] = ffa_disable ? internal_lut[0] : internal_ff[0];
                end
            endcase
        end else begin
            cout = 1'b0;
            out = 2'b0;
        end
    end

endmodule
