// Automatically generated by PRGA's RTL generator
`include "prga_utils.vh"
module prga_fifo_resizer #(
    parameter DATA_WIDTH = 32,
    parameter INPUT_MULTIPLIER = 1,
    parameter OUTPUT_MULTIPLIER = 1,
    parameter INPUT_LOOKAHEAD = 0,
    parameter OUTPUT_LOOKAHEAD = 0
) (
    input wire [0:0] clk,
    input wire [0:0] rst,

    input wire [0:0] empty_i,
    output wire [0:0] rd_i,
    input wire [DATA_WIDTH * INPUT_MULTIPLIER - 1:0] dout_i,

    output wire [0:0] empty,
    input wire [0:0] rd,
    output wire [DATA_WIDTH * OUTPUT_MULTIPLIER - 1:0] dout
    );

    generate if (INPUT_MULTIPLIER == 1 && OUTPUT_MULTIPLIER == 1) begin
        if (INPUT_LOOKAHEAD == OUTPUT_LOOKAHEAD) begin
            // Do nothing
            assign rd_i = rd;
            assign empty = empty_i;
            assign dout = dout_i;
        end else begin
            wire [DATA_WIDTH - 1:0] buffer_dout;

            prga_fifo_lookahead_buffer #(
                .DATA_WIDTH         (DATA_WIDTH)
                ,.REVERSED          (INPUT_LOOKAHEAD)
            ) buffer (
                .clk                (clk)
                ,.rst               (rst)
                ,.empty_i           (empty_i)
                ,.rd_i              (rd_i)
                ,.dout_i            (dout_i)
                ,.empty             (empty)
                ,.rd                (rd)
                ,.dout              (dout)
                );
        end
    end else if ((INPUT_MULTIPLIER <= 0 || INPUT_MULTIPLIER > 1) && (OUTPUT_MULTIPLIER <= 0 || OUTPUT_MULTIPLIER > 1)) begin
        // At least one of INPUT_MULTIPLIER and OUTPUT_MULTIPLIER must be 1 and the other must be a positive integer.
        __PRGA_PARAMETERIZATION_ERROR__ __error__();
    end else begin
        reg [DATA_WIDTH * OUTPUT_MULTIPLIER - 1:0] obuf;
        reg dout_i_valid;
        wire dout_i_ready;

        if (INPUT_LOOKAHEAD) begin
            always @* begin
                dout_i_valid = ~empty_i;
            end

            assign rd_i = dout_i_ready;
        end else begin
            always @(posedge clk or posedge rst) begin
                if (rst) begin
                    dout_i_valid <= 'b0;
                end else begin
                    if (~empty_i && rd_i) begin
                        dout_i_valid <= 'b1;
                    end else if (dout_i_ready) begin
                        dout_i_valid <= 'b0;
                    end
                end
            end

            assign rd_i = ~dout_i_valid || dout_i_ready;
        end

        if (OUTPUT_LOOKAHEAD) begin
            assign dout = obuf;
        end else begin
            reg [DATA_WIDTH * OUTPUT_MULTIPLIER - 1:0] obuf_f;

            always @(posedge clk) begin
                if (~empty && rd) begin
                    obuf_f <= obuf;
                end
            end

            assign dout = obuf_f;
        end

        if (INPUT_MULTIPLIER == 1) begin
            // Assembling
            localparam INPUT_COUNTER_WIDTH = `CLOG2(OUTPUT_MULTIPLIER + 1);

            reg [INPUT_COUNTER_WIDTH - 1:0] counter;

            always @(posedge clk or posedge rst) begin
                if (rst) begin
                    counter <= 'b0;
                end else begin
                    if (~empty && rd) begin
                        counter <= dout_i_valid ? 1 : 0;
                    end else if (dout_i_valid && dout_i_ready) begin
                        counter <= counter + 1;
                    end
                end
            end

            always @(posedge clk) begin
                if (dout_i_valid && dout_i_ready) begin
                    obuf <= {obuf, dout_i};
                end
            end

            assign empty = counter < OUTPUT_MULTIPLIER;
            assign dout_i_ready = empty || rd;
        end else begin
            // Disassembling
            localparam OUTPUT_COUNTER_WIDTH = `CLOG2(INPUT_MULTIPLIER + 1);

            reg [DATA_WIDTH * INPUT_MULTIPLIER - 1:0] ibuf;
            reg [OUTPUT_COUNTER_WIDTH - 1:0] counter;

            always @(posedge clk or posedge rst) begin
                if (rst) begin
                    counter <= 'b0;
                end else begin
                    if (dout_i_valid && dout_i_ready) begin
                        counter <= INPUT_MULTIPLIER;
                    end else if (~empty && rd) begin
                        counter <= counter - 1;
                    end
                end
            end

            always @(posedge clk) begin
                if (dout_i_valid && dout_i_ready) begin
                    ibuf <= dout_i;
                end else if (~empty && rd) begin
                    ibuf <= ibuf << DATA_WIDTH;
                end
            end

            assign empty = counter == 0;
            assign dout_i_ready = empty || (counter == 1 && rd);

            always @* begin
                obuf = ibuf[DATA_WIDTH * (INPUT_MULTIPLIER - 1) +: DATA_WIDTH];
            end
        end
    end endgenerate

endmodule
