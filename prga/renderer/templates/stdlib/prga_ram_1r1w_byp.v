// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps
module prga_ram_1r1w_byp #(
    parameter   DATA_WIDTH = 32
    , parameter ADDR_WIDTH = 10
) (
    input wire                      clk
    , input wire                    rst

    , input wire                    we
    , input wire [ADDR_WIDTH - 1:0] waddr
    , input wire [DATA_WIDTH - 1:0] din
    , input wire [DATA_WIDTH - 1:0] bw

    , input wire                    re
    , input wire [ADDR_WIDTH - 1:0] raddr
    , output reg [DATA_WIDTH - 1:0] dout
    );

    // internal signals
    reg [ADDR_WIDTH - 1:0]          int_waddr, int_raddr;
    reg                             int_we, int_re;
    reg [DATA_WIDTH - 1:0]          int_din, int_bw;
    wire [DATA_WIDTH - 1:0]         int_dout;

    prga_ram_1r1w #(
        .DATA_WIDTH                 (DATA_WIDTH)
        ,.ADDR_WIDTH                (ADDR_WIDTH)
    ) i_ram (
        .clk                        (clk)
        ,.rst                       (rst)
        ,.waddr                     (int_waddr)
        ,.din                       (int_din)
        ,.we                        (int_we)
        ,.bw                        (int_bw)
        ,.raddr                     (int_raddr)
        ,.re                        (int_re)
        ,.dout                      (int_dout)
        );

    // bypass read & write address conflict
    localparam  SRC_WIDTH           = 2;
    localparam  SRC_NONE            = 2'h0,
                SRC_NEW             = 2'h1,
                SRC_BUF             = 2'h2,
                SRC_MERGE           = 2'h3;

    // write buffer
    reg [SRC_WIDTH - 1:0]           wbuf_src;
    reg                             wbuf_vld;
    reg [ADDR_WIDTH - 1:0]          wbuf_addr;
    reg [DATA_WIDTH - 1:0]          wbuf_data;
    reg [DATA_WIDTH - 1:0]          wbuf_bw;

    always @* begin
        if (rst) begin
            wbuf_vld    <= 1'b0;
            wbuf_addr   <= {ADDR_WIDTH {1'b0} };
            wbuf_data   <= {DATA_WIDTH {1'b0} };
            wbuf_bw     <= {DATA_WIDTH {1'b0} };
        end else begin
            case (wbuf_src)
                SRC_NONE: begin
                    wbuf_vld    <= 1'b0;
                end
                SRC_NEW: begin
                    wbuf_vld    <= 1'b1;
                    wbuf_addr   <= waddr;
                    wbuf_data   <= din;
                    wbuf_bw     <= bw;
                end
                SRC_MERGE: begin
                    wbuf_data   <= (bw & din) | (~bw & wbuf_data);
                    wbuf_bw     <= bw | wbuf_bw;
                end
            endcase
        end
    end

    // execute write
    reg [SRC_WIDTH - 1:0]           wr_src;

    always @* begin
        int_we                  = 1'b0;
        int_waddr               = {ADDR_WIDTH {1'b0} };
        int_din                 = {DATA_WIDTH {1'b0} };
        int_bw                  = {DATA_WIDTH {1'b0} };

        if (~rst) begin
            case (wr_src)
                SRC_NEW: begin
                    int_we      = 1'b1;
                    int_waddr   = waddr;
                    int_din     = din;
                    int_bw      = bw;
                end
                SRC_BUF: begin
                    int_we      = 1'b1;
                    int_waddr   = wbuf_addr;
                    int_din     = wbuf_data;
                    int_bw      = wbuf_bw;
                end
            endcase
        end
    end

    // read buffer
    reg [SRC_WIDTH - 1:0]           rd_src;
    reg                             dout_merge;
    reg [DATA_WIDTH - 1:0]          rbuf_data, rbuf_bw;

    always @(posedge clk) begin
        if (rst) begin
            dout_merge          <= 1'b0;
            rbuf_data           <= {DATA_WIDTH {1'b0} };
            rbuf_bw             <= {DATA_WIDTH {1'b0} };
        end else begin
            dout_merge          <= rd_src == SRC_BUF;
            rbuf_data           <= wbuf_data;
            rbuf_bw             <= wbuf_bw;
        end
    end

    // execute read
    always @* begin
        int_re                  = 1'b0;
        int_raddr               = {ADDR_WIDTH {1'b0} };
        dout                    = {DATA_WIDTH {1'b0} };

        if (~rst) begin
            int_re              = rd_src == SRC_NEW || rd_src == SRC_BUF;
            int_raddr           = raddr;

            if (dout_merge) begin
                dout            = (rbuf_bw & rbuf_data) | (~rbuf_bw & dout);
            end else begin
                dout            = int_dout;
            end
        end
    end

    // resolve collision
    wire col_RW, col_RB;            // read-write, read-buffer address collisions

    assign col_RW               = raddr == waddr;
    assign col_RB               = raddr == wbuf_addr;

    always @* begin
        wbuf_src                = SRC_NONE;
        wr_src                  = SRC_NONE;
        rd_src                  = SRC_NONE;

        if (~rst) begin
            case ({we, wbuf_vld, re})
                3'b001: begin   // read-only
                    rd_src      = SRC_NEW;
                end
                3'b010: begin   // buffered write-only
                    wr_src      = SRC_BUF;
                end
                3'b100: begin   // new write-only
                    wr_src      = SRC_NEW;
                end
                3'b011: begin   // new read and buffered write
                    if (col_RB) begin
                        wbuf_src    = SRC_BUF;
                        rd_src      = SRC_BUF;
                    end else begin
                        wr_src  = SRC_BUF;
                        rd_src  = SRC_NEW;
                    end
                end
                3'b101: begin   // new read and new write
                    rd_src      = SRC_NEW;

                    if (col_RW) begin
                        wbuf_src    = SRC_NEW;
                    end else begin
                        wr_src      = SRC_NEW;
                    end
                end
                3'b110: begin   // new write and buffered write
                    wr_src      = SRC_BUF;
                    wbuf_src    = SRC_NEW;
                end
                3'b111: begin   // all happening!
                    case ({col_RW, col_RB})
                        2'b00,
                        2'b10: begin
                            rd_src      = SRC_NEW;
                            wr_src      = SRC_BUF;
                            wbuf_src    = SRC_NEW;
                        end
                        2'b01: begin
                            rd_src      = SRC_BUF;
                            wr_src      = SRC_NEW;
                            wbuf_src    = SRC_BUF;
                                // XXX: This violates BRAM ordering inside i_ram
                        end
                        2'b11: begin
                            rd_src      = SRC_BUF;
                            wbuf_src    = SRC_MERGE;
                        end
                    endcase
                end
            endcase
        end
    end

endmodule
