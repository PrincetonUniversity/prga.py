// Automatically generated by PRGA's RTL generator
module prga_onehot_decoder (data_i, idx_o);

    parameter   INDEX_WIDTH = 1;
    parameter   DATA_WIDTH = 0;

    localparam  ALIGNED_DATA_WIDTH = 1 << INDEX_WIDTH;
    localparam  ACTUAL_DATA_WIDTH = DATA_WIDTH == 0 ? ALIGNED_DATA_WIDTH : DATA_WIDTH;

    input wire [ACTUAL_DATA_WIDTH-1:0]  data_i;
    output wire [INDEX_WIDTH-1:0]       idx_o;

    /*
    * Algorithm: trailing-zero detection
    *
    *   idx_bit     data
    *             0000_0100
    *      0       x x  x x
    *      1        xx   xx
    *      2           xxxx
    *
    *   idx_o[idx_bit] = ~|data[x]
    */

    wire [ALIGNED_DATA_WIDTH-1:0]   data_aligned;
    generate
        if (ALIGNED_DATA_WIDTH > ACTUAL_DATA_WIDTH) begin
            assign data_aligned = { { (ALIGNED_DATA_WIDTH - ACTUAL_DATA_WIDTH) {1'b0} }, data_i };
        end else begin
            assign data_aligned = data_i;
        end
    endgenerate

    genvar gv_bit, gv_bit_subset;
    generate
        for (gv_bit = 0;
            gv_bit < INDEX_WIDTH;
            gv_bit = gv_bit + 1
        ) begin: g_bit
            wire [ALIGNED_DATA_WIDTH/2-1:0] subset;
            assign idx_o[gv_bit] = ~|subset;

            for (gv_bit_subset = 0;
                gv_bit_subset < ALIGNED_DATA_WIDTH/2;
                gv_bit_subset = gv_bit_subset + (1 << gv_bit)
            ) begin: g_bit_subset
                assign subset[gv_bit_subset +: (1 << gv_bit)] =
                    data_aligned[(gv_bit_subset << 1) +: (1 << gv_bit)];
            end
        end
    endgenerate

endmodule
