// Automatically generated by PRGA's RTL generator
`include "prga_utils.vh"
`include "prga_yami.vh"

/*
* Pipelined load shim for a simple valid-ready slave.
*/

module {{ module.name }} #(
    parameter   KERNEL_DATA_BYTES_LOG2  = {{ ((module.ports.kdata|length) // 8 - 1).bit_length() }}
    , parameter MAX_INFLIGHT_LOADS      = 31
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr    // base address
    , input wire [31:0]                             cfg_len     // # elements to load
    , input wire                                    cfg_start
    , output wire                                   cfg_idle

    // == Kernel-side Interface ==============================================
    , input wire                                    krdy
    , output wire                                   kvld
    , output wire [(8<<KERNEL_DATA_BYTES_LOG2)-1:0] kdata

    // == Memory-side YAMI Interface =========================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , input wire                                    fmc_rdy
    , output reg                                    fmc_vld
    , output wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]    fmc_type
    , output wire [`PRGA_YAMI_SIZE_WIDTH-1:0]       fmc_size
    , output wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]   fmc_addr
    // load shim, ignore request data
    // , output reg [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]    fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , output wire                                   mfc_rdy
    , input wire                                    mfc_vld
    // fixed transactions, ignore response type
    // , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]    mfc_type
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_data
    // cache is not supported beyond this shim
    // , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]    mfc_addr
    );

    localparam  INFLIGHT_LOAD_COUNTER_WIDTH = `PRGA_CLOG2(MAX_INFLIGHT_LOADS + 1);
    reg [INFLIGHT_LOAD_COUNTER_WIDTH-1:0]   ifl_cnt;

    always @(posedge clk) begin
        if (~rst_n) begin
            ifl_cnt     <= { INFLIGHT_LOAD_COUNTER_WIDTH {1'b0} };
        end else if (cfg_start && cfg_idle) begin
            ifl_cnt     <= { INFLIGHT_LOAD_COUNTER_WIDTH {1'b0} };
        end else begin
            case ({fmc_vld && fmc_rdy, mfc_vld && mfc_rdy})
                2'b01:  ifl_cnt <= ifl_cnt - 1;
                2'b10:  ifl_cnt <= ifl_cnt + 1;
            endcase
        end
    end

    // == Request to FMC =====================================================
    localparam  QST_WIDTH   = 2;
    localparam  QST_RST     = 2'h0,
                QST_IDLE    = 2'h1,
                QST_BUSY    = 2'h2;

    reg [QST_WIDTH-1:0]                     req_state, req_state_next;
    reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]     req_addr,  req_addr_next;
    reg [31:0]                              req_len,   req_len_next;

    wire [`PRGA_YAMI_FMC_ADDR_WIDTH-`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0] req_addr_full;
    wire [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]                           req_addr_offset, req_valid_words;

    assign {req_addr_full, req_addr_offset} = req_addr;
    assign req_valid_words = (`PRGA_YAMI_MFC_DATA_BYTES - req_addr_offset) >> KERNEL_DATA_BYTES_LOG2;

    always @(posedge clk) begin
        if (~rst_n) begin
            req_state   <= QST_RST;
            req_addr    <= {`PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
            req_len     <= 32'h0;
        end else begin
            req_state   <= req_state_next;
            req_addr    <= req_addr_next;
            req_len     <= req_len_next;
        end
    end

    assign fmc_type = `PRGA_YAMI_REQTYPE_LOAD;
    assign fmc_size = `PRGA_YAMI_SIZE_FULL;
    assign fmc_addr = req_addr_full << `PRGA_YAMI_MFC_DATA_BYTES_LOG2;

    always @* begin
        req_state_next  = req_state;
        req_addr_next   = req_addr;
        req_len_next    = req_len;

        fmc_vld         = 1'b0;

        case (req_state)
            QST_RST:    req_state_next = QST_IDLE;
            QST_IDLE: begin
                if (cfg_start && cfg_idle) begin
                    req_state_next  = QST_BUSY;
                    req_addr_next   = cfg_addr;
                    req_len_next    = cfg_len;
                end
            end
            QST_BUSY: if (ifl_cnt < MAX_INFLIGHT_LOADS) begin
                fmc_vld     = 1'b1;

                if (fmc_rdy) begin
                    if (req_valid_words >= req_len) begin
                        req_state_next  = QST_IDLE;
                    end else begin
                        req_addr_next   = (req_addr_full + 1) << `PRGA_YAMI_MFC_DATA_BYTES_LOG2;
                        req_len_next    = req_len - req_valid_words;
                    end
                end
            end
        endcase
    end

    // == Response from MFC ==================================================
    localparam  RST_WIDTH   = 2;    // Response State
    localparam  RST_RST     = 2'h0,
                RST_IDLE    = 2'h1,
                RST_BUSY    = 2'h2;

    reg [RST_WIDTH-1:0]                         resp_state,  resp_state_next;
    reg [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]    resp_offset, resp_offset_next;
    reg [31:0]                                  resp_len,    resp_len_next;

    wire [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]   resp_valid_words;
    assign resp_valid_words = (`PRGA_YAMI_MFC_DATA_BYTES - resp_offset) >> KERNEL_DATA_BYTES_LOG2;

    always @(posedge clk) begin
        if (~rst_n) begin
            resp_state  <= RST_RST;
            resp_offset <= { `PRGA_YAMI_MFC_DATA_BYTES_LOG2 {1'b0} };
            resp_len    <= 32'h0;
        end else begin
            resp_state  <= resp_state_next;
            resp_offset <= resp_offset_next;
            resp_len    <= resp_len_next;
        end
    end

    always @* begin
        resp_state_next     = resp_state;
        resp_offset_next    = resp_offset;
        resp_len_next       = resp_len;

        case (resp_state)
            RST_RST:    resp_state_next = RST_IDLE;
            RST_IDLE: begin
                if (cfg_start && cfg_idle) begin
                    resp_state_next     = RST_BUSY;
                    resp_offset_next    = cfg_addr[0+:`PRGA_YAMI_MFC_DATA_BYTES_LOG2];
                    resp_len_next       = cfg_len;
                end
            end
            RST_BUSY: begin
                if (mfc_vld && mfc_rdy) begin
                    if (resp_valid_words >= resp_len) begin
                        resp_state_next = QST_IDLE;
                    end else begin
                        resp_offset_next    = { `PRGA_YAMI_MFC_DATA_BYTES_LOG2 {1'b0} };
                        resp_len_next       = resp_len - resp_valid_words;
                    end
                end
            end
        endcase
    end

    localparam  KERNEL_WORDS_PER_MFC_DATA   = 1 << (`PRGA_YAMI_MFC_DATA_BYTES_LOG2 - KERNEL_DATA_BYTES_LOG2);
    localparam  KERNEL_DATA_WIDTH           = 8 << KERNEL_DATA_BYTES_LOG2;
    localparam  RESIZER_DATA_WIDTH          = KERNEL_WORDS_PER_MFC_DATA * (KERNEL_DATA_WIDTH + 1);

    wire resizer_empty_i, resizer_rd_i, resizer_empty, resizer_rd, resizer_vld;
    wire [RESIZER_DATA_WIDTH - 1:0] resizer_dout_i;

    genvar gv;
    generate
        for (gv = 0; gv < KERNEL_WORDS_PER_MFC_DATA; gv = gv + 1) begin: g_dout
            assign resizer_dout_i[gv * (KERNEL_DATA_WIDTH + 1) +: (KERNEL_DATA_WIDTH + 1)] =
                {(gv << KERNEL_DATA_BYTES_LOG2) >= resp_offset && gv < resp_len, mfc_data[gv * KERNEL_DATA_WIDTH +: KERNEL_DATA_WIDTH]};
        end
    endgenerate

    prga_fifo_resizer #(
        .DATA_WIDTH         (KERNEL_DATA_WIDTH + 1) // $size(kdata) + $size(kvld)
        ,.INPUT_MULTIPLIER  (KERNEL_WORDS_PER_MFC_DATA)
        ,.INPUT_LOOKAHEAD   (1)
        ,.OUTPUT_LOOKAHEAD  (1)
        ,.LITTLE_ENDIAN     (1)
    ) i_resizer (
        .clk        (clk)
        ,.rst       (~rst_n)
        ,.empty_i   (resizer_empty_i)
        ,.rd_i      (resizer_rd_i)
        ,.dout_i    (resizer_dout_i)
        ,.empty     (resizer_empty)
        ,.rd        (resizer_rd)
        ,.dout      ({resizer_vld, kdata})
        );

    assign resizer_empty_i = resp_state != RST_BUSY || !mfc_vld;
    assign mfc_rdy = resp_state == RST_BUSY && resizer_rd_i;

    assign cfg_idle = req_state == QST_IDLE && resp_state == RST_IDLE;
    assign kvld = !resizer_empty && resizer_vld;
    assign resizer_rd = krdy;

endmodule
