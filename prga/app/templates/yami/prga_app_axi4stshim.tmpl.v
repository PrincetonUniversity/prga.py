// Automatically generated by PRGA's RTL generator
`include "prga_axi4.vh"
`include "prga_yami.vh"

/*
* AXI4 store channel shim.
*
*   Add a shim between the kernel (hls design) and the fabric ports.
*
*   Functions:
*       - Address offsetting
*       - Break burst access into YAMI transactions
*/

module {{ module.name }} #(
    parameter   KERNEL_ADDR_WIDTH = {{ module.ports.awaddr|length }}
    , parameter KERNEL_DATA_BYTES_LOG2 = {{ ((module.ports.wdata|length) // 8 - 1).bit_length() }}
    , parameter PRQ_DEPTH_LOG2 = 3
    , parameter OPT_THRUPUT = 1     // optimize throughput (use feedthrough control)
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    //  XXX: Control values are assumed to be constant throughout a full burst
    //  (from the first AW/W request to the last B response)
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr_offset
    , input wire                                    cfg_nc

    // == Kernel-side AXI4 Interface ==========================================
    , output wire                                   awready
    , input wire                                    awvalid
    , input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]     awburst
    , input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]      awsize
    , input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]       awlen
    , input wire [KERNEL_ADDR_WIDTH-1:0]            awaddr

    , output wire                                   wready
    , input wire                                    wvalid
    , input wire [(8<<KERNEL_DATA_BYTES_LOG2)-1:0]  wdata
    , input wire [(1<<KERNEL_DATA_BYTES_LOG2)-1:0]  wstrb
    , input wire                                    wlast

    , input wire                                    bready
    , output reg                                    bvalid
    , output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]      bresp

    // == Memory-side YAMI Interface =========================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , input wire                                    fmc_rdy
    , output wire                                   fmc_vld
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]     fmc_type
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]        fmc_size
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    fmc_addr
    , output reg [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]    fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , output wire                                   mfc_rdy
    , input wire                                    mfc_vld
    // fixed transactions, ignore response type
    // , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]    mfc_type
    // store shim, ignore response data
    // , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_data
    // cache is not supported beyond this shim
    // , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]    mfc_addr
    );

    // == AW -> FMC ==========================================================
    reg                                 wvld;
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]  awburst_f;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    wlen;

    always @(posedge clk) begin
        if (~rst_n) begin
            fmc_type <= `PRGA_YAMI_REQTYPE_STORE;
        end else begin
            fmc_type <= cfg_nc ? `PRGA_YAMI_REQTYPE_STORE_NC : `PRGA_YAMI_REQTYPE_STORE;
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            wvld <= 1'b0;
            awburst_f <= `PRGA_AXI4_AXBURST_FIXED;
            wlen <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            fmc_size <= `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        end else if (awready && awvalid) begin
            wvld <= 1'b1;
            awburst_f <= awburst;
            wlen <= awlen;
            fmc_size <= awsize == `PRGA_AXI4_AXSIZE_1B  ? `PRGA_YAMI_SIZE_1B :
                        awsize == `PRGA_AXI4_AXSIZE_2B  ? `PRGA_YAMI_SIZE_2B :
                        awsize == `PRGA_AXI4_AXSIZE_4B  ? `PRGA_YAMI_SIZE_4B :
                        awsize == `PRGA_AXI4_AXSIZE_8B  ? `PRGA_YAMI_SIZE_8B :
                        awsize == `PRGA_AXI4_AXSIZE_16B ? `PRGA_YAMI_SIZE_16B :
                        awsize == `PRGA_AXI4_AXSIZE_32B ? `PRGA_YAMI_SIZE_32B :
                                                          `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= cfg_addr_offset + awaddr;
        end else if (fmc_vld && fmc_rdy) begin
            if (wlen == 0) begin     // last request sent
                wvld <= 1'b0;
            end else begin
                wlen <= wlen - 1;

                // XXX: WRAP rule ignored
                fmc_addr <= fmc_addr + (awburst_f == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                            fmc_size == `PRGA_YAMI_SIZE_1B  ? 1 :
                            fmc_size == `PRGA_YAMI_SIZE_2B  ? 2 :
                            fmc_size == `PRGA_YAMI_SIZE_4B  ? 4 :
                            fmc_size == `PRGA_YAMI_SIZE_8B  ? 8 :
                            fmc_size == `PRGA_YAMI_SIZE_16B ? 16 :
                            fmc_size == `PRGA_YAMI_SIZE_32B ? 32 :
                                                              `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    wire wstall;

    generate
        if (OPT_THRUPUT) begin
            assign wstall = wvld && (wlen != 0 || !wvalid || !fmc_rdy);
        end else begin
            assign wstall = wvld;
        end
    endgenerate

    // == Pending Response Queue =============================================
    wire                                prq_rd, prq_full, prq_empty;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]   prq_dout;

    prga_fifo #(
        .DATA_WIDTH     (`PRGA_AXI4_AXLEN_WIDTH)
        ,.DEPTH_LOG2    (PRQ_DEPTH_LOG2)
        ,.LOOKAHEAD     (1)
    ) i_prq (
        .clk            (clk)
        ,.rst           (~rst_n)
        ,.full          (prq_full)
        ,.wr            (awvalid && !wstall)
        ,.din           (awlen)
        ,.empty         (prq_empty)
        ,.rd            (prq_rd)
        ,.dout          (prq_dout)
        );

    assign awready = !prq_full && !wstall;

    // == W -> FMC ===========================================================
    assign wready = wvld && fmc_rdy;
    assign fmc_vld = wvld && wvalid;

    generate
        if (KERNEL_DATA_BYTES_LOG2 == 0) begin     // 1B AXI4
            always @* begin
                fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES {wdata} };
            end
        end else if (KERNEL_DATA_BYTES_LOG2 == 1) begin     // 2B AXI4
            always @* begin
                case (wstrb)
                    2'b01:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 0+: 8]} };
                    2'b10:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 8+: 8]} };
                    default: fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata} };
                endcase
            end
        end else if (KERNEL_DATA_BYTES_LOG2 == 2) begin     // 4B AXI4
            always @* begin
                case (wstrb)
                    4'b0001: fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 0+: 8]} };
                    4'b0010: fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 8+: 8]} };
                    4'b0100: fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[16+: 8]} };
                    4'b1000: fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[24+: 8]} };
                    4'b0011: fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[ 0+:16]} };
                    4'b1100: fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[16+:16]} };
                    default: fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/4) {wdata} };
                endcase
            end
        end else if (KERNEL_DATA_BYTES_LOG2 == 3) begin     // 8B AXI4, this is the widest possible setting
            always @* begin
                case (wstrb)
                    8'h01:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 0+: 8]} };
                    8'h02:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[ 8+: 8]} };
                    8'h04:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[16+: 8]} };
                    8'h08:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[24+: 8]} };
                    8'h10:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[32+: 8]} };
                    8'h20:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[40+: 8]} };
                    8'h40:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[48+: 8]} };
                    8'h80:   fmc_data = { `PRGA_YAMI_FMC_DATA_BYTES     {wdata[56+: 8]} };
                    8'h03:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[ 0+:16]} };
                    8'h0c:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[16+:16]} };
                    8'h30:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[32+:16]} };
                    8'hc0:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/2) {wdata[48+:16]} };
                    8'h0f:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/4) {wdata[ 0+:32]} };
                    8'hf0:   fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/4) {wdata[32+:32]} };
                    default: fmc_data = { (`PRGA_YAMI_FMC_DATA_BYTES/8) {wdata} };
                endcase
            end
        end else begin
            __PRGA_PARAMETERIZATION_ERROR__ __error__();
        end
    endgenerate

    // == MFC -> B ===========================================================
    reg                                 bvld;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    blen;

    always @(posedge clk) begin
        if (~rst_n) begin
            bvld <= 1'b0;
            blen <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
        end else if (!prq_empty && prq_rd) begin
            bvld <= 1'b1;
            blen <= prq_dout;
        end else if (mfc_rdy && mfc_vld) begin
            if (blen == 0) begin
                bvld <= 1'b0;
            end else begin
                blen <= blen - 1;
            end
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            bvalid <= 1'b0;
        end else if (mfc_rdy && mfc_vld && blen == 0) begin
            bvalid <= 1'b1;
        end else if (bready) begin
            bvalid <= 1'b0;
        end
    end

    assign bresp = `PRGA_AXI4_XRESP_OKAY;

    generate
        if (OPT_THRUPUT) begin
            assign mfc_rdy = bvld && (blen != 0 || !bvalid || bready);
            assign prq_rd = !bvld || (blen == 0 && mfc_vld && (!bvalid || bready));
        end else begin
            assign mfc_rdy = bvld && (blen != 0 || !bvalid);
            assign prq_rd = !bvld;
        end
    endgenerate

endmodule
