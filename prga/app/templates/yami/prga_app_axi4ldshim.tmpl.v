// Automatically generated by PRGA's RTL generator
`include "prga_axi4.vh"
`include "prga_yami.vh"

/*
* AXI4 load channel shim.
*
*   Add a shim between the kernel (hls design) and the fabric ports.
*
*   Functions:
*       - Address offsetting
*       - Break burst access into YAMI transactions
*/

module {{ module.name }} #(
    parameter   KERNEL_ADDR_WIDTH = {{ module.ports.araddr|length }}
    , parameter KERNEL_DATA_BYTES_LOG2 = {{ ((module.ports.rdata|length) / 8 - 1).bit_length() }}
    , parameter PRQ_DEPTH_LOG2 = 3
    , parameter OPT_THRUPUT = 1     // optimize throughput (use feedthrough control)
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    //  XXX: Control values are assumed to be constant throughout a full burst
    //  (from the first AR request to the last R response)
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr_offset
    , input wire                                    cfg_nc

    // == Kernel-side AXI4 Interface =========================================
    , output wire                                   arready
    , input wire                                    arvalid
    , input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]     arburst
    , input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]      arsize
    , input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]       arlen
    , input wire [KERNEL_ADDR_WIDTH-1:0]            araddr

    , input wire                                    rready
    , output wire                                   rvalid
    , output wire                                   rlast
    , output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]      rresp
    , output wire [(8<<KERNEL_DATA_BYTES_LOG2)-1:0] rdata

    // == Memory-side YAMI Interface =========================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , input wire                                    fmc_rdy
    , output reg                                    fmc_vld
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]     fmc_type
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]        fmc_size
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    fmc_addr
    // load shim, ignore request data
    // , output reg [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]    fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , output wire                                   mfc_rdy
    , input wire                                    mfc_vld
    // fixed transactions, ignore response type
    // , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]    mfc_type
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_data
    // cache is not supported beyond this shim
    // , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]    mfc_addr
    );

    // == AR -> FMC ==========================================================
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]  arburst_f;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    arlen_f;

    always @(posedge clk) begin
        if (~rst_n) begin
            fmc_type <= `PRGA_YAMI_REQTYPE_LOAD;
        end else begin
            fmc_type <= cfg_nc ? `PRGA_YAMI_REQTYPE_LOAD_NC ? `PRGA_YAMI_REQTYPE_LOAD;
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            arburst_f <= `PRGA_AXI4_AXBURST_FIXED;
            arlen_f <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            fmc_vld <= 1'b0;
            fmc_size <= KERNEL_DATA_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                        KERNEL_DATA_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                        KERNEL_DATA_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                        KERNEL_DATA_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                        KERNEL_DATA_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                        KERNEL_DATA_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                      `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        end else if (arready && arvalid) begin
            arburst_f <= arburst;
            arlen_f <= arlen;
            fmc_vld <= 1'b1;
            fmc_size <= arsize == `PRGA_AXI4_AXSIZE_1B ? `PRGA_YAMI_SIZE_1B :
                        `PRGA_AXI4_AXSIZE_2B  ? `PRGA_YAMI_SIZE_2B :
                        `PRGA_AXI4_AXSIZE_4B  ? `PRGA_YAMI_SIZE_4B :
                        `PRGA_AXI4_AXSIZE_8B  ? `PRGA_YAMI_SIZE_8B :
                        `PRGA_AXI4_AXSIZE_16B ? `PRGA_YAMI_SIZE_16B :
                        `PRGA_AXI4_AXSIZE_32B ? `PRGA_YAMI_SIZE_32B :
                                                `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= cfg_addr_offset + araddr;
        end else if (fmc_vld && fmc_rdy) begin
            if (arlen_f == 0) begin     // last request sent
                fmc_vld <= 1'b0;
            end else begin
                arlen_f <= arlen_f - 1;

                // XXX: WRAP rule ignored
                fmc_addr <= fmc_addr + (arburst_f == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                            fmc_size == `PRGA_YAMI_SIZE_1B  ? 1 :
                            fmc_size == `PRGA_YAMI_SIZE_2B  ? 2 :
                            fmc_size == `PRGA_YAMI_SIZE_4B  ? 4 :
                            fmc_size == `PRGA_YAMI_SIZE_8B  ? 8 :
                            fmc_size == `PRGA_YAMI_SIZE_16B ? 16 :
                            fmc_size == `PRGA_YAMI_SIZE_32B ? 32 :
                                                              `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    wire rstall;

    generate
        if (OPT_THRUPUT) begin
            assign rstall = fmc_vld && (arlen_f > 0 || !fmc_rdy);
        end else begin
            assign rstall = fmc_vld;
        end
    endgenerate


    // == Pending Response Queue =============================================
    wire                                prq_rd, prq_full, prq_empty;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]   prq_dout;

    prga_fifo #(
        .DATA_WIDTH     (`PRGA_AXI4_AXLEN_WIDTH)
        ,.DEPTH_LOG2    (PRQ_DEPTH_LOG2)
        ,.LOOKAHEAD     (1)
    ) i_prq (
        .clk            (clk)
        ,.rst           (~rst_n)
        ,.full          (prq_full)
        ,.wr            (arvalid && !rstall)
        ,.din           (arlen)
        ,.empty         (prq_empty)
        ,.rd            (prq_rd)
        ,.dout          (prq_dout)
        );

    assign arready = !prq_full && !rstall;

    // == MFC -> R ===========================================================
    reg                                 rvld;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    rlen;

    always @(posedge clk) begin
        if (~rst_n) begin
            rvld <= 1'b0;
            rlen <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
        end else if (!prq_empty && prq_rd) begin
            rvld <= 1'b1;
            rlen <= prq_dout;
        end else if (rready && rvalid) begin
            if (rlen == 0) begin
                rvld <= 1'b0;
            end else begin
                rlen <= rlen - 1;
            end
        end
    end

    assign rvalid = rvld && mfc_vld;
    assign rlast = rlen == 0;
    assign rresp = `PRGA_AXI4_XRESP_OKAY;
    assign rdata = mfc_data[0 +: (8<<KERNEL_DATA_BYTES_LOG2)];
    assign mfc_rdy = rvld && rready;

    generate
        if (OPT_THRUPUT) begin
            assign prq_rd = !rvld || (rlen == 0 && rready && mfc_vld);
        end else begin
            assign prq_rd = !rvld;
        end
    endgenerate

endmodule
