// Automatically generated by PRGA's RTL generator
`include "prga_axi4.vh"
`include "prga_yami.vh"

/*
* AXI4 load channel shim.
*
*   Add a shim between the kernel (hls design) and the fabric ports.
*
*   Functions:
*       - Address offsetting
*       - Break burst access into YAMI transactions
*/

module {{ module.name }} #(
    parameter   KERNEL_ADDR_WIDTH = {{ module.ports.araddr|length }}
    , parameter KERNEL_DATA_BYTES_LOG2 = {{ ((module.ports.rdata|length) // 8 - 1).bit_length() }}
    , parameter PRQ_DEPTH_LOG2 = 3
    , parameter OPT_THRUPUT = 1     // optimize throughput (use feedthrough control)
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    //  XXX: Control values are assumed to be constant throughout a full burst
    //  (from the first AR request to the last R response)
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr_offset
    , input wire                                    cfg_nc

    // == Kernel-side AXI4 Interface =========================================
    , output wire                                   arready
    , input wire                                    arvalid
    , input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]     arburst
    , input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]      arsize
    , input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]       arlen
    , input wire [KERNEL_ADDR_WIDTH-1:0]            araddr

    , input wire                                    rready
    , output wire                                   rvalid
    , output wire                                   rlast
    , output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]      rresp
    , output wire [(8<<KERNEL_DATA_BYTES_LOG2)-1:0] rdata

    // == Memory-side YAMI Interface =========================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , input wire                                    fmc_rdy
    , output reg                                    fmc_vld
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]     fmc_type
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]        fmc_size
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    fmc_addr
    // load shim, ignore request data
    // , output reg [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]    fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , output wire                                   mfc_rdy
    , input wire                                    mfc_vld
    // fixed transactions, ignore response type
    // , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]    mfc_type
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_data
    // cache is not supported beyond this shim
    // , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]    mfc_addr
    );

    // == AR -> FMC ==========================================================
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]          arburst_f;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]            arlen_f;

    wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        fmc_addr_next;
    assign fmc_addr_next = cfg_addr_offset + araddr;

    always @(posedge clk) begin
        if (~rst_n) begin
            fmc_type <= `PRGA_YAMI_REQTYPE_LOAD;
        end else begin
            fmc_type <= cfg_nc ? `PRGA_YAMI_REQTYPE_LOAD_NC : `PRGA_YAMI_REQTYPE_LOAD;
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            arburst_f <= `PRGA_AXI4_AXBURST_FIXED;
            arlen_f <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            fmc_vld <= 1'b0;
            fmc_size <= KERNEL_DATA_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                        KERNEL_DATA_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                        KERNEL_DATA_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                        KERNEL_DATA_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                        KERNEL_DATA_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                        KERNEL_DATA_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                      `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        end else if (arready && arvalid) begin
            arburst_f <= arburst;
            arlen_f <= arlen;
            fmc_vld <= 1'b1;
            fmc_size <= arsize == `PRGA_AXI4_AXSIZE_1B  ? `PRGA_YAMI_SIZE_1B :
                        arsize == `PRGA_AXI4_AXSIZE_2B  ? `PRGA_YAMI_SIZE_2B :
                        arsize == `PRGA_AXI4_AXSIZE_4B  ? `PRGA_YAMI_SIZE_4B :
                        arsize == `PRGA_AXI4_AXSIZE_8B  ? `PRGA_YAMI_SIZE_8B :
                        arsize == `PRGA_AXI4_AXSIZE_16B ? `PRGA_YAMI_SIZE_16B :
                        arsize == `PRGA_AXI4_AXSIZE_32B ? `PRGA_YAMI_SIZE_32B :
                                                          `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= fmc_addr_next;
        end else if (fmc_vld && fmc_rdy) begin
            if (arlen_f == 0) begin     // last request sent
                fmc_vld <= 1'b0;
            end else begin
                arlen_f <= arlen_f - 1;

                // XXX: WRAP rule ignored
                fmc_addr <= fmc_addr + (arburst_f == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                            fmc_size == `PRGA_YAMI_SIZE_1B  ? 1 :
                            fmc_size == `PRGA_YAMI_SIZE_2B  ? 2 :
                            fmc_size == `PRGA_YAMI_SIZE_4B  ? 4 :
                            fmc_size == `PRGA_YAMI_SIZE_8B  ? 8 :
                            fmc_size == `PRGA_YAMI_SIZE_16B ? 16 :
                            fmc_size == `PRGA_YAMI_SIZE_32B ? 32 :
                                                              `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    wire rstall;

    generate
        if (OPT_THRUPUT) begin
            assign rstall = fmc_vld && (arlen_f > 0 || !fmc_rdy);
        end else begin
            assign rstall = fmc_vld;
        end
    endgenerate


    // == Pending Response Queue =============================================
    wire                                        prq_rd, prq_full, prq_empty;
    wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]         rburst_next;
    wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]          rsize_next;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]           rlen_next;
    wire [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]   roffset_next;

    prga_fifo #(
        .DATA_WIDTH     (
            `PRGA_AXI4_AXBURST_WIDTH
            + `PRGA_AXI4_AXSIZE_WIDTH
            + `PRGA_AXI4_AXLEN_WIDTH
            + `PRGA_YAMI_MFC_DATA_BYTES_LOG2
        )
        ,.DEPTH_LOG2    (PRQ_DEPTH_LOG2)
        ,.LOOKAHEAD     (1)
    ) i_prq (
        .clk            (clk)
        ,.rst           (~rst_n)
        ,.full          (prq_full)
        ,.wr            (arvalid && !rstall)
        ,.din           ({
            arburst
            , arsize
            , arlen
            , fmc_addr_next[0+:`PRGA_YAMI_MFC_DATA_BYTES_LOG2]
        })
        ,.empty         (prq_empty)
        ,.rd            (prq_rd)
        ,.dout          ({
            rburst_next
            , rsize_next
            , rlen_next
            , roffset_next
        })
        );

    assign arready = !prq_full && !rstall;

    // == MFC -> R ===========================================================
    reg                                         rvld;
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]          rburst;
    reg [`PRGA_AXI4_AXSIZE_WIDTH-1:0]           rsize;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]            rlen;
    reg [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]    roffset;

    always @(posedge clk) begin
        if (~rst_n) begin
            rvld <= 1'b0;
            rlen <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            rsize <= { `PRGA_AXI4_AXSIZE_WIDTH {1'b0} };
            roffset <= { `PRGA_YAMI_MFC_DATA_BYTES_LOG2 {1'b0} };
        end else if (!prq_empty && prq_rd) begin
            rvld <= 1'b1;
            rlen <= rlen_next;
            rsize <= rsize_next;
            roffset <= roffset_next;
        end else if (rready && rvalid) begin
            if (rlen == 0) begin
                rvld <= 1'b0;
            end else begin
                rlen <= rlen - 1;

                // XXX: WRAP rule ignored
                roffset <= roffset + (rburst == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                           rsize == `PRGA_AXI4_AXSIZE_1B  ? 1 :
                           rsize == `PRGA_AXI4_AXSIZE_2B  ? 2 :
                           rsize == `PRGA_AXI4_AXSIZE_4B  ? 4 :
                           rsize == `PRGA_AXI4_AXSIZE_8B  ? 8 :
                           rsize == `PRGA_AXI4_AXSIZE_16B ? 16 :
                           rsize == `PRGA_AXI4_AXSIZE_32B ? 32 :
                                                            `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    assign rvalid = rvld && mfc_vld;
    assign rlast = rlen == 0;
    assign rresp = `PRGA_AXI4_XRESP_OKAY;
    assign mfc_rdy = rvld && rready;

    generate
        if (KERNEL_DATA_BYTES_LOG2 == 0) begin              // 1B AXI4
            assign rdata = mfc_data[{roffset, 3'h0}+:8];
        end else if (KERNEL_DATA_BYTES_LOG2 == 1) begin     // 2B AXI4
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {2 {mfc_data[{roffset, 3'h0}+: 8]} } :
                                                           {1 {mfc_data[{roffset, 3'h0}+:16]} };
        end else if (KERNEL_DATA_BYTES_LOG2 == 2) begin     // 4B AXI4
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {4 {mfc_data[{roffset, 3'h0}+: 8]} } :
                           rsize == `PRGA_AXI4_AXSIZE_2B ? {2 {mfc_data[{roffset, 3'h0}+:16]} } :
                                                           {1 {mfc_data[{roffset, 3'h0}+:32]} };
        end else if (KERNEL_DATA_BYTES_LOG2 == 3) begin     // 8B AXI4, this is the widest possible setting
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {8 {mfc_data[{roffset, 3'h0}+: 8]} } :
                           rsize == `PRGA_AXI4_AXSIZE_2B ? {4 {mfc_data[{roffset, 3'h0}+:16]} } :
                           rsize == `PRGA_AXI4_AXSIZE_4B ? {2 {mfc_data[{roffset, 3'h0}+:32]} } :
                                                           {1 {mfc_data[{roffset, 3'h0}+:64]} };
        end else begin
            __PRGA_PARAMETERIZATION_ERROR__ __error__();
        end
    endgenerate

    generate
        if (OPT_THRUPUT) begin
            assign prq_rd = !rvld || (rlen == 0 && rready && mfc_vld);
        end else begin
            assign prq_rd = !rvld;
        end
    endgenerate

endmodule
