// Automatically generated by PRGA's RTL generator
`include "prga_axi4.vh"
`include "prga_yami.vh"

/*
* AXI4 load channel shim.
*
*   Add a shim between the kernel (hls design) and the fabric ports.
*
*   Functions:
*       - Address offsetting
*       - Break burst access into YAMI transactions
*/

module {{ module.name }} #(
    parameter   KERNEL_ADDR_WIDTH = {{ module.ports.araddr|length }}
    , parameter KERNEL_DATA_BYTES_LOG2 = {{ ((module.ports.rdata|length) // 8 - 1).bit_length() }}
    , parameter PRQ_DEPTH_LOG2 = 3
    , parameter OPT_THRUPUT = 1     // optimize throughput (use feedthrough control)
    , parameter SWAP_ENDIANNESS = 0
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    //  XXX: Control values are assumed to be constant throughout a full burst
    //  (from the first AR request to the last R response)
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr_offset
    , input wire                                    cfg_nc

    // == Kernel-side AXI4 Interface =========================================
    , output wire                                   arready
    , input wire                                    arvalid
    , input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]     arburst
    , input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]      arsize
    , input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]       arlen
    , input wire [KERNEL_ADDR_WIDTH-1:0]            araddr

    , input wire                                    rready
    , output wire                                   rvalid
    , output wire                                   rlast
    , output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]      rresp
    , output wire [(8<<KERNEL_DATA_BYTES_LOG2)-1:0] rdata

    // == Memory-side YAMI Interface =========================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , input wire                                    fmc_rdy
    , output reg                                    fmc_vld
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]     fmc_type
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]        fmc_size
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    fmc_addr
    // load shim, ignore request data
    // , output reg [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]    fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , output wire                                   mfc_rdy
    , input wire                                    mfc_vld
    // fixed transactions, ignore response type
    // , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]    mfc_type
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_data
    // cache is not supported beyond this shim
    // , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]    mfc_addr
    );

    // == AR -> FMC ==========================================================
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]          arburst_f;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]            arlen_f;

    wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        fmc_addr_next;
    assign fmc_addr_next = cfg_addr_offset + araddr;

    always @(posedge clk) begin
        if (~rst_n) begin
            fmc_type <= `PRGA_YAMI_REQTYPE_LOAD;
        end else begin
            fmc_type <= cfg_nc ? `PRGA_YAMI_REQTYPE_LOAD_NC : `PRGA_YAMI_REQTYPE_LOAD;
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            arburst_f <= `PRGA_AXI4_AXBURST_FIXED;
            arlen_f <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            fmc_vld <= 1'b0;
            fmc_size <= KERNEL_DATA_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                        KERNEL_DATA_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                        KERNEL_DATA_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                        KERNEL_DATA_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                        KERNEL_DATA_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                        KERNEL_DATA_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                      `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        end else if (arready && arvalid) begin
            arburst_f <= arburst;
            arlen_f <= arlen;
            fmc_vld <= 1'b1;
            fmc_size <= arsize == `PRGA_AXI4_AXSIZE_1B  ? `PRGA_YAMI_SIZE_1B :
                        arsize == `PRGA_AXI4_AXSIZE_2B  ? `PRGA_YAMI_SIZE_2B :
                        arsize == `PRGA_AXI4_AXSIZE_4B  ? `PRGA_YAMI_SIZE_4B :
                        arsize == `PRGA_AXI4_AXSIZE_8B  ? `PRGA_YAMI_SIZE_8B :
                        arsize == `PRGA_AXI4_AXSIZE_16B ? `PRGA_YAMI_SIZE_16B :
                        arsize == `PRGA_AXI4_AXSIZE_32B ? `PRGA_YAMI_SIZE_32B :
                                                          `PRGA_YAMI_SIZE_FULL;
            fmc_addr <= fmc_addr_next;
        end else if (fmc_vld && fmc_rdy) begin
            if (arlen_f == 0) begin     // last request sent
                fmc_vld <= 1'b0;
            end else begin
                arlen_f <= arlen_f - 1;

                // XXX: WRAP rule ignored
                fmc_addr <= fmc_addr + (arburst_f == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                            fmc_size == `PRGA_YAMI_SIZE_1B  ? 1 :
                            fmc_size == `PRGA_YAMI_SIZE_2B  ? 2 :
                            fmc_size == `PRGA_YAMI_SIZE_4B  ? 4 :
                            fmc_size == `PRGA_YAMI_SIZE_8B  ? 8 :
                            fmc_size == `PRGA_YAMI_SIZE_16B ? 16 :
                            fmc_size == `PRGA_YAMI_SIZE_32B ? 32 :
                                                              `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    wire rstall;

    generate
        if (OPT_THRUPUT) begin
            assign rstall = fmc_vld && (arlen_f > 0 || !fmc_rdy);
        end else begin
            assign rstall = fmc_vld;
        end
    endgenerate


    // == Pending Response Queue =============================================
    wire                                        prq_rd, prq_full, prq_empty;
    wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]         rburst_next;
    wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]          rsize_next;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]           rlen_next;
    wire [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]   roffset_next;

    prga_fifo #(
        .DATA_WIDTH     (
            `PRGA_AXI4_AXBURST_WIDTH
            + `PRGA_AXI4_AXSIZE_WIDTH
            + `PRGA_AXI4_AXLEN_WIDTH
            + `PRGA_YAMI_MFC_DATA_BYTES_LOG2
        )
        ,.DEPTH_LOG2    (PRQ_DEPTH_LOG2)
        ,.LOOKAHEAD     (1)
    ) i_prq (
        .clk            (clk)
        ,.rst           (~rst_n)
        ,.full          (prq_full)
        ,.wr            (arvalid && !rstall)
        ,.din           ({
            arburst
            , arsize
            , arlen
            , fmc_addr_next[0+:`PRGA_YAMI_MFC_DATA_BYTES_LOG2]
        })
        ,.empty         (prq_empty)
        ,.rd            (prq_rd)
        ,.dout          ({
            rburst_next
            , rsize_next
            , rlen_next
            , roffset_next
        })
        );

    assign arready = !prq_full && !rstall;

    // == MFC -> R ===========================================================
    reg                                         rvld;
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]          rburst;
    reg [`PRGA_AXI4_AXSIZE_WIDTH-1:0]           rsize;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]            rlen;
    reg [`PRGA_YAMI_MFC_DATA_BYTES_LOG2-1:0]    roffset;

    always @(posedge clk) begin
        if (~rst_n) begin
            rvld <= 1'b0;
            rlen <= { `PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            rsize <= { `PRGA_AXI4_AXSIZE_WIDTH {1'b0} };
            roffset <= { `PRGA_YAMI_MFC_DATA_BYTES_LOG2 {1'b0} };
        end else if (!prq_empty && prq_rd) begin
            rvld <= 1'b1;
            rlen <= rlen_next;
            rsize <= rsize_next;
            roffset <= roffset_next;
        end else if (rready && rvalid) begin
            if (rlen == 0) begin
                rvld <= 1'b0;
            end else begin
                rlen <= rlen - 1;

                // XXX: WRAP rule ignored
                roffset <= roffset + (rburst == `PRGA_AXI4_AXBURST_FIXED ? 0 :
                           rsize == `PRGA_AXI4_AXSIZE_1B  ? 1 :
                           rsize == `PRGA_AXI4_AXSIZE_2B  ? 2 :
                           rsize == `PRGA_AXI4_AXSIZE_4B  ? 4 :
                           rsize == `PRGA_AXI4_AXSIZE_8B  ? 8 :
                           rsize == `PRGA_AXI4_AXSIZE_16B ? 16 :
                           rsize == `PRGA_AXI4_AXSIZE_32B ? 32 :
                                                            `PRGA_YAMI_MFC_DATA_BYTES);
            end
        end
    end

    assign rvalid = rvld && mfc_vld;
    assign rlast = rlen == 0;
    assign rresp = `PRGA_AXI4_XRESP_OKAY;
    assign mfc_rdy = rvld && rready;

    wire [ 7:0] bytes  [`PRGA_YAMI_MFC_DATA_BYTES-1:0];
    wire [15:0] words  [`PRGA_YAMI_MFC_DATA_BYTES/2-1:0];
    wire [31:0] dwords [`PRGA_YAMI_MFC_DATA_BYTES/4-1:0];
    wire [63:0] qwords [`PRGA_YAMI_MFC_DATA_BYTES/8-1:0];

    genvar gv_byte;
    generate
        for (gv_byte = 0; gv_byte < `PRGA_YAMI_MFC_DATA_BYTES; gv_byte = gv_byte + 1) begin: g_byte
            assign bytes[gv_byte] = mfc_data[gv_byte * 8 +: 8];
        end
    endgenerate

    genvar gv_word;
    generate
        for (gv_word = 0; gv_word < `PRGA_YAMI_MFC_DATA_BYTES/2; gv_word = gv_word + 1) begin: g_word
            if (SWAP_ENDIANNESS) begin
                assign words[gv_word] = {bytes[gv_word * 2], bytes[gv_word * 2 + 1]};
            end else begin
                assign words[gv_word] = {bytes[gv_word * 2 + 1], bytes[gv_word * 2]};
            end
        end
    endgenerate

    genvar gv_dword;
    generate
        for (gv_dword = 0; gv_dword < `PRGA_YAMI_MFC_DATA_BYTES/4; gv_dword = gv_dword + 1) begin: g_dword
            if (SWAP_ENDIANNESS) begin
                assign dwords[gv_dword] = {words[gv_dword * 2], words[gv_dword * 2 + 1]};
            end else begin
                assign dwords[gv_dword] = {words[gv_dword * 2 + 1], words[gv_dword * 2]};
            end
        end
    endgenerate

    genvar gv_qword;
    generate
        for (gv_qword = 0; gv_qword < `PRGA_YAMI_MFC_DATA_BYTES/8; gv_qword = gv_qword + 1) begin: g_qword
            if (SWAP_ENDIANNESS) begin
                assign qwords[gv_qword] = {dwords[gv_qword * 2], dwords[gv_qword * 2 + 1]};
            end else begin
                assign qwords[gv_qword] = {dwords[gv_qword * 2 + 1], dwords[gv_qword * 2]};
            end
        end
    endgenerate

    generate
        if (KERNEL_DATA_BYTES_LOG2 == 0) begin              // 1B AXI4
            assign rdata = bytes[roffset];
        end else if (KERNEL_DATA_BYTES_LOG2 == 1) begin     // 2B AXI4
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {2 {bytes [roffset]} } :
                                                           {1 {words [roffset >> 1]} };
        end else if (KERNEL_DATA_BYTES_LOG2 == 2) begin     // 4B AXI4
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {4 {bytes [roffset]} } :
                           rsize == `PRGA_AXI4_AXSIZE_2B ? {2 {words [roffset >> 1]} } :
                                                           {1 {dwords[roffset >> 2]} };
        end else if (KERNEL_DATA_BYTES_LOG2 == 3) begin     // 8B AXI4, this is the widest possible setting
            assign rdata = rsize == `PRGA_AXI4_AXSIZE_1B ? {8 {bytes [roffset]} } :
                           rsize == `PRGA_AXI4_AXSIZE_2B ? {4 {words [roffset >> 1]} } :
                           rsize == `PRGA_AXI4_AXSIZE_4B ? {2 {dwords[roffset >> 2]} } :
                                                           {1 {qwords[roffset >> 3]} };
        end else begin
            __PRGA_PARAMETERIZATION_ERROR__ __error__();
        end
    endgenerate

    generate
        if (OPT_THRUPUT) begin
            assign prq_rd = !rvld || (rlen == 0 && rready && mfc_vld);
        end else begin
            assign prq_rd = !rvld;
        end
    endgenerate

endmodule
