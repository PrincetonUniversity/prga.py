// Automatically generated by PRGA's RTL generator
`include "prga_utils.vh"
`include "prga_axi4.vh"
`include "prga_yami.vh"

/*
* AXI4 input (AW/W channels), YAMI output, blocking memory demuxer.
*
*   Distribute memory requests based on the address.
*/

module {{ module.name }} #(
    parameter   AXI4_ADDR_WIDTH = {{ module.ports.awaddr|length }}
    , parameter AXI4_DATA_WIDTH = {{ module.ports.wdata|length }}
    , parameter ACK_FAST        = 0     // if it's ok to ack AXI4 before ack'ed by YAMI
) (
    input wire                                      clk
    , input wire                                    rst_n

    // == Control (Soft Registers) ===========================================
    //  XXX: Control values are assumed to be constant throughout a call to kernel
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]    cfg_addr_offset

    // == Kernel-side AXI4 Interface =========================================
    , output wire                                   awready
    , input wire                                    awvalid
    , input wire [AXI4_ADDR_WIDTH-1:0]              awaddr
    , input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]      awsize

    , output wire                                   wready
    , input wire                                    wvalid
    , input wire [AXI4_DATA_WIDTH-1:0]              wdata

    , input wire                                    bready
    , output reg                                    bvalid
    , output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]      bresp

    // == Destinations =======================================================
    {%- for i in range(module.num_dsts) %}
    , input wire                                    dst{{ i }}_fmc_rdy
    , output reg                                    dst{{ i }}_fmc_vld
    , output wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]    dst{{ i }}_fmc_type
    , output wire [`PRGA_YAMI_SIZE_WIDTH-1:0]       dst{{ i }}_fmc_size
    , output wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]   dst{{ i }}_fmc_addr
    , output wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]   dst{{ i }}_fmc_data

    , output reg                                    dst{{ i }}_mfc_rdy
    , input wire                                    dst{{ i }}_mfc_vld

    {% endfor %}
    );

    localparam  DEMUX_ADDR_LOW  = {{ module.demux_addr_low }};
    localparam  DEMUX_ADDR_HIGH = {{ module.demux_addr_high }};

    localparam  NUM_DST         = {{ module.num_dsts }};
    localparam  NUM_ELEMS       = AXI4_DATA_WIDTH / `PRGA_YAMI_FMC_DATA_WIDTH; 
    localparam  NUM_ELEMS_LOG2  = `PRGA_CLOG2(NUM_ELEMS);

    generate if (NUM_ELEMS <= 1) begin
        __PRGA_PARAMETERIZATION_ERROR__ #(
            .ERROR_MSG("AXI4 data width must be larger than YAMI FMC data width")
        ) __error__ ();
    end endgenerate

    // == Shared Variables ===================================================
    reg                                 next_elem, xfer_done;

    // == W-Channel Buffering ================================================
    reg [AXI4_DATA_WIDTH-1:0]           wdata_f;
    reg                                 wdata_vld;

    always @(posedge clk) begin
        if (~rst_n) begin
            wdata_vld   <= 1'b0;
            wdata_f     <= { AXI4_DATA_WIDTH {1'b0} };
        end else if (wready && wvalid) begin
            wdata_vld   <= 1'b1;
            wdata_f     <= wdata;
        end else begin
            wdata_vld   <= !xfer_done && wdata_vld;
            if (next_elem)
                wdata_f <= wdata_f >> `PRGA_YAMI_FMC_DATA_WIDTH;
        end
    end

    assign wready = !wdata_vld || xfer_done;

    // == AW-Channel Buffering ===============================================
    reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0] fmc_addr;
    reg                                 fmc_addr_vld;

    always @(posedge clk) begin
        if (~rst_n) begin
            fmc_addr_vld    <= 1'b0;
            fmc_addr        <= { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        end else if (awready && awvalid) begin
            fmc_addr_vld    <= 1'b1;
            fmc_addr        <= cfg_addr_offset + awaddr;
        end else begin
            fmc_addr_vld    <= !xfer_done && fmc_addr_vld;
            if (next_elem)
                fmc_addr    <= fmc_addr + `PRGA_YAMI_FMC_DATA_BYTES;
        end
    end

    assign awready = !fmc_addr_vld || xfer_done;

    // == Address-based Demuxing =============================================
    reg [NUM_DST-1:0] dst_mask;

    always @* begin
        dst_mask = { NUM_DST {1'b0} };

        case (fmc_addr[DEMUX_ADDR_HIGH : DEMUX_ADDR_LOW])
            {%- for i in range(2 ** (module.demux_addr_high - module.demux_addr_low + 1)) %}
            {{ module.demux_addr_high - module.demux_addr_low + 1 }}'d{{ i }}: dst_mask[{{ i % module.num_dsts }}] = 1'b1;
            {%- endfor %}
        endcase
    end

    // == Egress Management ==================================================
    reg                                 fmc_vld;
    wire [NUM_DST-1:0]                  fmc_rdy, egress_done;
    reg [NUM_ELEMS_LOG2:0]              elem_cnt [NUM_DST-1:0];     // per channel
    {%- for i in range(module.num_dsts) %}

    // output channel {{ i }}
    always @(posedge clk) begin
        if (~rst_n) begin
            elem_cnt[{{ i }}]   <= { NUM_ELEMS_LOG2 {1'b0} };
        end else begin
            case ({
                dst{{ i }}_fmc_rdy && dst{{ i }}_fmc_vld
                , dst{{ i }}_mfc_rdy && dst{{ i }}_mfc_vld
            })
                2'b10:  elem_cnt[{{ i }}] <= elem_cnt[{{ i }}] + 1;
                2'b01:  elem_cnt[{{ i }}] <= elem_cnt[{{ i }}] - 1;
            endcase
        end
    end

    assign egress_done[{{ i }}] = elem_cnt[{{ i }}] == 0;
    assign fmc_rdy[{{ i }}] = dst{{ i }}_fmc_rdy;
    assign dst{{ i }}_fmc_vld = dst_mask[{{ i }}] && fmc_vld;
    assign dst{{ i }}_fmc_type = `PRGA_YAMI_REQTYPE_STORE;
    assign dst{{ i }}_fmc_addr = fmc_addr;
    assign dst{{ i }}_fmc_data = wdata_f[0+:`PRGA_YAMI_FMC_DATA_WIDTH];
    assign dst{{ i }}_fmc_size = `PRGA_YAMI_SIZE_FULL;
    assign dst{{ i }}_mfc_rdy = elem_cnt[{{ i }}] > 0;
    {%- endfor %}

    // == Request Sending ====================================================
    localparam  ST_WIDTH            = 2;
    localparam  ST_RESET            = 2'h0,
                ST_IDLE             = 2'h1,
                ST_SENDING          = 2'h2,
                ST_RECVING          = 2'h3;

    reg [ST_WIDTH-1:0]          state, state_next;
    reg [NUM_ELEMS_LOG2-1:0]    sent_cnt, sent_cnt_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            state   <= ST_RESET;
            sent_cnt <= { NUM_ELEMS_LOG2 {1'b0} };
        end else begin
            state   <= state_next;
            sent_cnt <= sent_cnt_next;
        end
    end

    always @* begin
        next_elem = 1'b0;
        xfer_done = 1'b0;
        fmc_vld = 1'b0;
        state_next = state;
        sent_cnt_next = sent_cnt;

        case (state)
            ST_RESET:   state_next = ST_IDLE;

            ST_IDLE: if (wdata_vld && fmc_addr_vld) begin
                state_next = ST_SENDING;

                // try send as well
                fmc_vld = 1'b1;
                if ( |(dst_mask & fmc_rdy) ) begin  // sent!
                    next_elem = 1'b1;
                    sent_cnt_next = 1;
                end else begin
                    sent_cnt_next = 0;
                end
            end

            ST_SENDING: begin
                fmc_vld = 1'b1;
                if ( |(dst_mask & fmc_rdy) ) begin  // sent!
                    next_elem = 1'b1;
                    sent_cnt_next = sent_cnt + 1;

                    if (sent_cnt == NUM_ELEMS - 1) begin
                        xfer_done = 1'b1;
                        state_next = ST_RECVING;
                    end
                end
            end

            ST_RECVING: if (&egress_done) begin
                state_next = ST_IDLE;
            end
        endcase
    end

    // == AXI4 Response ======================================================
    assign bresp = `PRGA_AXI4_XRESP_OKAY;

    always @(posedge clk) begin
        if (~rst_n) begin
            bvalid  <= 1'b0;
        end else if (ACK_FAST && xfer_done) begin
            bvalid  <= 1'b1;
        end else if (!ACK_FAST && state == ST_RECVING && egress_done) begin
            bvalid  <= 1'b1;
        end else if (bready) begin
            bvalid  <= 1'b0;
        end
    end

endmodule
