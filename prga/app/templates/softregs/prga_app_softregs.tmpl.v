// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps
`include "prga_app_softregs.vh"
{%- macro dwidth(name) -%} `PRGA_APP_SOFTREG_VAR_{{ name | upper }}_DATA_WIDTH {%- endmacro %}
{%- macro rstval(name) -%} `PRGA_APP_SOFTREG_VAR_{{ name | upper }}_RSTVAL {%- endmacro %}
{%- macro addr(name) -%} `PRGA_APP_SOFTREG_VAR_{{ name | upper }}_ADDR {%- endmacro %}

module prga_app_softregs (
    input wire                                      clk
    , input wire                                    rst_n

    // == Val/Rdy Interface ===================================================
    , output reg                                    softreg_req_rdy
    , input wire                                    softreg_req_val
    , input wire [`PRGA_APP_SOFTREG_ADDR_WIDTH-1:0] softreg_req_addr
    , input wire                                    softreg_req_we
    , input wire [`PRGA_APP_SOFTREG_DATA_WIDTH-1:0] softreg_req_data

    , input wire                                    softreg_resp_rdy
    , output reg                                    softreg_resp_val
    , output reg [`PRGA_APP_SOFTREG_DATA_WIDTH-1:0] softreg_resp_data

    // == Soft Register Ports =================================================
    {%- for name, r in module.softregs.regs.items() %}
        // {{ r.type_.name }} soft register: {{ name }}
        {%- if r.type_.is_const %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o

        {%- elif r.type_.is_kernel %}
    , input wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_i

        {%- elif r.type_.is_rdempty %}
    , input wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_i
    , input wire var_{{ name }}_empty
    , output wire var_{{ name }}_rd

        {%- elif r.type_.is_rdempty_la %}
    , input wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_i
    , input wire var_{{ name }}_empty
    , output wire var_{{ name }}_rd

        {%- elif r.type_.is_cbl_2stage %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o
    , input wire var_{{ name }}_ack
    , input wire var_{{ name }}_done

        {%- elif r.type_.is_vldrdy_rd %}
    , input wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_i
    , input wire var_{{ name }}_vld
    , output wire var_{{ name }}_rdy

        {%- elif r.type_.is_basic %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o

        {%- elif r.type_.is_pulse %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o

        {%- elif r.type_.is_pulse_ack %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o
    , input wire var_{{ name }}_ack

        {%- elif r.type_.is_decoupled %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o
    , input wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_i

        {%- elif r.type_.is_wrfull %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o
    , output wire var_{{ name }}_wr
    , input wire var_{{ name }}_full

        {%- elif r.type_.is_vldrdy_wr %}
    , output wire [{{ dwidth(name) }} - 1:0] var_{{ name }}_o
    , output wire var_{{ name }}_vld
    , input wire var_{{ name }}_rdy

        {%- elif not r.type_.is_reserved %}
        // Unsupported register type: {{ r.type_.name }}
        {%- endif %}
    {% endfor %}
    );

    // -----------------------------------------------------------------------
    // -- generate we/wmask --
    wire req_we;
    wire [`PRGA_APP_SOFTREG_DATA_WIDTH-1:0] req_wmask;

    assign req_we = softreg_req_we;
        assign req_wmask = { `PRGA_APP_SOFTREG_DATA_WIDTH {1'b1} };

    // -----------------------------------------------------------------------
    // -- assign internal IDs to the registers --
    {%- set num_regs = softregs.regs.values()|rejectattr("is_reserved")|length %}
    localparam  NUM_REGS        = {{ num_regs }};
    localparam  G_REGID_WIDTH   = {{ num_regs.bit_length() }};

    localparam  G_REGID_NONE    = {{ num_regs.bit_length() }}'d0;
    {%- for name, r in module.softregs.regs.items() %}
    localparam  REGID_{{ name|upper }} = {{ num_regs.bit_length() }}'d{{ loop.index }};
    {%- endfor %}

    wire [NUM_REGS:0] req_rdy, resp_vld;
    reg [NUM_REGS:0] resp_rdy, req_vld;
    wire [`PRGA_APP_SOFTREG_DATA_WIDTH-1:0] resp_data [0:NUM_REGS];

    assign req_rdy[G_REGID_NONE]    = 1'b1;
    assign resp_vld[G_REGID_NONE]   = 1'b1;
    assign resp_data[G_REGID_NONE]  = {`PRGA_APP_SOFTREG_DATA_WIDTH{1'b0}};

    // instantiate registers
    {%- for name, r in module.softregs.regs.items() %}
    // -----------------------------------------------------------------------
    // -- {{ r.type_.name }} soft register: {{ name }} --
    prga_app_softreg_{{ r.type_.name }} #(
        .DATA_WIDTH     ({{ dwidth(name) }})
        ,.RSTVAL        ({{ rstval(name) }})
    ) i_reg_{{ name }} (
        .clk            (clk)
        ,.rst_n         (rst_n)
        ,.req_rdy       (req_rdy[REGID_{{ name|upper }}])
        ,.req_vld       (req_vld[REGID_{{ name|upper }}])
        ,.req_we        (req_we)
        ,.req_wmask     (req_wmask)
        ,.req_data      (softreg_req_data)
        ,.resp_rdy      (resp_rdy[REGID_{{ name|upper }}])
        ,.resp_vld      (resp_vld[REGID_{{ name|upper }}])
        ,.resp_data     (resp_data[REGID_{{ name|upper }}][0+:{{ dwidth(name) }}])
        {%- if r.type_.is_const %}
        ,.var_o         (var_{{ name }}_o)

        {%- elif r.type_.is_kernel %}
        ,.var_i         (var_{{ name }}_i)

        {%- elif r.type_.is_rdempty %}
        ,.var_i         (var_{{ name }}_i)
        ,.var_empty     (var_{{ name }}_empty)
        ,.var_rd        (var_{{ name }}_rd)

        {%- elif r.type_.is_rdempty_la %}
        ,.var_i         (var_{{ name }}_i)
        ,.var_empty     (var_{{ name }}_empty)
        ,.var_rd        (var_{{ name }}_rd)

        {%- elif r.type_.is_cbl_2stage %}
        ,.var_o         (var_{{ name }}_o)
        ,.var_ack       (var_{{ name }}_ack)
        ,.var_done      (var_{{ name }}_done)

        {%- elif r.type_.is_vldrdy_rd %}
        ,.var_i         (var_{{ name }}_i)
        ,.var_vld       (var_{{ name }}_vld)
        ,.var_rdy       (var_{{ name }}_rdy)

        {%- elif r.type_.is_basic %}
        ,.var_o         (var_{{ name }}_o)

        {%- elif r.type_.is_pulse %}
        ,.var_o         (var_{{ name }}_o)

        {%- elif r.type_.is_pulse_ack %}
        ,.var_o         (var_{{ name }}_o)
        ,.var_ack       (var_{{ name }}_ack)

        {%- elif r.type_.is_decoupled %}
        ,.var_o         (var_{{ name }}_o)
        ,.var_i         (var_{{ name }}_i)

        {%- elif r.type_.is_wrfull %}
        ,.var_o         (var_{{ name }}_o)
        ,.var_wr        (var_{{ name }}_wr)
        ,.var_full      (var_{{ name }}_full)

        {%- elif r.type_.is_vldrdy_wr %}
        ,.var_o         (var_{{ name }}_o)
        ,.var_vld       (var_{{ name }}_vld)
        ,.var_rdy       (var_{{ name }}_rdy)

        {%- endif %}
        );

    {% if r.width < 8 * (2 ** softregs.intf.data_bytes_log2) %}
    assign resp_data[REGID_{{ name|upper }}][`PRGA_APP_SOFTREG_DATA_WIDTH-1:{{ dwidth(name) }}] =
        { (`PRGA_APP_SOFTREG_DATA_WIDTH - {{ dwidth(name) }}) {1'b0} };
    {%- endif %}

    {% endfor %}

    // -----------------------------------------------------------------------
    // -- pending response queue --
    reg prq_rd;
    wire prq_full, prq_empty;
    reg [PRQ_DEPTH_LOG2:0] wptr, rptr;
    reg [G_REGID_WIDTH-1:0] prq [0:(1<<PRQ_DEPTH_LOG2)-1];
    reg [G_REGID_WIDTH-1:0] req_regid, resp_regid;

    always @(posedge clk) begin
        if (~rst_n) begin
            wptr <= { (PRQ_DEPTH_LOG2+1) {1'b0} };
            rptr <= { (PRQ_DEPTH_LOG2+1) {1'b0} };
            resp_regid <= { (REGID_WIDTH+1) {1'b0} };
        end else begin
            if (prq_rd && !prq_empty) begin
                rptr <= rptr + 1;
                resp_regid <= prq[rptr];
            end

            if (softreg_req_rdy && softreg_req_val && !prq_full) begin
                prq[wptr] <= req_regid;
                wptr <= wptr + 1;
            end
        end
    end

    assign prq_empty = wptr == rptr;
    assign prq_full = wptr == {~rptr[PRQ_DEPTH_LOG2], rptr[0+:PRQ_DEPTH_LOG2]};

    // -----------------------------------------------------------------------
    // -- request distribution --
    always @* begin
        req_regid = G_REGID_NONE;

        case (softreg_req_addr)
            {%- for r in softregs.regs.values()|rejectattr("is_reserved") %}
            {{ addr(r.name) }}: begin
                req_regid = REGID_{{ r.name|upper }};
            end
            {%- endfor %}
        endcase
    end

    always @* begin
        req_vld = { (NUM_REGS + 1) {1'b0} };

        if (softreg_req_val && !prq_full)
            req_vld[req_regid] = 1'b1;
    end

    always @* begin
        softreg_req_rdy = 1'b0;

        if (!prq_full)
            softreg_req_rdy = req_rdy[req_regid];
    end

    // -----------------------------------------------------------------------
    // -- response collection --
    reg resp_regid_vld;

    always @(posedge clk) begin
        if (~rst_n) begin
            resp_regid_vld <= 1'b0;
        end else if (prq_rd && !prq_empty) begin
            resp_regid_vld <= 1'b1;
        end else if (softreg_resp_val && softreg_resp_rdy) begin
            resp_regid_vld <= 1'b0;
        end
    end

    always @* begin
        softreg_resp_val = 1'b0;
        softreg_resp_data = { `PRGA_APP_SOFTREG_DATA_WIDTH {1'b0} };
        resp_rdy = { (NUM_REGS + 1) {1'b0} };

        if (resp_regid_vld) begin
            softreg_resp_val = resp_vld[resp_regid];
            softreg_resp_data = resp_data[resp_regid];
            resp_rdy[resp_regid] = softreg_resp_rdy;
        end
    end

    always @* begin
        prq_rd = !resp_regid_vld || (softreg_resp_val && softreg_resp_rdy);
    end

endmodule
