// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps
`include "prga_utils.vh"
`include "prga_app_memintf.vh"

/*
* Store Channel.
*
*   Receive data through the kernel val/rdy interface, then perform stores
*   through the memory-side val/rdy interface.
*
*   Refer to prga_app_ldchan.v for more information.
*
*   TODO:
*       - Add support for streaming mode
*
*/

module prga_app_stchan #(
    parameter   KERNEL_DATA_BYTES_LOG2      =   2   // 4B by default
    , parameter OBJ_SIZE                    =   0   // actual size = ((OBJ_SIZE + 1) << KERNEL_DATA_BYTES_LOG2) bytes
) (
    input wire                                                  clk
    , input wire                                                rst_n

    // == Kernel-side Interface ===============================================
    , output reg                                                kernel_rdy
    , input wire                                                kernel_val
    , input wire [(1 << (KERNEL_DATA_BYTES_LOG2+3))-1:0]        kernel_data

    // == Memory-side Val/Rdy Interface =======================================
    , input wire                                                streq_rdy
    , output reg                                                streq_val
    , output wire [`PRGA_APP_MEMINTF_SIZE_WIDTH-1:0]            streq_size
    , output reg [`PRGA_APP_MEMINTF_ADDR_WIDTH-1:0]             streq_addr
    , output reg [`PRGA_APP_MEMINTF_DATA_WIDTH-1:0]             streq_data

    , input wire                                                stresp_val
    , output reg                                                stresp_rdy

    // == Memory Transaction Configurations ===================================

    // Transaction hand-shake
    , input wire                                                trx_start
    , output wire                                               trx_busy

    // Base address of the memory object. Must be natually aligned
    , input wire [`PRGA_APP_MEMINTF_ADDR_WIDTH-1:0]             obj_base_addr
    );

    // ========================================================================
    // -- Local Parameters ----------------------------------------------------
    // ========================================================================

    localparam  OBJ_SIZE_LOG2       = (OBJ_SIZE == 0) ? 0 : `PRGA_CLOG2(OBJ_SIZE + 1);

    localparam  KERNEL_DATA_BYTES   = 1 << KERNEL_DATA_BYTES_LOG2;
    localparam  KERNEL_DATA_WIDTH   = KERNEL_DATA_BYTES * 8;

    localparam  STORES_PER_KUNIT_LOG2   = (KERNEL_DATA_BYTES_LOG2 > `PRGA_APP_MEMINTF_DATA_BYTES_LOG2) ?
                                          (KERNEL_DATA_BYTES_LOG2 - `PRGA_APP_MEMINTF_DATA_BYTES_LOG2) : 0;
    localparam  STORES_PER_KUNIT        = 1 << STORES_PER_KUNIT_LOG2;

    localparam  MAX_KUNITS_PER_STORE_LOG2   = (`PRGA_APP_MEMINTF_DATA_BYTES_LOG2 > KERNEL_DATA_BYTES_LOG2) ?
                                              (`PRGA_APP_MEMINTF_DATA_BYTES_LOG2 - KERNEL_DATA_BYTES_LOG2) : 0;
    localparam  MAX_KUNITS_PER_STORE        = 1 << MAX_KUNITS_PER_STORE_LOG2;

    // ========================================================================
    // -- Request Channel -----------------------------------------------------
    // ========================================================================

    reg req_active;     // 2-state FSM

    generate if (OBJ_SIZE == 0 && STORES_PER_KUNIT_LOG2 == 0) begin
        // Simplest case: one store per memory object

        always @(posedge clk) begin
            if (~rst_n) begin
                req_active <= 1'b0;
                streq_addr <= { `PRGA_APP_MEMINTF_ADDR_WIDTH {1'b0} };
            end else if (trx_start && !trx_busy) begin
                req_active <= 1'b1;
                streq_addr <= obj_base_addr;
            end else if (stresp_val && stresp_rdy) begin
                req_active <= 1'b0;
            end
        end

        always @* begin
            kernel_rdy = streq_rdy && req_active;
            streq_val = kernel_val && req_active;
            streq_data = { MAX_KUNITS_PER_STORE {kernel_data} };
        end

    end else if (STORES_PER_KUNIT_LOG2 == 0) begin
        // One store per kunit, but multiple kunits per memory object

        reg [OBJ_SIZE_LOG2-1:0] req_kunit_cnt;

        always @(posedge clk) begin
            if (~rst_n) begin
                req_active <= 1'b0;
                streq_addr <= { `PRGA_APP_MEMINTF_ADDR_WIDTH {1'b0} };
                req_kunit_cnt <= { OBJ_SIZE_LOG2 {1'b0} };
            end else if (trx_start && !trx_busy) begin
                req_active <= 1'b1;
                streq_addr <= obj_base_addr;
                req_kunit_cnt <= { OBJ_SIZE_LOG2 {1'b0} };
            end else if (stresp_val && stresp_rdy) begin
                req_active <= req_kunit_cnt < OBJ_SIZE;
                streq_addr <= streq_addr + KERNEL_DATA_BYTES;
                req_kunit_cnt <= req_kunit_cnt + 1;
            end
        end

        always @* begin
            kernel_rdy = streq_rdy && req_active;
            streq_val = kernel_val && req_active;
            streq_data = { MAX_KUNITS_PER_STORE {kernel_data} };
        end

    end else begin
        // We need to slice up kunits

        reg [OBJ_SIZE_LOG2-1:0]         req_kunit_cnt;
        reg [STORES_PER_KUNIT_LOG2-1:0] req_store_cnt;


        // slicing
        reg [KERNEL_DATA_WIDTH-1:0]             kernel_data_f;
        wire [`PRGA_APP_MEMINTF_DATA_WIDTH-1:0] req_kunits  [0:STORES_PER_KUNIT-1];

        genvar req_kunit_i;
        for (req_kunit_i = 0; req_kunit_i < STORES_PER_KUNIT_LOG2; req_kunit_i = req_kunit_i + 1) begin
            assign req_kunits[req_kunit_i] = kernel_data_f[`PRGA_APP_MEMINTF_DATA_WIDTH * req_kunit_i +: `PRGA_APP_MEMINTF_DATA_WIDTH];
        end

        always @(posedge clk) begin
            if (~rst_n) begin
                req_active <= 1'b0;
                streq_addr <= { `PRGA_APP_MEMINTF_ADDR_WIDTH {1'b0} };
                req_kunit_cnt <= { OBJ_SIZE_LOG2 {1'b0} };
                req_store_cnt <= { STORES_PER_KUNIT_LOG2 {1'b0} };
            end else if (trx_start && !trx_busy) begin
                req_active <= 1'b1;
                streq_addr <= obj_base_addr;
                req_kunit_cnt <= { OBJ_SIZE_LOG2 {1'b0} };
                req_store_cnt <= { STORES_PER_KUNIT_LOG2 {1'b0} };
            end else if (stresp_val && stresp_rdy) begin
                req_active <= req_kunit_cnt < OBJ_SIZE && ~&req_store_cnt;
                streq_addr <= streq_addr + `PRGA_APP_MEMINTF_DATA_BYTES;
                req_kunit_cnt <= req_kunit_cnt + (&req_store_cnt ? 1 : 0);
                req_store_cnt <= req_store_cnt + 1;
            end
        end

        always @(posedge clk) begin
            if (~rst_n) begin
                streq_val <= 1'b0;
                kernel_data_f <= { KERNEL_DATA_WIDTH {1'b0} };
            end else if (kernel_val && kernel_rdy) begin
                streq_val <= 1'b1;
                kernel_data_f <= kernel_data;
            end else if (streq_rdy && &req_store_cnt) begin
                streq_val <= 1'b0;
            end
        end

        always @* begin
            kernel_rdy = req_active && (~streq_val || (&req_store_cnt && streq_rdy && req_kunit_cnt < OBJ_SIZE));
            streq_data = req_kunits[req_store_cnt];
        end

    end endgenerate

    if (KERNEL_DATA_BYTES_LOG2 == 0) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_1B;
    end else if (KERNEL_DATA_BYTES_LOG2 == 1) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_2B;
    end else if (KERNEL_DATA_BYTES_LOG2 == 2) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_4B;
`ifdef PRGA_APP_MEMINTF_SIZE_8B
    end else if (KERNEL_DATA_BYTES_LOG2 == 3) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_8B;
`ifdef PRGA_APP_MEMINTF_SIZE_16B
    end else if (KERNEL_DATA_BYTES_LOG2 == 4) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_16B;
`ifdef PRGA_APP_MEMINTF_SIZE_32B
    end else if (KERNEL_DATA_BYTES_LOG2 == 5) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_32B;
`ifdef PRGA_APP_MEMINTF_SIZE_64B
    end else if (KERNEL_DATA_BYTES_LOG2 == 6) begin
        assign streq_size = `PRGA_APP_MEMINTF_SIZE_64B;
`endif /* `ifdef PRGA_APP_MEMINTF_SIZE_64B */
`endif /* `ifdef PRGA_APP_MEMINTF_SIZE_32B */
`endif /* `ifdef PRGA_APP_MEMINTF_SIZE_16B */
`endif /* `ifdef PRGA_APP_MEMINTF_SIZE_8B */
    end

    // ========================================================================
    // -- Response Channel ----------------------------------------------------
    // ========================================================================

    reg resp_active;     // 2-state FSM

    generate if (OBJ_SIZE == 0 && STORES_PER_KUNIT_LOG2 == 0) begin
        // expecting only one response

        always @(posedge clk) begin
            if (~rst_n) begin
                resp_active <= 1'b0;
            end else if (trx_start && ~trx_busy) begin
                resp_active <= 1'b1;
            end else if (stresp_rdy && stresp_val) begin
                resp_active <= 1'b0;
            end
        end

    end else begin
        // expecting multiple responses

        reg [OBJ_SIZE_LOG2 + STORES_PER_KUNIT_LOG2 - 1:0]   resp_store_cnt;

        always @(posedge clk) begin
            if (~rst_n) begin
                resp_active <= 1'b0;
                resp_store_cnt <= { (OBJ_SIZE_LOG2 + STORES_PER_KUNIT_LOG2) {1'b0} };
            end else if (trx_start && ~trx_busy) begin
                resp_active <= 1'b1;
                resp_store_cnt <= { (OBJ_SIZE_LOG2 + STORES_PER_KUNIT_LOG2) {1'b0} };
            end else if (stresp_rdy && stresp_val) begin
                resp_active <= resp_store_cnt < ((OBJ_SIZE + 1) << STORES_PER_KUNIT_LOG2) - 1;
                resp_store_cnt <= resp_store_cnt + 1;
            end
        end

    end

    always @* begin
        stresp_rdy = resp_active;
    end

    // ========================================================================
    // -- Transaction Hand-Shake ----------------------------------------------
    // ========================================================================

    assign trx_busy = resp_active;

endmodule
