// Automatically generated by PRGA's RTL generator

/*
* RXI plain hardware-sync'ed register (HSR).
*/

`include "prga_rxi.vh"
`default_nettype none

module prga_rxi_fe_phsr (
    // -- System Ctrl --------------------------------------------------------
    input wire                                          clk
    , input wire                                        rst_n

    // -- System-side Interface ----------------------------------------------
    //  always ready :)
    , input wire                                        s_req_vld
    , input wire [`PRGA_RXI_HSR_PLAIN_ID_WIDTH-1:0]     s_req_id
    , input wire [`PRGA_RXI_DATA_BYTES-1:0]             s_req_strb
    , input wire [`PRGA_RXI_DATA_WIDTH-1:0]             s_req_din
    , output reg [`PRGA_RXI_DATA_WIDTH-1:0]             s_resp_dout

    // -- application-initiated sync interface -------------------------------
    , input wire                                        a_sync
    , input wire [`PRGA_RXI_HSR_PLAIN_ID_WIDTH-1:0]     a_id
    , input wire [`PRGA_RXI_DATA_WIDTH-1:0]             a_data

    // -- application-targeted sync interface --------------------------------
    , input wire                                        m_rdy
    , output wire [`PRGA_RXI_HSR_PLAIN_ID_WIDTH-1:0]    m_id
    , output reg                                        m_vld
    , output reg [`PRGA_RXI_DATA_WIDTH-1:0]             m_data
    );

    reg [`PRGA_RXI_NUM_HSR_PLAINS-1:0]  unsynced;
    wire [`PRGA_RXI_DATA_WIDTH-1:0]     data [0:`PRGA_RXI_NUM_HSR_PLAINS-1];

    genvar gv_reg;
    generate
        for (gv_reg = 0; gv_reg < `PRGA_RXI_NUM_HSR_PLAINS; gv_reg = gv_reg + 1) begin: g_reg

            always @(posedge clk) begin
                if (~rst_n) begin
                    unsynced[gv_reg]    <= 1'b0;
                end else if (m_vld && m_rdy && m_id == gv_reg) begin
                    unsynced[gv_reg]    <= 1'b0;
                end else if (s_req_vld && s_req_strb && s_req_id == gv_reg) begin
                    unsynced[gv_reg]    <= 1'b1;
                end
            end

            wire                                wr;
            wire [`PRGA_RXI_DATA_BYTES-1:0]     mask;
            wire [`PRGA_RXI_DATA_WIDTH-1:0]     din;

            assign wr = (a_sync && a_id == gv_reg)
                        || (s_req_vld && s_req_id == gv_reg);
            assign mask = (a_sync && a_id == gv_reg) ?
                          { `PRGA_RXI_DATA_BYTES {1'b1} } :
                          s_req_strb;
            assign din = (a_sync && a_id == gv_reg) ? a_data : s_req_din;

            prga_byteaddressable_reg #(
                .NUM_BYTES  (`PRGA_RXI_DATA_BYTES)
            ) i_reg (
                .clk        (clk)
                ,.rst       (~rst_n)
                ,.wr        (wr)
                ,.mask      (mask)
                ,.din       (din)
                ,.dout      (data[gv_reg])
                );
        end
    endgenerate

    // -- Arbitration --------------------------------------------------------
    prga_arb_robinfair #(
        .INDEX_WIDTH    (`PRGA_RXI_HSR_PLAIN_ID_WIDTH)
    ) i_arb (
        .clk            (clk)
        ,.rst_n         (rst_n)
        ,.ce            (m_rdy && m_vld)
        ,.candidates    (unsynced)
        ,.current       (m_id)
        );

    always @* begin
        s_resp_dout = data[s_req_id];
        m_vld = unsynced[m_id];
        m_data = data[m_id];
    end

endmodule
