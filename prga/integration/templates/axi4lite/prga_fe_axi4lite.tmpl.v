// Automatically generated by PRGA's RTL generator
`include "prga_system.vh"

module prga_fe_axi4lite #(
    parameter   NO_INTF_BUFFER = 0
) (
    // system ctrl signals
    input wire                                  clk,
    input wire                                  rst_n,

    // == AXI4-Lite Interface ================================================
    // write address channel
    input wire                                  m_AWVALID,
    output wire                                 m_AWREADY,
    input wire [`PRGA_CREG_ADDR_WIDTH - 1:0]    m_AWADDR,
    input wire [2:0]                            m_AWPROT,

    // write data channel
    input wire                                  m_WVALID,
    output wire                                 m_WREADY,
    input wire [`PRGA_CREG_DATA_WIDTH - 1:0]    m_WDATA,
    input wire [`PRGA_CREG_DATA_BYTES - 1:0]    m_WSTRB,

    // write response channel
    output wire                                 m_BVALID,
    input wire                                  m_BREADY,
    output wire [1:0]                           m_BRESP,

    // read address channel
    input wire                                  m_ARVALID,
    output wire                                 m_ARREADY,
    input wire [`PRGA_CREG_ADDR_WIDTH - 1:0]    m_ARADDR,
    input wire [2:0]                            m_ARPROT,

    // read data channel
    output wire                                 m_RVALID,
    input wire                                  m_RREADY,
    output wire [`PRGA_CREG_DATA_WIDTH - 1:0]   m_RDATA,
    output wire [1:0]                           m_RRESP,

    // == Generic CREG/UREG Interface ========================================
    input wire                                  creg_req_rdy,
    output wire                                 creg_req_val,
    output wire [`PRGA_CREG_ADDR_WIDTH-1:0]     creg_req_addr,
    output wire [`PRGA_CREG_DATA_BYTES-1:0]     creg_req_strb,
    output wire [`PRGA_CREG_DATA_WIDTH-1:0]     creg_req_data,

    output wire                                 creg_resp_rdy,
    input wire                                  creg_resp_val,
    input wire [`PRGA_CREG_DATA_WIDTH-1:0]      creg_resp_data
    );

    // == Buffer Input/Output ==
    wire awvalid, wvalid, bready, arvalid, rready, creq_rdy, cresp_val;
    reg awready, wready, bvalid, arready, rvalid, creq_val, cresp_rdy;
    wire [`PRGA_CREG_ADDR_WIDTH-1:0] awaddr, araddr;
    reg [`PRGA_CREG_ADDR_WIDTH-1:0] creq_addr;
    wire [`PRGA_CREG_DATA_WIDTH-1:0] wdata, cresp_data;
    wire [`PRGA_CREG_DATA_BYTES-1:0] wstrb;
    reg [`PRGA_CREG_DATA_BYTES-1:0] creq_strb;

    prga_valrdy_buf #(
        .DECOUPLED          (1)
        ,.DATA_WIDTH        (`PRGA_CREG_ADDR_WIDTH)
    ) i_awaddr (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (m_AWREADY)
        ,.val_i             (m_AWVALID)
        ,.data_i            (m_AWADDR)
        ,.rdy_i             (awready)
        ,.val_o             (awvalid)
        ,.data_o            (awaddr)
        );

    prga_valrdy_buf #(
        .DECOUPLED          (1)
        ,.DATA_WIDTH        (`PRGA_CREG_DATA_WIDTH + `PRGA_CREG_DATA_BYTES)
    ) i_wdata (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (m_WREADY)
        ,.val_i             (m_WVALID)
        ,.data_i            ({m_WSTRB, m_WDATA})
        ,.rdy_i             (wready)
        ,.val_o             (wvalid)
        ,.data_o            ({wstrb, wdata})
        );

    prga_valrdy_buf #(
        .DECOUPLED          (1)
        ,.DATA_WIDTH        (`PRGA_CREG_ADDR_WIDTH)
    ) i_araddr (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (m_ARREADY)
        ,.val_i             (m_ARVALID)
        ,.data_i            (m_ARADDR)
        ,.rdy_i             (arready)
        ,.val_o             (arvalid)
        ,.data_o            (araddr)
        );

    prga_valrdy_buf #(
        .DECOUPLED          (1)
        ,.DATA_WIDTH        (2)
    ) i_bresp (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (bready)
        ,.val_i             (bvalid)
        ,.data_i            (2'b0)
        ,.rdy_i             (m_BREADY)
        ,.val_o             (m_BVALID)
        ,.data_o            (m_BRESP)
        );

    prga_valrdy_buf #(
        .DECOUPLED          (1)
        ,.DATA_WIDTH        (`PRGA_CREG_DATA_WIDTH + 2)
    ) i_rresp (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (rready)
        ,.val_i             (rvalid)
        ,.data_i            ({cresp_data, 2'b0})
        ,.rdy_i             (m_RREADY)
        ,.val_o             (m_RVALID)
        ,.data_o            ({m_RDATA, m_RRESP})
        );

    prga_valrdy_buf #(
        .REGISTERED         (0)
        ,.DATA_WIDTH        (`PRGA_CREG_ADDR_WIDTH + `PRGA_CREG_DATA_WIDTH + `PRGA_CREG_DATA_BYTES)
    ) i_creq (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (creq_rdy)
        ,.val_i             (creq_val)
        ,.data_i            ({creq_addr, wdata, creq_strb})
        ,.rdy_i             (creg_req_rdy)
        ,.val_o             (creg_req_val)
        ,.data_o            ({creg_req_addr, creg_req_data, creg_req_strb})
        );

    prga_valrdy_buf #(
        .REGISTERED         (0)
        ,.DATA_WIDTH        (`PRGA_CREG_DATA_WIDTH)
    ) i_cresp (
        .clk                (clk)
        ,.rst               (~rst_n)
        ,.rdy_o             (creg_resp_rdy)
        ,.val_i             (creg_resp_val)
        ,.data_i            (creg_resp_data)
        ,.rdy_i             (cresp_rdy)
        ,.val_o             (cresp_val)
        ,.data_o            (cresp_data)
        );

    // == Token FIFO ==
    localparam  TOKEN_WIDTH = 1;
    localparam  TOKEN_RD    = 1'b0,
                TOKEN_WR    = 1'b1;

    wire i_tokenq_full, i_tokenq_empty;
    reg i_tokenq_wr, i_tokenq_rd;
    wire [TOKEN_WIDTH-1:0] i_tokenq_dout;
    reg [TOKEN_WIDTH-1:0] i_tokenq_din;

    prga_fifo #(
        .DATA_WIDTH                     (TOKEN_WIDTH)
        ,.DEPTH_LOG2                    (6)
        ,.LOOKAHEAD                     (1)
    ) i_tokenq (
        .clk                            (clk)
        ,.rst                           (~rst_n)
        ,.full                          (i_tokenq_full)
        ,.wr                            (i_tokenq_wr)
        ,.din                           (i_tokenq_din)
        ,.empty                         (i_tokenq_empty)
        ,.rd                            (i_tokenq_rd)
        ,.dout                          (i_tokenq_dout)
        );

    // == Arbitration ==
    reg [TOKEN_WIDTH-1:0]   arb_next, arb_f;

    always @(posedge clk) begin
        if (~rst_n) begin
            arb_f   <= TOKEN_RD;
        end else begin
            arb_f   <= arb_next;
        end
    end

    always @* begin
        arb_next = arb_f;

        awready = 1'b0;
        wready = 1'b0;
        arready = 1'b0;
        i_tokenq_wr = 1'b0;
        i_tokenq_din = TOKEN_RD;
        creq_val = 1'b0;
        creq_addr = araddr;
        creq_strb = {`PRGA_CREG_DATA_BYTES {1'b0} };

        case ({awvalid && wvalid, arvalid, arb_f})
            {2'b10, TOKEN_RD},
            {2'b10, TOKEN_WR},
            {2'b11, TOKEN_RD}: begin
                i_tokenq_wr = creq_rdy;
                creq_val = ~i_tokenq_full;

                i_tokenq_din = TOKEN_WR;
                creq_addr = awaddr;
                creq_strb = wstrb;

                if (~i_tokenq_full && creq_rdy) begin
                    awready = 1'b1;
                    wready = 1'b1;
                    arb_next = TOKEN_WR;
                end
            end
            {2'b01, TOKEN_RD},
            {2'b01, TOKEN_WR},
            {2'b11, TOKEN_WR}: begin
                i_tokenq_wr = creq_rdy;
                creq_val = ~i_tokenq_full;

                if (~i_tokenq_full && creq_rdy) begin
                    arready = 1'b1;
                    arb_next = TOKEN_RD;
                end
            end
        endcase

        bvalid = 1'b0;
        rvalid = 1'b0;
        i_tokenq_rd = 1'b0;
        cresp_rdy = 1'b0;

        if (~i_tokenq_empty) begin
            case (i_tokenq_dout)
                TOKEN_RD: begin
                    rvalid = cresp_val;
                    cresp_rdy = rready;

                    i_tokenq_rd = cresp_val && rready;
                end
                TOKEN_WR: begin
                    bvalid = cresp_val;
                    cresp_rdy = bready;

                    i_tokenq_rd = cresp_val && bready;
                end
            endcase
        end
    end

endmodule
