// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps

/*
* Memory Protection Layer in fabric clock domain.
*/

`include "prga_utils.vh"
`include "prga_yami.vh"
`default_nettype none

module prga_yami_mprot_fbrc #(
    parameter   DEFAULT_FEATURES    = `PRGA_YAMI_CREG_FEATURE_LOAD | `PRGA_YAMI_CREG_FEATURE_STORE
    , parameter DEFAULT_TIMEOUT     = 32'd1000
) (
    // -- Interface Ctrl -----------------------------------------------------
    input wire                                          clk
    , input wire                                        rst_n
    , output wire                                       err_o       // error signal out
    , input wire                                        shutdown_i  // quick shutdown

    // -- FIFO ---------------------------------------------------------------
    , input wire                                        fifo_fmc_full
    , output reg                                        fifo_fmc_wr
    , output reg [`PRGA_YAMI_FMC_FIFO_ELEM_WIDTH-1:0]   fifo_fmc_data

    , output reg                                        fifo_mfc_rd
    , input wire                                        fifo_mfc_empty
    , input wire [`PRGA_YAMI_MFC_FIFO_ELEM_WIDTH-1:0]   fifo_mfc_data

    // -- FMC (fabric-memory channel) ----------------------------------------
    , output reg                                        fmc_rdy
    , input wire                                        fmc_vld
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]         fmc_type
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            fmc_size
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        fmc_addr
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]        fmc_data
    , input wire                                        fmc_parity

    // -- MFC (memory-fabric channel) ----------------------------------------
    , input wire                                        mfc_rdy
    , output reg                                        mfc_vld
    , output wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]       mfc_type
    , output wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]       mfc_addr
    , output wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]       mfc_data
    );

    // =======================================================================
    // == Core Status ========================================================
    // =======================================================================
    reg [`PRGA_YAMI_CREG_STATUS_WIDTH-1:0]  status;
    wire                                    creg_activate, creg_deactivate;
    reg                                     event_error;

    always @(posedge clk) begin
        if (~rst_n)
            status          <= `PRGA_YAMI_CREG_STATUS_RESET

        else 
            case (status)
                `PRGA_YAMI_CREG_STATUS_RESET:
                    status  <= `PRGA_YAMI_CREG_STATUS_INACTIVE;

                `PRGA_YAMI_CREG_STATUS_INACTIVE,
                `PRGA_YAMI_CREG_STATUS_ERROR:
                    status  <= creg_activate ? `PRGA_YAMI_CREG_STATUS_ACTIVE : status;

                `PRGA_YAMI_CREG_STATUS_ACTIVE:
                    status  <= event_error ? `PRGA_YAMI_CREG_STATUS_ERROR :
                               creg_deactivate || shutdown_i ? `PRGA_YAMI_CREG_STATUS_INACTIVE : status;
            endcase
    end

    wire yami_active;
    assign yami_active = status == `PRGA_YAMI_CREG_STATUS_ACTIVE;
    assign err_o = status == `PRGA_YAMI_CREG_STATUS_ERROR;

    // =======================================================================
    // == Ctrl Registers =====================================================
    // =======================================================================
    reg                                     creg_we;
    wire [`PRGA_YAMI_CREG_ADDR_WIDTH-1:0]   creg_addr;
    wire [`PRGA_YAMI_CREG_DATA_WIDTH-1:0]   creg_data;

    assign creg_addr = fifo_mfc_data[`PRGA_YAMI_MFC_FIFO_CREG_ADDR_INDEX];
    assign creg_data = fifo_mfc_data[`PRGA_YAMI_MFC_FIFO_CREG_DATA_INDEX];

    // -- status --
    assign creg_activate   = creg_we && creg_addr == `PRGA_YAMI_CREG_ADDR_STATUS && |creg_data;
    assign creg_deactivate = creg_we && creg_addr == `PRGA_YAMI_CREG_ADDR_STATUS && ~|creg_data;

    // -- features --
    reg [`PRGA_YAMI_CREG_FEATURE_WIDTH-1:0] creg_features;
    always @(posedge clk) begin
        if (~rst_n)
            creg_features   <= DEFAULT_FEATURES;
        else if (creg_we && creg_addr == `PRGA_YAMI_CREG_ADDR_FEATURES)
            creg_features   <= creg_data[0 +: `PRGA_YAMI_CREG_FEATURE_WIDTH];
    end

    // -- timeout --
    reg [`PRGA_YAMI_CREG_DATA_WIDTH-1:0]    creg_timeout;
    always @(posedge clk) begin
        if (~rst_n)
            creg_timeout    <= DEFAULT_TIMEOUT;
        else if (creg_we && creg_addr == `PRGA_YAMI_CREG_ADDR_TIMEOUT)
            creg_timeout    <= creg_data;
    end

    // -- error message --
    reg [`PRGA_YAMI_CREG_DATA_WIDTH-1:0]    creg_errcode, creg_errcode_next;
    always @(posedge clk) begin
        if (~rst_n)
            creg_errcode    <= { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };
        else if (event_error)
            creg_errcode    <= creg_errcode_next;
        else if (creg_activate)
            creg_errcode    <= { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };
    end

    // =======================================================================
    // == MFC channel ========================================================
    // =======================================================================

    // -- Decode MFC FIFO ----------------------------------------------------
    assign mfc_type = fifo_mfc_data[`PRGA_YAMI_MFC_FIFO_RESPTYPE_INDEX];
    assign mfc_addr = fifo_mfc_data[`PRGA_YAMI_MFC_FIFO_ADDR_INDEX];
    assign mfc_data = fifo_mfc_data[`PRGA_YAMI_MFC_FIFO_DATA_INDEX];

    // -- MFC Timer ----------------------------------------------------------
    reg                                     mfc_timeout;
    reg [`PRGA_YAMI_CREG_DATA_WIDTH-1:0]    mfc_timer;

    always @(posedge clk) begin
        if (~rst_n) begin
            mfc_timeout <= 1'b0;
        end else if (!yami_active) begin
            mfc_timeout <= 1'b0;
        end else begin
            mfc_timeout <= mfc_timeout || mfc_timer == creg_timeout;
        end
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            mfc_timer   <= { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };
        end else if (!yami_active || mfc_timeout || mfc_rdy) begin
            mfc_timer   <= { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };
        end else if (mfc_vld) begin
            mfc_timer   <= mfc_timer + 1;
        end
    end

    // -- Core Logic ---------------------------------------------------------
    reg                                     fmc_creg_vld;
    reg [`PRGA_YAMI_CREG_DATA_WIDTH-1:0]    fmc_creg_data;

    // tasks
    task automatic process_mfc;
        input feature;
        begin
            fifo_mfc_rd = !yami_active || !feature || mfc_rdy;
            mfc_vld = yami_active && feature && !fifo_mfc_empty;
        end
    endtask

    always @* begin
        fifo_mfc_rd = 1'b0;
        mfc_vld = 1'b0;
        creg_we = 1'b0;
        fmc_creg_vld = 1'b0;
        fmc_creg_data = { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };

        case (mfc_type)
            `PRGA_YAMI_RESPTYPE_CREG_LOAD,
            `PRGA_YAMI_RESPTYPE_CREG_STORE: begin
                fifo_mfc_rd = !fifo_fmc_full;
                creg_we = !fifo_mfc_empty && mfc_type == `PRGA_YAMI_RESPTYPE_CREG_STORE && !fifo_fmc_full;
                fmc_creg_vld = !fifo_mfc_empty;

                case (creg_addr)
                    `PRGA_YAMI_CREG_ADDR_STATUS:
                        fmc_creg_data[0 +: `PRGA_YAMI_CREG_STATUS_WIDTH] = status;

                    `PRGA_YAMI_CREG_ADDR_FEATURES:
                        fmc_creg_data[0 +: `PRGA_YAMI_CREG_FEATURE_WIDTH] = creg_features;

                    `PRGA_YAMI_CREG_ADDR_TIMEOUT:
                        fmc_creg_data = creg_timeout;

                    `PRGA_YAMI_CREG_ADDR_ERRCODE:
                        fmc_creg_data = creg_errcode;
                endcase
            end

            `PRGA_YAMI_RESPTYPE_LOAD_ACK:
                process_mfc(
                    creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_LOAD]
                    );

            `PRGA_YAMI_RESPTYPE_STORE_ACK:
                process_mfc(
                    creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_STORE]
                    );

            `PRGA_YAMI_RESPTYPE_CACHE_INV:
                process_mfc(
                    creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_LOAD]
                    && creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_L1CACHE]
                    );

            `PRGA_YAMI_RESPTYPE_AMO_ACK:
                process_mfc(
                    creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_LOAD]
                    && creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_STORE]
                    && creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_NC]
                    && creg_features[`PRGA_YAMI_CREG_FEATURE_BIT_AMO]
                    );
        endcase
    end

    // =======================================================================
    // == FMC channel ========================================================
    // =======================================================================

    // -- FMC Parities -------------------------------------------------------
    wire   fmc_parity_fail;
    assign fmc_parity_fail = ^{fmc_type, fmc_size, fmc_addr, fmc_data, fmc_parity};

    // -- FMC required features ----------------------------------------------
    reg [`PRGA_YAMI_CREG_FEATURE_WIDTH-1:0]     missing_features;

    always @* begin
        missing_features = { `PRGA_YAMI_CREG_FEATURE_WIDTH {1'b0} };

        // calculate required features first
        case (fmc_type)
            `PRGA_YAMI_REQTYPE_LOAD: begin
                missing_features = missing_features
                                    | `PRGA_YAMI_CREG_FEATURE_LOAD;

                if (fmc_size == `PRGA_YAMI_SIZE_CACHELINE)
                    missing_features = missing_features
                                       | `PRGA_YAMI_CREG_FEATURE_L1CACHE;
            end

            `PRGA_YAMI_REQTYPE_LOAD_NC:
                missing_features = missing_features
                                    | `PRGA_YAMI_CREG_FEATURE_LOAD
                                    | `PRGA_YAMI_CREG_FEATURE_NC;

            `PRGA_YAMI_REQTYPE_STORE:
                missing_features = missing_features
                                    | `PRGA_YAMI_CREG_FEATURE_STORE;

            `PRGA_YAMI_REQTYPE_STORE_NC:
                missing_features = missing_features
                                    | `PRGA_YAMI_CREG_FEATURE_STORE
                                    | `PRGA_YAMI_CREG_FEATURE_NC;

            `PRGA_YAMI_REQTYPE_AMO_LR,
            `PRGA_YAMI_REQTYPE_AMO_SC,
            `PRGA_YAMI_REQTYPE_AMO_SWAP,
            `PRGA_YAMI_REQTYPE_AMO_ADD,
            `PRGA_YAMI_REQTYPE_AMO_AND,
            `PRGA_YAMI_REQTYPE_AMO_OR,
            `PRGA_YAMI_REQTYPE_AMO_XOR,
            `PRGA_YAMI_REQTYPE_AMO_MAX,
            `PRGA_YAMI_REQTYPE_AMO_MAXU,
            `PRGA_YAMI_REQTYPE_AMO_MIN,
            `PRGA_YAMI_REQTYPE_AMO_MINU,
            `PRGA_YAMI_REQTYPE_AMO_CAS1,
            `PRGA_YAMI_REQTYPE_AMO_CAS2:
                missing_features = missing_features
                                    | `PRGA_YAMI_CREG_FEATURE_LOAD
                                    | `PRGA_YAMI_CREG_FEATURE_STORE
                                    | `PRGA_YAMI_CREG_FEATURE_NC
                                    | `PRGA_YAMI_CREG_FEATURE_AMO;
        endcase

        if (fmc_size != `PRGA_YAMI_SIZE_FULL)
            missing_features = missing_features | `PRGA_YAMI_CREG_FEATURE_SUBWORD;

        // check which required features are missing
        missing_features = missing_features & ~creg_features;
    end

    // -- FMC request "full" sizes -------------------------------------------
    localparam  CACHELINE_SIZE  = `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                                  `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                                  `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                                  `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                                  `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                                  `PRGA_YAMI_CACHELINE_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                                         -1;

    localparam  STORE_SIZE_FULL = `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                                  `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                                  `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                                  `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                                  `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                                  `PRGA_YAMI_FMC_DATA_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                                        -1;

    localparam  LOAD_SIZE_FULL  = `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 0 ? `PRGA_YAMI_SIZE_1B :
                                  `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 1 ? `PRGA_YAMI_SIZE_2B :
                                  `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 2 ? `PRGA_YAMI_SIZE_4B :
                                  `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 3 ? `PRGA_YAMI_SIZE_8B :
                                  `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 4 ? `PRGA_YAMI_SIZE_16B :
                                  `PRGA_YAMI_MFC_DATA_BYTES_LOG2 == 5 ? `PRGA_YAMI_SIZE_32B :
                                                                        -1;

    localparam  AMO_SIZE_FULL   = `PRGA_MIN2(STORE_SIZE_FULL, LOAD_SIZE_FULL);

    // -- Core Logic ---------------------------------------------------------
    // tasks
    task automatic process_fmc;
        input [`PRGA_YAMI_SIZE_WIDTH-1:0] full_size;
        input cacheline_size_ok;
        begin
            if (fmc_size == `PRGA_YAMI_SIZE_CACHELINE) begin
                if (cacheline_size_ok) begin
                    fifo_fmc_wr = 1'b1;
                    fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_SIZE_INDEX] = CACHELINE_SIZE;
                end else begin
                    creg_errcode_next = `PRGA_YAMI_CREG_ERRCODE_SIZE_OUT_OF_RANGE;
                    event_error = fmc_vld;
                end
            end else if (fmc_size > full_size) begin
                creg_errcode_next = `PRGA_YAMI_CREG_ERRCODE_SIZE_OUT_OF_RANGE;
                event_error = fmc_vld;
            end else if (fmc_size == `PRGA_YAMI_SIZE_FULL) begin
                fifo_fmc_wr = fmc_vld;
                fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_SIZE_INDEX] = full_size;
            end else begin
                fifo_fmc_wr = fmc_vld;
                fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_SIZE_INDEX] = fmc_size;
            end
        end
    endtask

    always @* begin
        fifo_fmc_wr = 1'b0;
        fifo_fmc_data = { `PRGA_YAMI_FMC_FIFO_ELEM_WIDTH {1'b0} };
        fmc_rdy = 1'b0;
        event_error = 1'b0;
        creg_errcode_next = { `PRGA_YAMI_CREG_DATA_WIDTH {1'b0} };

        if (fmc_creg_vld) begin
            fifo_fmc_wr = 1'b1;
            fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_REQTYPE_INDEX] = `PRGA_YAMI_REQTYPE_CREG_ACK];
            fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_CREG_DATA_INDEX] = fmc_creg_data;
        end else if (yami_active) begin
            fmc_rdy = !fifo_fmc_full;

            if (mfc_timeout) begin
                event_error = 1'b1;
                creg_errcode_next = `PRGA_YAMI_CREG_ERRCODE_TIMEOUT;
            end else if (fmc_parity_fail) begin
                event_error = fmc_vld;
                creg_errcode_next = `PRGA_YAMI_CREG_ERRCODE_PARITY;
            end else if (missing_features) begin
                event_error = fmc_vld;
                creg_errcode_next = `PRGA_YAMI_CREG_ERRCODE_MISSING_FEATURES + missing_features;
            end else begin
                case (fmc_type)
                    `PRGA_YAMI_REQTYPE_LOAD:
                        process_fmc(LOAD_SIZE_FULL, 1'b1);

                    `PRGA_YAMI_REQTYPE_LOAD_NC:
                        process_fmc(LOAD_SIZE_FULL, 1'b0);

                    `PRGA_YAMI_REQTYPE_STORE,
                    `PRGA_YAMI_REQTYPE_STORE_NC:
                        process_fmc(STORE_SIZE_FULL, 1'b0);

                    `PRGA_YAMI_REQTYPE_AMO_LR,
                    `PRGA_YAMI_REQTYPE_AMO_SC,
                    `PRGA_YAMI_REQTYPE_AMO_SWAP,
                    `PRGA_YAMI_REQTYPE_AMO_ADD,
                    `PRGA_YAMI_REQTYPE_AMO_AND,
                    `PRGA_YAMI_REQTYPE_AMO_OR,
                    `PRGA_YAMI_REQTYPE_AMO_XOR,
                    `PRGA_YAMI_REQTYPE_AMO_MAX,
                    `PRGA_YAMI_REQTYPE_AMO_MAXU,
                    `PRGA_YAMI_REQTYPE_AMO_MIN,
                    `PRGA_YAMI_REQTYPE_AMO_MINU:
                        process_fmc(AMO_SIZE_FULL, 1'b0);

                endcase
            end

            fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_REQTYPE_INDEX] = fmc_type;
            fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_ADDR_INDEX] = fmc_addr;
            fifo_fmc_data[`PRGA_YAMI_FMC_FIFO_DATA_INDEX] = fmc_data;
        end
    end

endmodule
