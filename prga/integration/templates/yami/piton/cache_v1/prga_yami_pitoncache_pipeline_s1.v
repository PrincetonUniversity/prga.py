// Automatically generated by PRGA's RTL generator

/*
* Main pipeline, stage I for prga_yami_pitoncache.
*/

`include "prga_yami.vh"
`include "prga_yami_pitoncache.vh"
`default_nettype none

module prga_yami_pitoncache_pipeline_s1 (
    // -- System Ctrl --------------------------------------------------------
    input wire                                          clk
    , input wire                                        rst_n

    // -- Receive FMC Requests from Accelerator ------------------------------
    , output reg                                        a_fmc_rdy
    , input wire                                        a_fmc_vld
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]         a_fmc_type
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            a_fmc_size
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        a_fmc_addr
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]        a_fmc_data

    // -- Receive MFC Responses from Memory ----------------------------------
    , output reg                                        m_mfc_rdy
    , input wire                                        m_mfc_vld
    , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]        m_mfc_type
    , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]        m_mfc_addr
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]        m_mfc_data
    , input wire [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]   m_mfc_inval_way // this is specific to OpenPiton
    , input wire                                        m_mfc_inval_all // this is specific to OpenPiton

    // -- To ROB -------------------------------------------------------------
    , input wire                                        rob_next_entry_vld_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rob_next_entry_s1

    , output reg                                        rob_alloc_s1
    , output reg [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]        rob_alloc_resptype_s1

    // -- From ILQ -----------------------------------------------------------
    , output reg                                        ilq_rd_s1
    , input wire                                        ilq_full_s1
    , input wire                                        ilq_nc_s1
    , input wire [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]     ilq_index_s1
    , input wire [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]   ilq_way_s1
    , input wire [`PRGA_YAMI_CACHE_INDEX_LOW-1:0]       ilq_offset_s1
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            ilq_size_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    ilq_rob_entry_s1

    // -- From ISQ -----------------------------------------------------------
    , output reg                                        isq_rd_s1
    , input wire                                        isq_full_s1
    , input wire                                        isq_nc_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    isq_rob_entry_s1

    // -- From IMQ -----------------------------------------------------------
    , output reg                                        imq_rd_s1
    , input wire                                        imq_full_s1
    , input wire [`PRGA_YAMI_CACHE_INDEX_LOW-1:0]       imq_offset_s1
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            imq_size_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    imq_rob_entry_s1

    // -- To Arrays ----------------------------------------------------------
    , input wire                                        lru_array_busy_s1
    , input wire                                        tag_array_busy_s1
    , input wire                                        state_array_busy_s1

    , output reg [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]     index_s1
    , output reg                                        lru_array_rd_s1
    , output reg                                        tag_array_rd_s1
    , output reg                                        state_array_rd_s1

    // -- To Stage II --------------------------------------------------------
    , input wire                                        stall_s2
    , output reg [`PRGA_YAMI_CACHE_S3OP_WIDTH-1:0]      op_s2_next
    , output reg [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]   inv_ilq_way_s2_next
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]         reqtype_s2_next
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]            size_s2_next
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        addr_s2_next
    , output reg [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]        data_s2_next
    , output reg [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rob_entry_s2_next

    // -- From Stage III -----------------------------------------------------
    , input wire                                        enqueue_rpb_s3

    // -- From RPB -----------------------------------------------------------
    , output reg                                        dequeue_rpb_s1
    , input wire                                        rpb_empty_s1
    , input wire                                        rpb_vld_s1
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]         rpb_reqtype_s1
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            rpb_size_s1
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        rpb_addr_s1
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]        rpb_data_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rpb_rob_entry_s1
    );

    reg may_conflict_s2, may_conflict_s2_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            may_conflict_s2     <= 1'b0;
        end else begin
            may_conflict_s2     <= may_conflict_s2_next;
        end
    end

    always @* begin
        a_fmc_rdy               = 1'b0;
        m_mfc_rdy               = 1'b0;

        rob_alloc_s1            = 1'b0;
        rob_alloc_resptype_s1   = `PRGA_YAMI_RESPTYPE_NONE;

        ilq_rd_s1               = 1'b0;
        isq_rd_s1               = 1'b0;
        imq_rd_s1               = 1'b0;

        index_s1                = { `PRGA_YAMI_CACHE_INDEX_WIDTH {1'b0} };
        lru_array_rd_s1         = 1'b0;
        tag_array_rd_s1         = 1'b0;
        state_array_rd_s1       = 1'b0;

        op_s2_next              = `PRGA_YAMI_CACHE_S3OP_NONE;
        inv_ilq_way_s2_next     = { `PRGA_YAMI_CACHE_NUM_WAYS_LOG2 {1'b0} };
        reqtype_s2_next         = `PRGA_YAMI_REQTYPE_NONE;
        size_s2_next            = `PRGA_YAMI_SIZE_FULL;
        addr_s2_next            = { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        data_s2_next            = { `PRGA_YAMI_MFC_DATA_WIDTH {1'b0} };
        rob_entry_s2_next       = { `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 {1'b0} };

        dequeue_rpb_s1          = 1'b0;

        may_conflict_s2_next    = stall_s2 ? may_conflict_s2 : 1'b0;

        if ( !(stall_s2 || lru_array_busy_s1 || tag_array_busy_s1 || state_array_busy_s1) ) begin
            // prioritize MFC responses over RPB over FMC Requests
            m_mfc_rdy   = 1'b1;

            if (m_mfc_vld) begin
                addr_s2_next[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH] = m_mfc_addr;
                data_s2_next = m_mfc_data;

                case (m_mfc_type)
                    `PRGA_YAMI_RESPTYPE_LOAD_ACK: begin
                        ilq_rd_s1 = 1'b1;
                        index_s1 = ilq_index_s1;
                        lru_array_rd_s1 = 1'b1;
                        tag_array_rd_s1 = 1'b1;
                        state_array_rd_s1 = 1'b1;
                        op_s2_next = ilq_nc_s1 ? `PRGA_YAMI_CACHE_S3OP_LD_NC_ACK : `PRGA_YAMI_CACHE_S3OP_LD_ACK;
                        inv_ilq_way_s2_next = ilq_way_s1;
                        size_s2_next = ilq_size_s1;
                        addr_s2_next[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH] = ilq_index_s1;
                        addr_s2_next[`PRGA_YAMI_CACHE_INDEX_LOW-1:0] = ilq_offset_s1;
                        rob_entry_s2_next = ilq_rob_entry_s1;
                        may_conflict_s2_next = !ilq_nc_s1;
                    end

                    `PRGA_YAMI_RESPTYPE_STORE_ACK: begin
                        isq_rd_s1 = 1'b1;
                        op_s2_next = isq_nc_s1 ? `PRGA_YAMI_CACHE_S3OP_ST_NC_ACK : `PRGA_YAMI_CACHE_S3OP_NONE;
                        rob_entry_s2_next = isq_rob_entry_s1;
                    end

                    `PRGA_YAMI_RESPTYPE_AMO_ACK: begin
                        imq_rd_s1 = 1'b1;
                        op_s2_next = `PRGA_YAMI_CACHE_S3OP_AMO_ACK;
                        size_s2_next = imq_size_s1;
                        addr_s2_next[`PRGA_YAMI_CACHE_INDEX_LOW-1:0] = imq_offset_s1;
                        rob_entry_s2_next = imq_rob_entry_s1;
                    end

                    `PRGA_YAMI_RESPTYPE_CACHE_INV: begin
                        index_s1 = m_mfc_addr;
                        lru_array_rd_s1 = 1'b1;
                        tag_array_rd_s1 = 1'b1;
                        state_array_rd_s1 = 1'b1;
                        op_s2_next = m_mfc_inval_all ? `PRGA_YAMI_CACHE_S3OP_INV_ALL :
                                                       `PRGA_YAMI_CACHE_S3OP_INV_WAY;
                        inv_ilq_way_s2_next = m_mfc_inval_way;
                        may_conflict_s2_next = 1'b1;
                    end
                endcase
            end

            // RPB?
            else if (!may_conflict_s2 && !rpb_empty_s1) begin
                dequeue_rpb_s1  = 1'b1;
                op_s2_next      = rpb_vld_s1 ? `PRGA_YAMI_CACHE_S3OP_APP_REQ : `PRGA_YAMI_CACHE_S3OP_NONE; 
                reqtype_s2_next = rpb_reqtype_s1;
                size_s2_next    = rpb_size_s1;
                addr_s2_next    = rpb_addr_s1;
                index_s1        = rpb_addr_s1[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH];
                data_s2_next    = {2{rpb_data_s1}};
                rob_entry_s2_next   = rpb_rob_entry_s1;
                may_conflict_s2_next = rpb_vld_s1;
                lru_array_rd_s1     = 1'b1;
                tag_array_rd_s1     = 1'b1;
                state_array_rd_s1   = 1'b1;
            end

            // a_fmc
            else begin
                index_s1                = a_fmc_addr[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH];
                reqtype_s2_next         = a_fmc_type;
                size_s2_next            = a_fmc_size;
                addr_s2_next            = a_fmc_addr;
                data_s2_next            = {2{a_fmc_data}};
                rob_entry_s2_next       = rob_next_entry_s1;

                if (!may_conflict_s2 && !enqueue_rpb_s3) begin
                    a_fmc_rdy           = rob_next_entry_vld_s1;

                    case (a_fmc_type)
                        `PRGA_YAMI_REQTYPE_LOAD,
                        `PRGA_YAMI_REQTYPE_LOAD_NC: if (a_fmc_vld && !ilq_full_s1) begin
                            rob_alloc_s1 = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_LOAD_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                        `PRGA_YAMI_REQTYPE_STORE,
                        `PRGA_YAMI_REQTYPE_STORE_NC: if (a_fmc_vld && !isq_full_s1) begin
                            rob_alloc_s1 = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_STORE_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                        `PRGA_YAMI_REQTYPE_AMO_LR,
                        `PRGA_YAMI_REQTYPE_AMO_SC,
                        `PRGA_YAMI_REQTYPE_AMO_SWAP,
                        `PRGA_YAMI_REQTYPE_AMO_ADD,
                        `PRGA_YAMI_REQTYPE_AMO_AND,
                        `PRGA_YAMI_REQTYPE_AMO_OR,
                        `PRGA_YAMI_REQTYPE_AMO_XOR,
                        `PRGA_YAMI_REQTYPE_AMO_MAX,
                        `PRGA_YAMI_REQTYPE_AMO_MAXU,
                        `PRGA_YAMI_REQTYPE_AMO_MIN,
                        `PRGA_YAMI_REQTYPE_AMO_MINU: if (a_fmc_vld && !imq_full_s1) begin
                            rob_alloc_s1 = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_AMO_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                    endcase
                end
            end
        end
    end

endmodule
