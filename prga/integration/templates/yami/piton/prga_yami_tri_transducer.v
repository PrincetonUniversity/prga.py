// Automatically generated by PRGA's RTL generator

/*
* Transducer between PRGA YAMI and OpenPiton TRI.
*/

`include "l15.tmp.h"
`include "prga_yami.vh"
`default_nettype none

module prga_yami_tri_transducer (
    input wire                                  clk
    , input wire                                rst_n

    // == Transducer <-> TRI =================================================
    // -- Transducer -> L15 --------------------------------------------------
    // Outputs
    , output reg                                transducer_l15_val
    , output reg [`PCX_REQTYPE_WIDTH-1:0]       transducer_l15_rqtype
    , output reg                                transducer_l15_nc
    , output reg [`PCX_SIZE_WIDTH-1:0]          transducer_l15_size
    , output reg [39:0]                         transducer_l15_address
    , output reg [63:0]                         transducer_l15_data
    , output reg [`L15_AMO_OP_WIDTH-1:0]        transducer_l15_amo_op

    // ACK
    , input wire                                l15_transducer_ack
    , input wire                                l15_transducer_header_ack

    // Unused outputs
    , output wire [`L15_THREADID_MASK]          transducer_l15_threadid
    , output wire [1:0]                         transducer_l15_l1rplway
    , output wire                               transducer_l15_prefetch
    , output wire                               transducer_l15_invalidate_cacheline // L1 invalidation
    , output wire                               transducer_l15_blockstore
    , output wire                               transducer_l15_blockinitstore
    , output wire [63:0]                        transducer_l15_data_next_entry      // unused (for CAS only)
    , output wire [`TLB_CSM_WIDTH-1:0]          transducer_l15_csm_data             // unused (for CDR only)

    // -- L15 -> Transducer --------------------------------------------------
    // Inputs
    , input wire                                l15_transducer_val
    , input wire [`CPX_RESTYPE_WIDTH-1:0]       l15_transducer_returntype
    , input wire [15:4]                         l15_transducer_inval_address_15_4
    , input wire [63:0]                         l15_transducer_data_0
    , input wire [63:0]                         l15_transducer_data_1

    // ACK: Must be asserted in the same cycle when `l15_transducer_val` is asserted
    , output wire                               transducer_l15_req_ack

    // unchecked inputs
    , input wire                                l15_transducer_noncacheable
    , input wire [`L15_THREADID_MASK]           l15_transducer_threadid

    // == Transducer <-> YAMI ================================================
    // -- FMC (fabric-memory channel) ----------------------------------------
    , output reg                                        fmc_rdy
    , input wire                                        fmc_vld
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]         fmc_type
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]            fmc_size
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]        fmc_addr
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]        fmc_data

    // -- MFC (memory-fabric channel) ----------------------------------------
    , input wire                                        mfc_rdy
    , output reg                                        mfc_vld
    , output reg [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]        mfc_type
    , output wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]       mfc_addr
    , output wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]       mfc_data
    );

    // =======================================================================
    // == Paramterization Validations ========================================
    // =======================================================================

    generate
        if (
            `PRGA_YAMI_CACHELINE_BYTES_LOG2 != 4
            || `PRGA_YAMI_FMC_ADDR_WIDTH > 40
            || `PRGA_YAMI_MFC_ADDR_WIDTH > 16
        ) begin
            __PRGA_PARAMETERIZATION_ERROR__ __error__();
        end
    endgenerate

    // =======================================================================
    // == Send L15 Request ===================================================
    // =======================================================================

    wire                            transducer_l15_stall;

    reg                             l15_transducer_ack_pending;
    reg                             transducer_l15_val_next;
    reg [4:0]                       transducer_l15_rqtype_next;
    reg                             transducer_l15_nc_next;
    reg [2:0]                       transducer_l15_size_next;
    reg [39:0]                      transducer_l15_address_next;
    reg [63:0]                      transducer_l15_data_next;
    reg [`L15_AMO_OP_WIDTH-1:0]     transducer_l15_amo_op_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            l15_transducer_ack_pending  <= 1'b0;

            transducer_l15_val          <= 1'b0;
            transducer_l15_rqtype       <= 5'b0;
            transducer_l15_nc           <= 1'b0;
            transducer_l15_size         <= 3'b0;
            transducer_l15_address      <= 40'b0;
            transducer_l15_data         <= 64'b0;
            transducer_l15_amo_op       <= `L15_AMO_OP_NONE;

        end else if (~transducer_l15_stall) begin
            l15_transducer_ack_pending  <= transducer_l15_val_next;

            transducer_l15_val          <= transducer_l15_val_next;
            transducer_l15_rqtype       <= transducer_l15_rqtype_next;
            transducer_l15_nc           <= transducer_l15_nc_next;
            transducer_l15_size         <= transducer_l15_size_next;
            transducer_l15_address      <= transducer_l15_address_next;
            transducer_l15_data         <= transducer_l15_data_next;
            transducer_l15_amo_op       <= transducer_l15_amo_op_next;

        end else begin
            if (transducer_l15_val && l15_transducer_header_ack) begin
                transducer_l15_val <= 1'b0;
            end

            if (l15_transducer_ack_pending && l15_transducer_ack) begin
                l15_transducer_ack_pending <= 1'b0;
            end
        end
    end

    assign transducer_l15_stall = (transducer_l15_val && ~l15_transducer_header_ack) ||
                                  (l15_transducer_ack_pending && ~l15_transducer_ack);

    // -- Connect unused L15 outputs --
    assign transducer_l15_threadid = {`L15_THREADID_WIDTH {1'b0} }; // only used when 2 YAMI implementations share an L15
    assign transducer_l15_l1rplway = 2'b0;
    assign transducer_l15_prefetch = 1'b0;
    assign transducer_l15_invalidate_cacheline = 1'b0;
    assign transducer_l15_blockstore = 1'b0;
    assign transducer_l15_blockinitstore = 1'b0;
    assign transducer_l15_data_next_entry = 64'b0;
    assign transducer_l15_csm_data = {`TLB_CSM_WIDTH{1'b0} };

    // =======================================================================
    // == Receive L15 Response ===============================================
    // =======================================================================

    // Register L15 responses
    reg                             l15_transducer_stall;
    reg                             l15_transducer_val_f;
    reg [3:0]                       l15_transducer_returntype_f;
    reg [15:4]                      l15_transducer_inval_address_15_4_f;
    reg                             l15_transducer_noncacheable_f;
    reg [`L15_THREADID_MASK]        l15_transducer_threadid_f;
    reg [127:0]                     l15_transducer_data_f;

    always @(posedge clk) begin
        if (~rst_n) begin
            l15_transducer_val_f                <= 1'b0;
            l15_transducer_returntype_f         <= { `CPX_RESTYPE_WIDTH {1'b0} };
            l15_transducer_inval_address_15_4_f <= 12'b0;
            l15_transducer_noncacheable_f       <= 1'b0;
            l15_transducer_threadid_f           <= {`L15_THREADID_WIDTH {1'b0} };
            l15_transducer_data_f               <= 128'b0;
        end else if (~l15_transducer_stall) begin
            l15_transducer_val_f                <= l15_transducer_val;
            l15_transducer_returntype_f         <= l15_transducer_returntype;
            l15_transducer_inval_address_15_4_f <= l15_transducer_inval_address_15_4;
            l15_transducer_noncacheable_f       <= l15_transducer_noncacheable;
            l15_transducer_threadid_f           <= l15_transducer_threadid;
            l15_transducer_data_f               <= { l15_transducer_data_1, l15_transducer_data_0 };
        end
    end

    assign transducer_l15_req_ack = l15_transducer_val && ~l15_transducer_stall;

    // =======================================================================
    // == L15 -> MFC Cacheline Load Processor ================================
    // =======================================================================

    // -- Notes --------------------------------------------------------------
    // The only complicated case is when MFC_DATA_WIDTH is smaller than
    // YAMI_CACHELINE_WIDTH, in which case we need to return the cacheline in
    // multiple transactions (2 if MFC_DATA_WIDTH is 8B, 4 if MFC_DATA_WIDTH is
    // 4B)
    //
    // In addition, L15 -> MFC logic needs to know if a load response from the
    // L15 is responding to a full-cacheline load request. Here we use an
    // 4-entry FIFO to remember that when a load request from FMC is received.
    // 4 entries should be more than enough, because L15 can only handle one
    // load at a time.

    localparam  MFC_DATA_COUNTER_WIDTH = `PRGA_YAMI_CACHELINE_BYTES_LOG2 - `PRGA_YAMI_MFC_DATA_BYTES_LOG2;
    localparam  MFC_DATA_PER_CACHELINE = 1 << MFC_DATA_COUNTER_WIDTH;

    wire        mfc_elem_last;

    generate
        if (MFC_DATA_PER_CACHELINE == 1) begin
            assign mfc_data = l15_transducer_data_f;
            assign mfc_elem_last = 1'b1;

        end else begin

            reg         is_cacheline_load;

            reg [MFC_DATA_COUNTER_WIDTH-1:0]        mfc_elem_cnt;
            reg [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]     mfc_elem;
            wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]    mfc_elems   [0:MFC_DATA_PER_CACHELINE-1];

            genvar gv_mfc_elem;
            for (gv_mfc_elem = 0; gv_mfc_elem < MFC_DATA_PER_CACHELINE; gv_mfc_elem = gv_mfc_elem + 1) begin: g_mfc_elem
                assign mfc_elems[gv_mfc_elem] = l15_transducer_data_f[gv_mfc_elem * `PRGA_YAMI_MFC_DATA_WIDTH +: `PRGA_YAMI_MFC_DATA_WIDTH];
            end

            always @(posedge clk) begin
                if (~rst_n) begin
                    mfc_elem_cnt <= { MFC_DATA_COUNTER_WIDTH {1'b0} };
                end else if (!is_cacheline_load || !l15_transducer_val_f) begin
                    mfc_elem_cnt <= { MFC_DATA_COUNTER_WIDTH {1'b0} };
                end else if (mfc_vld && mfc_rdy && mfc_type == `PRGA_YAMI_RESPTYPE_LOAD_ACK) begin 
                    mfc_elem_cnt <= mfc_elem_cnt + 1;
                end
            end

            reg [3:0]   cacheline_load_tokenq;
            reg [1:0]   cacheline_load_tokenq_wptr, cacheline_load_tokenq_rptr;

            always @(posedge clk) begin
                if (~rst_n) begin
                    cacheline_load_tokenq       <= 4'b0;
                    cacheline_load_tokenq_wptr  <= 3'b0;
                    cacheline_load_tokenq_rptr  <= 3'b0;
                end else begin
                    if (fmc_vld && fmc_rdy && fmc_type == `PRGA_YAMI_REQTYPE_LOAD) begin
                        cacheline_load_tokenq[cacheline_load_tokenq_wptr] <= fmc_size == `PRGA_YAMI_SIZE_16B;
                        cacheline_load_tokenq_wptr <= cacheline_load_tokenq_wptr + 1;
                    end

                    if (mfc_vld && mfc_rdy && mfc_type == `PRGA_YAMI_RESPTYPE_LOAD_ACK && mfc_elem_last) begin
                        cacheline_load_tokenq_rptr <= cacheline_load_tokenq_rptr + 1;
                    end
                end
            end

            always @* begin
                mfc_elem = mfc_elems[mfc_elem_cnt];
                is_cacheline_load = cacheline_load_tokenq[cacheline_load_tokenq_rptr];
            end

            assign mfc_data = mfc_elem;
            assign mfc_elem_last = !is_cacheline_load || &mfc_elem_cnt;
        end
    endgenerate

    // =======================================================================
    // == FMC -> L15 =========================================================
    // =======================================================================

    always @* begin
        transducer_l15_val_next = 1'b0;
        transducer_l15_rqtype_next = {`PCX_REQTYPE_WIDTH {1'b0} };
        transducer_l15_nc_next = 1'b0;
        transducer_l15_size_next = {`PCX_SIZE_WIDTH {1'b0} };
        transducer_l15_address_next = 40'h0;
        transducer_l15_data_next = 64'h0;
        transducer_l15_amo_op_next = `L15_AMO_OP_NONE;

        fmc_rdy = !transducer_l15_stall;
        transducer_l15_val_next = fmc_vld;

        case (fmc_type)
            `PRGA_YAMI_REQTYPE_LOAD:
                transducer_l15_rqtype_next = `PCX_REQTYPE_LOAD;

            `PRGA_YAMI_REQTYPE_LOAD_NC: begin
                transducer_l15_rqtype_next = `PCX_REQTYPE_LOAD;
                transducer_l15_nc_next = 1'b1;
            end

            `PRGA_YAMI_REQTYPE_STORE:
                transducer_l15_rqtype_next = `PCX_REQTYPE_STORE;

            `PRGA_YAMI_REQTYPE_STORE_NC: begin
                transducer_l15_rqtype_next = `PCX_REQTYPE_STORE;
                transducer_l15_nc_next = 1'b1;
            end

            `PRGA_YAMI_REQTYPE_AMO_LR,
            `PRGA_YAMI_REQTYPE_AMO_SC,
            `PRGA_YAMI_REQTYPE_AMO_SWAP,
            `PRGA_YAMI_REQTYPE_AMO_ADD,
            `PRGA_YAMI_REQTYPE_AMO_AND,
            `PRGA_YAMI_REQTYPE_AMO_OR,
            `PRGA_YAMI_REQTYPE_AMO_XOR,
            `PRGA_YAMI_REQTYPE_AMO_MAX,
            `PRGA_YAMI_REQTYPE_AMO_MAXU,
            `PRGA_YAMI_REQTYPE_AMO_MIN,
            `PRGA_YAMI_REQTYPE_AMO_MINU: begin
                transducer_l15_rqtype_next = `PCX_REQTYPE_AMO;
                transducer_l15_nc_next = 1'b1;
            end
        endcase

        case (fmc_size)
            `PRGA_YAMI_SIZE_1B:  transducer_l15_size_next = `PCX_SIZE_WIDTH'b001;
            `PRGA_YAMI_SIZE_2B:  transducer_l15_size_next = `PCX_SIZE_WIDTH'b010;
            `PRGA_YAMI_SIZE_4B:  transducer_l15_size_next = `PCX_SIZE_WIDTH'b011;
            `PRGA_YAMI_SIZE_16B: transducer_l15_size_next = `PCX_SIZE_WIDTH'b111;
            default:             transducer_l15_size_next = `PCX_SIZE_WIDTH'b100;
        endcase

        transducer_l15_address_next[0 +: `PRGA_YAMI_FMC_ADDR_WIDTH] = fmc_addr;

        case (`PRGA_YAMI_FMC_DATA_BYTES_LOG2)
            0: transducer_l15_data_next = { 8 {fmc_data} };
            1: transducer_l15_data_next = { 4 {fmc_data} };
            2: transducer_l15_data_next = { 2 {fmc_data} };
            default: transducer_l15_data_next = fmc_data;
        endcase

        case (fmc_type)
            `PRGA_YAMI_REQTYPE_AMO_LR:   transducer_l15_amo_op_next = `L15_AMO_OP_LR;
            `PRGA_YAMI_REQTYPE_AMO_SC:   transducer_l15_amo_op_next = `L15_AMO_OP_SC;
            `PRGA_YAMI_REQTYPE_AMO_SWAP: transducer_l15_amo_op_next = `L15_AMO_OP_SWAP;
            `PRGA_YAMI_REQTYPE_AMO_ADD:  transducer_l15_amo_op_next = `L15_AMO_OP_ADD;
            `PRGA_YAMI_REQTYPE_AMO_AND:  transducer_l15_amo_op_next = `L15_AMO_OP_AND;
            `PRGA_YAMI_REQTYPE_AMO_OR:   transducer_l15_amo_op_next = `L15_AMO_OP_OR;
            `PRGA_YAMI_REQTYPE_AMO_XOR:  transducer_l15_amo_op_next = `L15_AMO_OP_XOR;
            `PRGA_YAMI_REQTYPE_AMO_MAX:  transducer_l15_amo_op_next = `L15_AMO_OP_MAX;
            `PRGA_YAMI_REQTYPE_AMO_MAXU: transducer_l15_amo_op_next = `L15_AMO_OP_MAXU;
            `PRGA_YAMI_REQTYPE_AMO_MIN:  transducer_l15_amo_op_next = `L15_AMO_OP_MIN;
            `PRGA_YAMI_REQTYPE_AMO_MINU: transducer_l15_amo_op_next = `L15_AMO_OP_MINU;
        endcase
    end

    // =======================================================================
    // == L15 -> MFC =========================================================
    // =======================================================================

    assign mfc_addr = { l15_transducer_inval_address_15_4, 4'b0 };

    // -- Core Logic --------------------------------------------------------

    always @* begin
        mfc_vld = 1'b0;
        mfc_type = `PRGA_YAMI_RESPTYPE_NONE;
        l15_transducer_stall = 1'b0;

        case (l15_transducer_returntype_f)
            `CPX_RESTYPE_LOAD: begin
                mfc_vld = l15_transducer_val_f;
                mfc_type = `PRGA_YAMI_RESPTYPE_LOAD_ACK;
                l15_transducer_stall = l15_transducer_val_f && !(mfc_elem_last && mfc_rdy);
            end

            `CPX_RESTYPE_STORE_ACK: begin
                mfc_vld = l15_transducer_val_f;
                mfc_type = `PRGA_YAMI_RESPTYPE_STORE_ACK;
                l15_transducer_stall = l15_transducer_val_f && !mfc_rdy;
            end

            `CPX_RESTYPE_INVAL: begin
                mfc_vld = l15_transducer_val_f;
                mfc_type = `PRGA_YAMI_RESPTYPE_CACHE_INV;
                l15_transducer_stall = l15_transducer_val_f && !mfc_rdy;
            end

            `CPX_RESTYPE_ATOMIC_RES: begin
                mfc_vld = l15_transducer_val_f;
                mfc_type = `PRGA_YAMI_RESPTYPE_AMO_ACK;
                l15_transducer_stall = l15_transducer_val_f && !mfc_rdy;
            end
        endcase
    end

endmodule
