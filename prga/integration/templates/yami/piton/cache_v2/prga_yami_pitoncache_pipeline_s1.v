// Automatically generated by PRGA's RTL generator

/*
* Main pipeline, stage I for prga_yami_pitoncache.
*/

`include "prga_yami.vh"
`include "prga_yami_pitoncache.vh"
`default_nettype none

module prga_yami_pitoncache_pipeline_s1 (
    // -- System Ctrl --------------------------------------------------------
    input wire                                                  clk
    , input wire                                                rst_n

    // -- Receive FMC Requests from Accelerator ------------------------------
    , output reg                                                a_fmc_rdy
    , input wire                                                a_fmc_vld
    , input wire [`PRGA_YAMI_MTHREAD_ID_WIDTH-1:0]              a_fmc_thread_id
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]                 a_fmc_type
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]                    a_fmc_size
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]                a_fmc_addr
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]                a_fmc_data

    // -- Receive MFC Responses from Memory ----------------------------------
    , output reg                                                m_mfc_rdy
    , input wire                                                m_mfc_vld
    , input wire [`PRGA_YAMI_MTHREAD_ID_WIDTH-1:0]              m_mfc_thread_id
    , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]                m_mfc_type
    , input wire [`PRGA_YAMI_MFC_ADDR_WIDTH-1:0]                m_mfc_addr
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]                m_mfc_data
    , input wire [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]           m_mfc_inval_way // this is specific to OpenPiton
    , input wire                                                m_mfc_inval_all // this is specific to OpenPiton

    // -- To Stage I ---------------------------------------------------------
    //  -- Shared --
    , output reg [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]             index_s1    // also: index_s2_next

    //  -- Arrays --
    , input wire                                                lru_array_busy_s1
    , input wire                                                tag_array_busy_s1
    , input wire                                                state_array_busy_s1
    , output reg                                                lru_array_rd_s1
    , output reg                                                tag_array_rd_s1
    , output reg                                                state_array_rd_s1

    //  -- ROB (Response reOrder Buffer) --
    , input wire [`PRGA_YAMI_NUM_MTHREADS-1:0]                                          rob_next_entry_vld_s1   // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]     rob_next_entry_s1       // per thread
    , output reg [`PRGA_YAMI_NUM_MTHREADS-1:0]                                          rob_alloc_s1            // per thread
    , output reg [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]                                        rob_alloc_resptype_s1

    //  -- PRQ (Pending Response Queue) --
    , output reg [`PRGA_YAMI_NUM_MTHREADS-1:0]                                          prq_rd_s1               // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS-1:0]                                          prq_full_s1             // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS*`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]             prq_index_s1            // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS*`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]           prq_way_s1              // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS*`PRGA_YAMI_CACHE_INDEX_LOW-1:0]               prq_offset_s1           // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS*`PRGA_YAMI_SIZE_WIDTH-1:0]                    prq_size_s1             // per thread
    , input wire [`PRGA_YAMI_NUM_MTHREADS*`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    prq_rob_entry_s1        // per thread

    // -- To Stage II --------------------------------------------------------
    , input wire                                                stall_s2
    , output reg [`PRGA_YAMI_CACHE_S3OP_WIDTH-1:0]              op_s2_next
    , output reg [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]           inv_prq_way_s2_next
    , output reg [`PRGA_YAMI_MTHREAD_ID_WIDTH-1:0]              thread_id_s2_next
    , output reg [`PRGA_YAMI_REQTYPE_WIDTH-1:0]                 reqtype_s2_next
    , output reg [`PRGA_YAMI_SIZE_WIDTH-1:0]                    size_s2_next
    , output reg [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]                addr_s2_next
    , output reg [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]                data_s2_next
    , output reg [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rob_entry_s2_next

    // -- From Stage III -----------------------------------------------------
    , input wire                                                enqueue_rpb_s3

    // -- From RPB (RePlay Buffer) -------------------------------------------
    , output reg                                                validate_rpb_s1
    , output reg                                                dequeue_rpb_s1
    , input wire                                                rpb_empty_s1
    , input wire                                                rpb_vld_s1
    , input wire [`PRGA_YAMI_MTHREAD_ID_WIDTH-1:0]              rpb_thread_id_s1
    , input wire [`PRGA_YAMI_REQTYPE_WIDTH-1:0]                 rpb_reqtype_s1
    , input wire [`PRGA_YAMI_SIZE_WIDTH-1:0]                    rpb_size_s1
    , input wire [`PRGA_YAMI_FMC_ADDR_WIDTH-1:0]                rpb_addr_s1
    , input wire [`PRGA_YAMI_FMC_DATA_WIDTH-1:0]                rpb_data_s1
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rpb_rob_entry_s1
    );

    // conservative stalling
    reg may_conflict_s2, may_conflict_s2_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            may_conflict_s2     <= 1'b0;
        end else begin
            may_conflict_s2     <= may_conflict_s2_next;
        end
    end

    // dis-aggregate "Per-Thread" buses
    wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    rob_next_entry_s1_pt    [`PRGA_YAMI_NUM_MTHREADS-1:0];
    wire [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]             prq_index_s1_pt         [`PRGA_YAMI_NUM_MTHREADS-1:0];
    wire [`PRGA_YAMI_CACHE_NUM_WAYS_LOG2-1:0]           prq_way_s1_pt           [`PRGA_YAMI_NUM_MTHREADS-1:0];
    wire [`PRGA_YAMI_CACHE_INDEX_LOW-1:0]               prq_offset_s1_pt        [`PRGA_YAMI_NUM_MTHREADS-1:0];
    wire [`PRGA_YAMI_SIZE_WIDTH-1:0]                    prq_size_s1_pt          [`PRGA_YAMI_NUM_MTHREADS-1:0];
    wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    prq_rob_entry_s1_pt     [`PRGA_YAMI_NUM_MTHREADS-1:0];

    genvar gv_pt;
    generate for (gv_pt = 0; gv_pt < `PRGA_YAMI_NUM_MTHREADS; gv_pt = gv_pt + 1) begin: g_pt
        assign rob_next_entry_s1_pt[gv_pt]  = rob_next_entry_s1 [gv_pt * `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 +: `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2];
        assign prq_index_s1_pt[gv_pt]       = prq_index_s1      [gv_pt * `PRGA_YAMI_CACHE_INDEX_WIDTH          +: `PRGA_YAMI_CACHE_INDEX_WIDTH];
        assign prq_way_s1_pt[gv_pt]         = prq_way_s1        [gv_pt * `PRGA_YAMI_CACHE_NUM_WAYS_LOG2        +: `PRGA_YAMI_CACHE_NUM_WAYS_LOG2];
        assign prq_offset_s1_pt[gv_pt]      = prq_offset_s1     [gv_pt * `PRGA_YAMI_CACHE_INDEX_LOW            +: `PRGA_YAMI_CACHE_INDEX_LOW];
        assign prq_size_s1_pt[gv_pt]        = prq_size_s1       [gv_pt * `PRGA_YAMI_SIZE_WIDTH                 +: `PRGA_YAMI_SIZE_WIDTH];
        assign prq_rob_entry_s1_pt[gv_pt]   = prq_rob_entry_s1  [gv_pt * `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 +: `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2];
    end endgenerate

    // main logic
    always @* begin
        a_fmc_rdy               = 1'b0;
        m_mfc_rdy               = 1'b0;

        index_s1                = { `PRGA_YAMI_CACHE_INDEX_WIDTH {1'b0} };
        lru_array_rd_s1         = 1'b0;
        tag_array_rd_s1         = 1'b0;
        state_array_rd_s1       = 1'b0;

        rob_alloc_s1            = { `PRGA_YAMI_NUM_MTHREADS {1'b0} };
        rob_alloc_resptype_s1   = `PRGA_YAMI_RESPTYPE_NONE;
        prq_rd_s1               = { `PRGA_YAMI_NUM_MTHREADS {1'b0} };

        op_s2_next              = `PRGA_YAMI_CACHE_S3OP_NONE;
        inv_prq_way_s2_next     = { `PRGA_YAMI_CACHE_NUM_WAYS_LOG2 {1'b0} };
        thread_id_s2_next       = { `PRGA_YAMI_MTHREAD_ID_WIDTH {1'b0} };
        reqtype_s2_next         = `PRGA_YAMI_REQTYPE_NONE;
        size_s2_next            = `PRGA_YAMI_SIZE_FULL;
        addr_s2_next            = { `PRGA_YAMI_FMC_ADDR_WIDTH {1'b0} };
        data_s2_next            = { `PRGA_YAMI_MFC_DATA_WIDTH {1'b0} };
        rob_entry_s2_next       = { `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 {1'b0} };

        validate_rpb_s1         = 1'b0;
        dequeue_rpb_s1          = 1'b0;

        may_conflict_s2_next    = stall_s2 ? may_conflict_s2 : 1'b0;

        if ( !(stall_s2 || lru_array_busy_s1 || tag_array_busy_s1 || state_array_busy_s1) ) begin
            // prioritize MFC responses over RPB over FMC Requests
            m_mfc_rdy   = 1'b1;

            if (m_mfc_vld) begin
                addr_s2_next            = {m_mfc_addr, prq_offset_s1_pt[m_mfc_thread_id]};
                data_s2_next            = m_mfc_data;
                thread_id_s2_next       = m_mfc_thread_id;
                size_s2_next            = prq_size_s1_pt[m_mfc_thread_id];
                rob_entry_s2_next       = prq_rob_entry_s1_pt[m_mfc_thread_id];

                case (m_mfc_type)
                    `PRGA_YAMI_RESPTYPE_LOAD_ACK: begin
                        lru_array_rd_s1             = 1'b1;
                        tag_array_rd_s1             = 1'b1;
                        state_array_rd_s1           = 1'b1;
                        index_s1                    = prq_index_s1_pt[m_mfc_thread_id];
                        prq_rd_s1[m_mfc_thread_id]  = 1'b1;

                        op_s2_next                  = `PRGA_YAMI_CACHE_S3OP_LD_ACK;
                        inv_prq_way_s2_next         = prq_way_s1_pt[m_mfc_thread_id];

                        validate_rpb_s1             = 1'b1;
                        may_conflict_s2_next        = 1'b1;
                    end

                    `PRGA_YAMI_RESPTYPE_STORE_ACK: begin
                        op_s2_next                  = `PRGA_YAMI_CACHE_S3OP_NONE;
                    end

                    `PRGA_YAMI_RESPTYPE_CACHE_INV: begin
                        index_s1                    = m_mfc_addr;
                        lru_array_rd_s1             = 1'b1;
                        tag_array_rd_s1             = 1'b1;
                        state_array_rd_s1           = 1'b1;
                        op_s2_next                  = m_mfc_inval_all ? `PRGA_YAMI_CACHE_S3OP_INV_ALL :
                                                                        `PRGA_YAMI_CACHE_S3OP_INV_WAY;
                        inv_prq_way_s2_next         = m_mfc_inval_way;
                        may_conflict_s2_next        = 1'b1;
                    end

                    `PRGA_YAMI_RESPTYPE_AMO_ACK: begin
                        prq_rd_s1[m_mfc_thread_id]  = 1'b1;
                        op_s2_next                  = `PRGA_YAMI_CACHE_S3OP_AMO_ACK;
                    end

                    default: begin
                        $display ("[Error] |PRGA/YAMI/PitonCache| Unsupported MFC resptype\n");
                        $stop;
                        m_mfc_rdy                   = 1'b0;
                    end
                endcase
            end

            // RPB?
            else if (!may_conflict_s2 && !rpb_empty_s1) begin
                dequeue_rpb_s1          = 1'b1;
                op_s2_next              = rpb_vld_s1 ? `PRGA_YAMI_CACHE_S3OP_APP_REQ : `PRGA_YAMI_CACHE_S3OP_NONE; 
                thread_id_s2_next       = rpb_thread_id_s1;
                reqtype_s2_next         = rpb_reqtype_s1;
                size_s2_next            = rpb_size_s1;
                addr_s2_next            = rpb_addr_s1;
                index_s1                = rpb_addr_s1[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH];
                data_s2_next            = {2{rpb_data_s1}};
                rob_entry_s2_next       = rpb_rob_entry_s1;
                may_conflict_s2_next    = rpb_vld_s1;
                lru_array_rd_s1         = 1'b1;
                tag_array_rd_s1         = 1'b1;
                state_array_rd_s1       = 1'b1;
            end

            // a_fmc
            else begin
                index_s1                = a_fmc_addr[`PRGA_YAMI_CACHE_INDEX_LOW +: `PRGA_YAMI_CACHE_INDEX_WIDTH];
                thread_id_s2_next       = a_fmc_thread_id;
                reqtype_s2_next         = a_fmc_type;
                size_s2_next            = a_fmc_size;
                addr_s2_next            = a_fmc_addr;
                data_s2_next            = {2{a_fmc_data}};
                rob_entry_s2_next       = rob_next_entry_s1_pt[a_fmc_thread_id];

                if (!may_conflict_s2 && !enqueue_rpb_s3) begin
                    a_fmc_rdy           = rob_next_entry_vld_s1[a_fmc_thread_id];

                    case (a_fmc_type)
                        `PRGA_YAMI_REQTYPE_LOAD: if (a_fmc_vld && !prq_full_s1[a_fmc_thread_id]) begin
                            rob_alloc_s1[a_fmc_thread_id] = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_LOAD_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1[a_fmc_thread_id]) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                        `PRGA_YAMI_REQTYPE_STORE: if (a_fmc_vld) begin
                            rob_alloc_s1[a_fmc_thread_id] = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_STORE_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1[a_fmc_thread_id]) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                        `PRGA_YAMI_REQTYPE_AMO_LR,
                        `PRGA_YAMI_REQTYPE_AMO_SC,
                        `PRGA_YAMI_REQTYPE_AMO_SWAP,
                        `PRGA_YAMI_REQTYPE_AMO_ADD,
                        `PRGA_YAMI_REQTYPE_AMO_AND,
                        `PRGA_YAMI_REQTYPE_AMO_OR,
                        `PRGA_YAMI_REQTYPE_AMO_XOR,
                        `PRGA_YAMI_REQTYPE_AMO_MAX,
                        `PRGA_YAMI_REQTYPE_AMO_MAXU,
                        `PRGA_YAMI_REQTYPE_AMO_MIN,
                        `PRGA_YAMI_REQTYPE_AMO_MINU: if (a_fmc_vld && !prq_full_s1[a_fmc_thread_id]) begin
                            rob_alloc_s1[a_fmc_thread_id] = 1'b1;
                            rob_alloc_resptype_s1 = `PRGA_YAMI_RESPTYPE_AMO_ACK;
                            may_conflict_s2_next = 1'b1;

                            if (rob_next_entry_vld_s1[a_fmc_thread_id]) begin
                                lru_array_rd_s1 = 1'b1;
                                tag_array_rd_s1 = 1'b1;
                                state_array_rd_s1 = 1'b1;
                                op_s2_next = `PRGA_YAMI_CACHE_S3OP_APP_REQ;
                            end
                        end

                        default: begin
                            $display ("[Error] |PRGA/YAMI/PitonCache| Unsupported FMC reqtype\n");
                            $stop;
                            a_fmc_rdy = 1'b0;
                        end

                    endcase
                end
            end
        end
    end

endmodule
