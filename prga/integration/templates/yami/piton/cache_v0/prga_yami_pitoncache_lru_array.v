// Automatically generated by PRGA's RTL generator

/*
* LRU array for prga_yami_pitoncache.
*/

`include "prga_yami.vh"
`include "prga_yami_pitoncache.vh"
`default_nettype none

module prga_yami_pitoncache_lru_array #(
    parameter   INITIALIZE          = 1
    , parameter USE_INITIAL_BLOCK   = 0     // if set, use `initial` block to initialize the LRU array
                                            // this only works when the cache is implemented as a soft cache inside the FPGA
) (
    // -- System Ctrl --------------------------------------------------------
    input wire                                          clk
    , input wire                                        rst_n

    // -- Stage I ------------------------------------------------------------
    , output wire                                       busy_s2
    , input wire                                        rd_s2
    , input wire [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]     index_s2

    // -- Stage II -----------------------------------------------------------
    , output wire [`PRGA_YAMI_CACHE_LRU_WIDTH * `PRGA_YAMI_CACHE_NUM_WAYS - 1:0] rdata_s3

    , input wire                                        wr_s3
    , input wire [`PRGA_YAMI_CACHE_NUM_WAYS-1:0]        inc_mask_s3
    , input wire [`PRGA_YAMI_CACHE_NUM_WAYS-1:0]        clr_mask_s3
    );

    localparam  LINE_WIDTH  = `PRGA_YAMI_CACHE_LRU_WIDTH * `PRGA_YAMI_CACHE_NUM_WAYS;
    localparam  LINE_COUNT  = 1 << `PRGA_YAMI_CACHE_INDEX_WIDTH;

    // -- Tag Array Memory --
    wire                                    we;
    reg                                     read_after_write;
    wire [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0] waddr;
    wire [LINE_WIDTH-1:0]                   din;

    reg [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]  raddr_s3;
    reg [LINE_WIDTH-1:0]                    din_f, dout;
    reg [LINE_WIDTH-1:0]                    data [0:LINE_COUNT-1];

    assign rdata_s3 = read_after_write ? din_f : dout;

    always @(posedge clk) begin
        dout <= data[index_s2];
        din_f <= din;
        if (we)
            data[waddr] <= din;
    end

    always @(posedge clk) begin
        if (~rst_n) begin
            raddr_s3 <= { `PRGA_YAMI_CACHE_INDEX_WIDTH {1'b0} };
            read_after_write <= 1'b0;
        end else if (rd_s2) begin
            raddr_s3 <= index_s2;
            read_after_write <= we && waddr == index_s2;
        end else begin
            read_after_write <= 1'b0;
        end
    end

    // -- Initailization --
    generate
        if (!INITIALIZE) begin
            assign busy_s2 = 1'b0;
            assign we = wr_s3;
            assign waddr = raddr_s3;

        end else if (USE_INITIAL_BLOCK) begin
            integer lv_init;
            initial begin
                for (lv_init = 0; lv_init < LINE_COUNT; lv_init = lv_init + 1) begin
                    data[lv_init] = { (`PRGA_YAMI_CACHE_NUM_WAYS * `PRGA_YAMI_CACHE_LRU_WIDTH) {1'b0} };
                end
            end

            assign busy_s2 = 1'b0;
            assign we = wr_s3;
            assign waddr = raddr_s3;

        end else begin
            // -- FSM (for initialization) --
            localparam  ST_WIDTH    = 2;
            localparam  ST_RST      = 2'd0,
                        ST_INIT     = 2'd1,
                        ST_READY    = 2'd2;

            reg [ST_WIDTH-1:0]                      state, state_next;
            reg [`PRGA_YAMI_CACHE_INDEX_WIDTH-1:0]  init_index;

            always @(posedge clk) begin
                if (~rst_n) begin
                    init_index  <= { `PRGA_YAMI_CACHE_INDEX_WIDTH {1'b0} };
                end else if (state == ST_INIT) begin
                    init_index  <= init_index + 1;
                end
            end

            always @(posedge clk) begin
                if (~rst_n) begin
                    state <= ST_RST;
                end else begin
                    state <= state_next;
                end
            end

            always @* begin
                state_next = state;

                case (state)
                    ST_RST:     state_next = ST_INIT;
                    ST_INIT:    state_next = &init_index ? ST_READY : ST_INIT;
                endcase
            end

            assign busy_s2 = state != ST_READY;
            assign we = state == ST_INIT || wr_s3;
            assign waddr = state == ST_INIT ? init_index : raddr_s3;
        end
    endgenerate

    genvar gv_way;
    generate
        for (gv_way = 0; gv_way < `PRGA_YAMI_CACHE_NUM_WAYS; gv_way = gv_way + 1) begin: g_way
            wire [`PRGA_YAMI_CACHE_LRU_WIDTH-1:0]    din_tmp;

            assign din_tmp = busy_s2 ? { `PRGA_YAMI_CACHE_LRU_WIDTH {1'b0} } :
                             clr_mask_s3[gv_way] ? { `PRGA_YAMI_CACHE_LRU_WIDTH {1'b0} } :
                             inc_mask_s3[gv_way] ? (rdata_s3[`PRGA_YAMI_CACHE_LRU_WIDTH * gv_way +: `PRGA_YAMI_CACHE_LRU_WIDTH] + 1) :
                                                   rdata_s3[`PRGA_YAMI_CACHE_LRU_WIDTH * gv_way +: `PRGA_YAMI_CACHE_LRU_WIDTH] ;

            assign din[`PRGA_YAMI_CACHE_LRU_WIDTH * gv_way +: `PRGA_YAMI_CACHE_LRU_WIDTH] = din_tmp;
        end
    endgenerate

endmodule
