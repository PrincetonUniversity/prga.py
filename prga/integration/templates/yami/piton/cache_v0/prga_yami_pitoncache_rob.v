// Automatically generated by PRGA's RTL generator

/*
* Response ReOrder Buffer for prga_yami_pitoncache.
*/

`include "prga_yami.vh"
`include "prga_yami_pitoncache.vh"
`default_nettype none

module prga_yami_pitoncache_rob (
    // -- System Ctrl --------------------------------------------------------
    input wire                                          clk
    , input wire                                        rst_n

    // -- Send MFC Responses -------------------------------------------------
    , input wire                                        mfc_rdy
    , output reg                                        mfc_vld
    , output reg [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]        mfc_type
    , output reg [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]        mfc_data

    // -- Ports to Pipeline --------------------------------------------------
    // -- Stage I --
    , output wire                                               next_entry_vld_s2
    , output wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]   next_entry_s2

    , input wire                                                alloc_s2
    , input wire [`PRGA_YAMI_RESPTYPE_WIDTH-1:0]                alloc_resptype_s2

    // -- Stage II --
    , input wire                                                fill_s3
    , input wire [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2-1:0]    fill_entry_s3
    , input wire [`PRGA_YAMI_MFC_DATA_WIDTH-1:0]                fill_data_s3
    );

    // Each entry:
    //
    //  +--------+----------+------+
    //  | filled | resptype | data |
    //  +--------+----------+------+

    localparam  ENTRY_DATA_BASE         = 0;
    localparam  ENTRY_RESPTYPE_BASE     = ENTRY_DATA_BASE + `PRGA_YAMI_MFC_DATA_WIDTH;
    localparam  ENTRY_FILLED            = ENTRY_RESPTYPE_BASE + `PRGA_YAMI_RESPTYPE_WIDTH;
    localparam  ENTRY_WIDTH             = ENTRY_FILLED + 1;

    localparam  NUM_ENTRIES             = 1 << `PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2;

    reg [`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2:0]   rptr, wptr;
    reg [ENTRY_WIDTH-1:0]                           entries     [0:NUM_ENTRIES-1];

    always @(posedge clk) begin
        if (~rst_n) begin
            rptr            <= {`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 {1'b0} };
            wptr            <= {`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2 {1'b0} };
        end else begin
            if (alloc_s2 && next_entry_vld_s2) begin
                entries[wptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2]] <= { 1'b0, alloc_resptype_s2, {`PRGA_YAMI_MFC_DATA_WIDTH {1'b0} } };
                wptr <= wptr + 1;
            end

            if (fill_s3) begin
                entries[update_entry_s3][ENTRY_FILLED]                                   <= 1'b1;
                entries[update_entry_s3][ENTRY_DATA_BASE+:`PRGA_YAMI_MFC_DATA_WIDTH]     <= fill_data_s3;
            end

            if (mfc_rdy && mfc_vld) begin
                rptr <= rptr + 1;
            end
        end
    end

    always @* begin
        mfc_type = entries[rptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2]][ENTRY_RESPTYPE_BASE +: `PRGA_YAMI_RESPTYPE_WIDTH];
        mfc_data = entries[rptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2]][ENTRY_DATA_BASE +: `PRGA_YAMI_MFC_DATA_WIDTH];

        if (rptr == wptr) begin
            mfc_vld = 1'b0;
        end else if (entries[rptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2]][ENTRY_FILLED]) begin
            mfc_vld = 1'b1;
        end

        // reduce latency from 3 cycles to 2 cycles, but may hinder timing 
        else if (fill_s3 && fill_entry_s3 == rptr) begin
            mfc_vld = 1'b1;
            mfc_data = fill_data_s3;
        end
        
        else begin
            mfc_vld = 1'b0;
        end
    end

    assign next_entry_vld_s2 = wptr != {~rptr[`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2], rptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2]};
    assign next_entry_s2 = wptr[0+:`PRGA_YAMI_CACHE_ROB_NUM_ENTRIES_LOG2];

endmodule
