// Automatically generated by PRGA's RTL generator

/*
* Memory Protection Layer in AXI4 interface.
*/

`include "prga_system_axi4.vh"

`ifdef DEFAULT_NETTYPE_NONE
`default_nettype none
`endif

module prga_mprot #(
    parameter   DECOUPLED = 1
    , parameter SWAP_ENDIANNESS = 0
) (
    input wire                                  clk,
    input wire                                  rst_n,

    // == SAX -> MPROT =======================================================
    output wire                                 sax_rdy,
    input wire                                  sax_val,
    input wire [`PRGA_SAX_DATA_WIDTH-1:0]       sax_data,

    // == MPROT -> ASX =======================================================
    input wire                                  asx_rdy,
    output wire                                 asx_val,
    output wire [`PRGA_ASX_DATA_WIDTH-1:0]      asx_data,

    // == Control Signals ====================================================
    input wire                                  app_en,

    input wire [`PRGA_CREG_DATA_WIDTH-1:0]      app_features,
    input wire [`PRGA_PROT_TIMER_WIDTH-1:0]     timeout_limit,
    input wire                                  urst_n,

    // == AXI4 Slave Interface ===============================================
    // -- AW channel --
    output wire                                 awready,
    input wire                                  awvalid,
    input wire [`PRGA_AXI4_ID_WIDTH-1:0]        awid,
    input wire [`PRGA_AXI4_ADDR_WIDTH-1:0]      awaddr,
    input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]     awlen,
    input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]    awsize,
    input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]   awburst,

    // non-standard use of AWCACHE: Only |AWCACHE[3:2] is checked: 1'b1: cacheable; 1'b0: non-cacheable
    input wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0]   awcache,

    // ECC
    input wire [`PRGA_CCM_ECC_WIDTH-1:0]        awuser,

    // not used
    //  input wire                                  awlock,     // all atomic operations are done through AR channel
    //  input wire [2:0]                            awprot,
    //  input wire [3:0]                            awqos,
    //  input wire [3:0]                            awregion,

    // -- W channel --
    output wire                                 wready,
    input wire                                  wvalid,
    input wire [`PRGA_AXI4_DATA_WIDTH-1:0]      wdata,
    input wire [`PRGA_AXI4_DATA_BYTES-1:0]      wstrb,
    input wire                                  wlast,

    // ECC
    input wire [`PRGA_CCM_ECC_WIDTH-1:0]        wuser,

    // -- B channel --
    input wire                                  bready,
    output wire                                 bvalid,
    output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]    bresp,
    output wire [`PRGA_AXI4_ID_WIDTH-1:0]       bid,

    // -- AR channel --
    output wire                                 arready,
    input wire                                  arvalid,
    input wire [`PRGA_AXI4_ID_WIDTH-1:0]        arid,
    input wire [`PRGA_AXI4_ADDR_WIDTH-1:0]      araddr,
    input wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]     arlen,
    input wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]    arsize,
    input wire [`PRGA_AXI4_AXBURST_WIDTH-1:0]   arburst,

    // non-standard use of ARLOCK: indicates an atomic operation.
    // Type of the atomic operation is specified in the ARUSER field
    input wire                                  arlock,

    // non-standard use of ARCACHE: Only |ARCACHE[3:2] is checked: 1'b1: cacheable; 1'b0: non-cacheable
    input wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0]   arcache,

    // ATOMIC operation type, data & ECC:
    //      aruser[`PRGA_CCM_ECC_WIDTH + `PRGA_CCM_AMO_OPCODE_WIDTH +: `PRGA_CCM_DATA_WIDTH]        amo_data
    //      aruser[`PRGA_CCM_ECC_WIDTH                              +: `PRGA_CCM_AMO_OPCODE_WIDTH]  amo_opcode
    //      aruser[0                                                +: `PRGA_CCM_ECC_WIDTH]         ecc
    input wire [`PRGA_CCM_AMO_OPCODE_WIDTH + `PRGA_CCM_ECC_WIDTH + `PRGA_CCM_DATA_WIDTH - 1:0]      aruser,

    // not used
    //  input wire [2:0]                            arprot,
    //  input wire [3:0]                            arqos,
    //  input wire [3:0]                            arregion,

    // -- R channel --
    input wire                                  rready,
    output wire                                 rvalid,
    output wire [`PRGA_AXI4_XRESP_WIDTH-1:0]    rresp,
    output wire [`PRGA_AXI4_ID_WIDTH-1:0]       rid,
    output wire [`PRGA_AXI4_DATA_WIDTH-1:0]     rdata,
    output wire                                 rlast
    );

    // Identifier for Sub-Components
    localparam  NUM_IDS = 4;
    localparam  ID_B    = 0,    // B channel
                ID_R    = 1,    // R channel
                ID_AW   = 2,    // AW & W channel
                ID_AR   = 3;    // AR channel

    // =======================================================================
    // -- Extract Related APP Features ---------------------------------------
    // =======================================================================
    wire ccm_en, ccm_nc_en, ccm_atomic_en, ccm_mthread_en;

    assign ccm_en = app_features[`PRGA_APP_CCM_EN_INDEX];
    assign ccm_nc_en = app_features[`PRGA_APP_CCM_NC_EN_INDEX];
    assign ccm_atomic_en = app_features[`PRGA_APP_CCM_ATOMIC_EN_INDEX] && ccm_nc_en;
    assign ccm_mthread_en = app_features[`PRGA_APP_CCM_MTHREAD_EN_INDEX];

    reg [`PRGA_PROT_TIMER_WIDTH-1:0]        timeout_limit_f;

    always @(posedge clk) begin
        if (~rst_n) begin
            timeout_limit_f     <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else begin
            timeout_limit_f     <= timeout_limit;
        end
    end

    // =======================================================================
    // -- Forward Declarations -----------------------------------------------
    // =======================================================================

    // == Feedback signals ==
    // error_reported is a fast path of ~app_en
    reg error_reported;
    reg [NUM_IDS - 1:0] report_error;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            error_reported <= 1'b0;
        end else if (|report_error) begin
            error_reported <= 1'b1;
        end
    end

    // =======================================================================
    // -- Buffer Requests ----------------------------------------------------
    // =======================================================================

    wire ccm_intf_en;
    assign ccm_intf_en = rst_n && app_en && ccm_en && urst_n && ~error_reported;

    // -- AW channel --
    reg                                 awready_p;
    wire                                awvalid_f;
    wire [`PRGA_AXI4_ID_WIDTH-1:0]      awid_f, awid_tmp;
    wire [`PRGA_AXI4_ADDR_WIDTH-1:0]    awaddr_f;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]   awlen_f;
    wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]  awsize_f;
    wire [`PRGA_AXI4_AXBURST_WIDTH-1:0] awburst_f;
    wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0] awcache_f, awcache_tmp;
    wire [`PRGA_CCM_ECC_WIDTH-1:0]      awecc_f;

    prga_valrdy_buf #(
        .REGISTERED     (1)
        ,.DECOUPLED     (DECOUPLED)
        ,.DATA_WIDTH    (
            `PRGA_AXI4_ID_WIDTH         // awid
            + `PRGA_AXI4_ADDR_WIDTH     // awaddr
            + `PRGA_AXI4_AXLEN_WIDTH    // awlen
            + `PRGA_AXI4_AXSIZE_WIDTH   // awsize
            + `PRGA_AXI4_AXBURST_WIDTH  // awburst
            + `PRGA_AXI4_AXCACHE_WIDTH  // awcache
            + `PRGA_CCM_ECC_WIDTH       // awuser (awecc)
        )
    ) i_buf_aw (
        .clk            (clk)
        ,.rst           (~ccm_intf_en)
        ,.rdy_o         (awready)
        ,.val_i         (awvalid)
        ,.data_i        ({
            awid
            , awaddr
            , awlen
            , awsize
            , awburst
            , awcache
            , awuser
        })
        ,.rdy_i         (awready_p)
        ,.val_o         (awvalid_f)
        ,.data_o        ({
            awid_tmp
            , awaddr_f
            , awlen_f
            , awsize_f
            , awburst_f
            , awcache_tmp
            , awecc_f
        })
        );

    assign awid_f = ccm_mthread_en ? awid_tmp : {`PRGA_AXI4_ID_WIDTH {1'b0} };
    assign awcache_f = ccm_nc_en ? awcache_tmp : `PRGA_AXI4_AWCACHE_WB_ALCT;

    // -- W channel --
    reg                                 wready_p;
    wire                                wvalid_f;
    wire [`PRGA_AXI4_DATA_WIDTH-1:0]    wdata_f;
    wire [`PRGA_AXI4_DATA_BYTES-1:0]    wstrb_f;
    wire                                wlast_f;
    wire [`PRGA_CCM_ECC_WIDTH-1:0]      wecc_f;

    prga_valrdy_buf #(
        .REGISTERED     (1)
        ,.DECOUPLED     (DECOUPLED)
        ,.DATA_WIDTH    (
            `PRGA_AXI4_DATA_WIDTH       // wdata
            + `PRGA_AXI4_DATA_BYTES     // wstrb
            + 1                         // wlast
            + `PRGA_CCM_ECC_WIDTH       // wuser (wecc)
        )
    ) i_buf_w (
        .clk            (clk)
        ,.rst           (~ccm_intf_en)
        ,.rdy_o         (wready)
        ,.val_i         (wvalid)
        ,.data_i        ({
            wdata
            , wstrb
            , wlast
            , wuser
        })
        ,.rdy_i         (wready_p)
        ,.val_o         (wvalid_f)
        ,.data_o        ({
            wdata_f
            , wstrb_f
            , wlast_f
            , wecc_f
        })
        );

    // -- B channel --
    wire                                bready_f;
    reg                                 bvalid_p;
    reg  [`PRGA_AXI4_XRESP_WIDTH-1:0]   bresp_p;
    reg  [`PRGA_AXI4_ID_WIDTH-1:0]      bid_p;

    prga_valrdy_buf #(
        .REGISTERED     (1)
        ,.DECOUPLED     (DECOUPLED)
        ,.DATA_WIDTH    (
            `PRGA_AXI4_XRESP_WIDTH      // bresp
            + `PRGA_AXI4_ID_WIDTH       // bid
        )
    ) i_buf_b (
        .clk            (clk)
        ,.rst           (~ccm_intf_en)
        ,.rdy_o         (bready_f)
        ,.val_i         (bvalid_p)
        ,.data_i        ({
            bresp_p
            , bid_p
        })
        ,.rdy_i         (bready)
        ,.val_o         (bvalid)
        ,.data_o        ({
            bresp
            , bid
        })
        );

    // -- AR channel --
    reg                                 arready_p;
    wire                                arvalid_f;
    wire [`PRGA_AXI4_ID_WIDTH-1:0]      arid_f, arid_tmp;
    wire [`PRGA_AXI4_ADDR_WIDTH-1:0]    araddr_f;
    wire [`PRGA_AXI4_AXLEN_WIDTH-1:0]   arlen_f;
    wire [`PRGA_AXI4_AXSIZE_WIDTH-1:0]  arsize_f;
    wire [`PRGA_AXI4_AXBURST_WIDTH-1:0] arburst_f;
    wire                                arlock_f, arlock_tmp;
    wire [`PRGA_AXI4_AXCACHE_WIDTH-1:0] arcache_f, arcache_tmp;
    wire [`PRGA_CCM_DATA_WIDTH-1:0]         aramodata_f, aramodata_tmp;
    wire [`PRGA_CCM_AMO_OPCODE_WIDTH-1:0]   aramo_f, aramo_tmp;
    wire [`PRGA_CCM_ECC_WIDTH-1:0]          arecc_f;

    prga_valrdy_buf #(
        .REGISTERED     (1)
        ,.DECOUPLED     (DECOUPLED)
        ,.DATA_WIDTH    (
            `PRGA_AXI4_ID_WIDTH         // arid
            + `PRGA_AXI4_ADDR_WIDTH     // araddr
            + `PRGA_AXI4_AXLEN_WIDTH    // arlen
            + `PRGA_AXI4_AXSIZE_WIDTH   // arsize
            + `PRGA_AXI4_AXBURST_WIDTH  // arburst
            + 1                         // arlock
            + `PRGA_AXI4_AXCACHE_WIDTH  // arcache
            + `PRGA_CCM_DATA_WIDTH          // aruser.amo_data
            + `PRGA_CCM_AMO_OPCODE_WIDTH    // aruser.amo_opcode
            + `PRGA_CCM_ECC_WIDTH           // aruser.ecc
        )
    ) i_buf_ar (
        .clk            (clk)
        ,.rst           (~ccm_intf_en)
        ,.rdy_o         (arready)
        ,.val_i         (arvalid)
        ,.data_i        ({
            arid
            , araddr
            , arlen
            , arsize
            , arburst
            , arlock
            , arcache
            , aruser
        })
        ,.rdy_i         (arready_p)
        ,.val_o         (arvalid_f)
        ,.data_o        ({
            arid_tmp
            , araddr_f
            , arlen_f
            , arsize_f
            , arburst_f
            , arlock_tmp
            , arcache_tmp
            , aramodata_tmp
            , aramo_tmp
            , arecc_f
        })
        );

    assign arid_f = ccm_mthread_en ? arid_tmp : {`PRGA_AXI4_ID_WIDTH {1'b0} };
    assign arlock_f = ccm_atomic_en ? arlock_tmp : 1'b0;
    assign arcache_f = ccm_nc_en ? arcache_tmp : `PRGA_AXI4_ARCACHE_WB_ALCT;
    assign aramo_f = ccm_atomic_en ? aramo_tmp : {`PRGA_CCM_AMO_OPCODE_WIDTH {1'b0} };
    assign aramodata_f = ccm_atomic_en ? aramodata_tmp : {`PRGA_CCM_DATA_WIDTH {1'b0} };

    // -- R channel --
    wire                                rready_f;
    reg                                 rvalid_p;
    reg [`PRGA_AXI4_XRESP_WIDTH-1:0]    rresp_p;
    reg [`PRGA_AXI4_ID_WIDTH-1:0]       rid_p;
    reg [`PRGA_AXI4_DATA_WIDTH-1:0]     rdata_p;
    reg                                 rlast_p;

    prga_valrdy_buf #(
        .REGISTERED     (1)
        ,.DECOUPLED     (DECOUPLED)
        ,.DATA_WIDTH    (
            `PRGA_AXI4_XRESP_WIDTH      // rresp
            + `PRGA_AXI4_ID_WIDTH       // rid
            + `PRGA_AXI4_DATA_WIDTH     // rdata
            + 1                         // rlast
        )
    ) i_buf_r (
        .clk            (clk)
        ,.rst           (~ccm_intf_en)
        ,.rdy_o         (rready_f)
        ,.val_i         (rvalid_p)
        ,.data_i        ({
            rresp_p
            , rid_p
            , rdata_p
            , rlast_p
        })
        ,.rdy_i         (rready)
        ,.val_o         (rvalid)
        ,.data_o        ({
            rresp
            , rid
            , rdata
            , rlast
        })
        );

    // =======================================================================
    // -- Validation ---------------------------------------------------------
    // =======================================================================

    // -- AW ECC check --
    wire                                awecc_fail;
    {{ module.instances.i_ecc_checker.model.name }} #(
        .DATA_WIDTH (
            `PRGA_AXI4_ID_WIDTH         // awid
            + `PRGA_AXI4_ADDR_WIDTH     // awaddr
            + `PRGA_AXI4_AXLEN_WIDTH    // awlen
            + `PRGA_AXI4_AXSIZE_WIDTH   // awsize
            + `PRGA_AXI4_AXBURST_WIDTH  // awburst
            + `PRGA_AXI4_AXCACHE_WIDTH  // awcache
        )
    ) i_ecc_aw (
            .clk    (clk)
            ,.rst_n (~ccm_intf_en)
            ,.data  ({
                awid_f
                , awaddr_f
                , awlen_f
                , awsize_f
                , awburst_f
                , awcache_f
            })
            ,.ecc   (awecc_f)
            ,.fail  (awecc_fail)
        );

    // -- W ECC check --
    wire                                wecc_fail;
    {{ module.instances.i_ecc_checker.model.name }} #(
        .DATA_WIDTH (
            `PRGA_AXI4_DATA_WIDTH       // wdata
            + `PRGA_AXI4_DATA_BYTES     // wstrb
            + 1                         // wlast
        )
    ) i_ecc_w (
            .clk    (clk)
            ,.rst_n (~ccm_intf_en)
            ,.data  ({
                wdata_f
                , wstrb_f
                , wlast_f
            })
            ,.ecc   (wecc_f)
            ,.fail  (wecc_fail)
        );

    // -- AR ECC check --
    wire                                arecc_fail;
    {{ module.instances.i_ecc_checker.model.name }} #(
        .DATA_WIDTH (
            `PRGA_AXI4_ID_WIDTH         // arid
            + `PRGA_AXI4_ADDR_WIDTH     // araddr
            + `PRGA_AXI4_AXLEN_WIDTH    // arlen
            + `PRGA_AXI4_AXSIZE_WIDTH   // arsize
            + `PRGA_AXI4_AXBURST_WIDTH  // arburst
            + 1                         // arlock
            + `PRGA_AXI4_AXCACHE_WIDTH  // arcache
            + `PRGA_CCM_AMO_OPCODE_WIDTH    // aruser.amo_opcode
            + `PRGA_CCM_DATA_WIDTH          // aruser.amo_data
        )
    ) i_ecc_ar (
            .clk    (clk)
            ,.rst_n (~ccm_intf_en)
            ,.data  ({
                arid_f
                , araddr_f
                , arlen_f
                , arsize_f
                , arburst_f
                , arlock_f
                , arcache_f
                , aramo_f
                , aramodata_f
            })
            ,.ecc   (arecc_f)
            ,.fail  (arecc_fail)
        );

    // -- AW Request size --
    //  We don't support unaligned accesses
    wire                                awsize_inval;
    assign awsize_inval = ~(awsize_f == `PRGA_AXI4_AXSIZE_1B                                // 1B
                          || (awsize_f == `PRGA_AXI4_AXSIZE_2B && awaddr_f[0:0] == 1'b0)    // 2B aligned
                          || (awsize_f == `PRGA_AXI4_AXSIZE_4B && awaddr_f[1:0] == 2'h0)    // 4B aligned
                          || (awsize_f == `PRGA_AXI4_AXSIZE_8B && awaddr_f[2:0] == 3'h0)    // 8B aligned
        );

    // -- AR Request size --
    //  We don't support unaligned accesses
    wire                                arsize_inval;
    assign arsize_inval = ~(arsize_f == `PRGA_AXI4_AXSIZE_1B                                // 1B
                          || (arsize_f == `PRGA_AXI4_AXSIZE_2B && araddr_f[0:0] == 1'b0)    // 2B aligned
                          || (arsize_f == `PRGA_AXI4_AXSIZE_4B && araddr_f[1:0] == 2'h0)    // 4B aligned
                          || (arsize_f == `PRGA_AXI4_AXSIZE_8B && araddr_f[2:0] == 3'h0)    // 8B aligned
        );

    // -- AR AMO Request Type --
    wire                                aramo_inval;
    assign aramo_inval = arlock_f && (arlen_f != 0 ||
                         ~(aramo_f == `PRGA_CCM_AMO_OPCODE_LR
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_SC
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_SWAP
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_ADD
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_AND
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_OR
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_XOR
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_MAX
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_MAXU
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_MIN
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_MINU
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_CAS1
                         || aramo_f == `PRGA_CCM_AMO_OPCODE_CAS2));

    // =======================================================================
    // -- ASX Arbitration ----------------------------------------------------
    // =======================================================================
    localparam  ASX_ARB_WIDTH   = 3;
    localparam  ASX_ARB_NONE    = 3'h7;

    wire                            asx_rdy_f;
    reg                             asx_val_p;
    reg [`PRGA_ASX_DATA_WIDTH-1:0]  asx_data_p;

    prga_valrdy_buf #(
        .REGISTERED             (1)
        ,.DECOUPLED             (0)
        ,.DATA_WIDTH            (`PRGA_ASX_DATA_WIDTH)
    ) i_buf_asx (
        .clk                    (clk)
        ,.rst                   (~rst_n)
        ,.rdy_o                 (asx_rdy_f)
        ,.val_i                 (asx_val_p)
        ,.data_i                (asx_data_p)
        ,.rdy_i                 (asx_rdy)
        ,.val_o                 (asx_val)
        ,.data_o                (asx_data)
        );

    reg                             asx_val_candidates  [NUM_IDS-1:0];
    reg                             asx_rdy_candidates  [NUM_IDS-1:0];
    reg [`PRGA_ASX_DATA_WIDTH-1:0]  asx_data_candidates [NUM_IDS-1:0];
    reg [ASX_ARB_WIDTH-1:0]         asx_arb, asx_arb_prev;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            asx_arb_prev = ASX_ARB_NONE;
        end else if (asx_rdy_f && asx_val_p) begin
            asx_arb_prev = asx_arb;
        end
    end

    always @* begin
        asx_arb                 = ASX_ARB_NONE;

        case (asx_arb_prev)
            ASX_ARB_NONE,
            ID_R: if (asx_val_candidates[ID_AW]) begin
                asx_arb = ID_AW;
            end else if (asx_val_candidates[ID_AR]) begin
                asx_arb = ID_AR;
            end else if (asx_val_candidates[ID_B]) begin
                asx_arb = ID_B;
            end else if (asx_val_candidates[ID_R]) begin
                asx_arb = ID_R;
            end
            ID_AW: if (asx_val_candidates[ID_AR]) begin
                asx_arb = ID_AR;
            end else if (asx_val_candidates[ID_B]) begin
                asx_arb = ID_B;
            end else if (asx_val_candidates[ID_R]) begin
                asx_arb = ID_R;
            end else if (asx_val_candidates[ID_AW]) begin
                asx_arb = ID_AW;
            end
            ID_AR: if (asx_val_candidates[ID_B]) begin
                asx_arb = ID_B;
            end else if (asx_val_candidates[ID_R]) begin
                asx_arb = ID_R;
            end else if (asx_val_candidates[ID_AW]) begin
                asx_arb = ID_AW;
            end else if (asx_val_candidates[ID_AR]) begin
                asx_arb = ID_AR;
            end
            ID_B: if (asx_val_candidates[ID_R]) begin
                asx_arb = ID_R;
            end else if (asx_val_candidates[ID_AW]) begin
                asx_arb = ID_AW;
            end else if (asx_val_candidates[ID_AR]) begin
                asx_arb = ID_AR;
            end else if (asx_val_candidates[ID_B]) begin
                asx_arb = ID_B;
            end
        endcase
    end

    always @* begin
        case (asx_arb)
            ID_AW, ID_AR, ID_B, ID_R: begin
                asx_val_p = asx_val_candidates[asx_arb];
                asx_data_p = asx_data_candidates[asx_arb];
            end
            default: begin
                asx_val_p = 1'b0;
                asx_data_p = {`PRGA_ASX_DATA_WIDTH {1'b0} };
            end
        endcase

        asx_rdy_candidates[ID_AW] = asx_arb == ID_AW && asx_rdy_f;
        asx_rdy_candidates[ID_AR] = asx_arb == ID_AR && asx_rdy_f;
        asx_rdy_candidates[ID_B] = asx_arb == ID_B && asx_rdy_f;
        asx_rdy_candidates[ID_R] = asx_arb == ID_R && asx_rdy_f;
    end

    // =======================================================================
    // -- Buffer SAX Messages ------------------------------------------------
    // =======================================================================
    reg                                 sax_rdy_p;
    wire                                sax_val_f;
    wire [`PRGA_SAX_DATA_WIDTH-1:0]     sax_data_f;

    prga_valrdy_buf #(
        .REGISTERED             (1)
        ,.DECOUPLED             (0)
        ,.DATA_WIDTH            (`PRGA_SAX_DATA_WIDTH)
    ) i_buf_sax (
        .clk            (clk)
        ,.rst           (~(rst_n && app_en))
        ,.rdy_o         (sax_rdy)
        ,.val_i         (sax_val)
        ,.data_i        (sax_data)
        ,.rdy_i         (sax_rdy_p)
        ,.val_o         (sax_val_f)
        ,.data_o        (sax_data_f)
        );

    wire [`PRGA_SAX_MSGTYPE_WIDTH-1:0]      sax_msgtype_f;
    wire [`PRGA_CCM_THREADID_WIDTH-1:0]     sax_id_f;
    reg  [`PRGA_CCM_CACHELINE_WIDTH-1:0]    sax_payload_f;

    assign sax_msgtype_f = sax_data_f[`PRGA_SAX_MSGTYPE_INDEX];
    assign sax_id_f = sax_data_f[`PRGA_SAX_THREADID_INDEX];

    always @* begin
        if (SWAP_ENDIANNESS) begin
            sax_payload_f = {
                sax_data_f[ 64+:8], sax_data_f[ 72+:8], sax_data_f[ 80+:8], sax_data_f[ 88+:8],
                sax_data_f[ 96+:8], sax_data_f[104+:8], sax_data_f[112+:8], sax_data_f[120+:8],
                sax_data_f[  0+:8], sax_data_f[  8+:8], sax_data_f[ 16+:8], sax_data_f[ 24+:8],
                sax_data_f[ 32+:8], sax_data_f[ 40+:8], sax_data_f[ 48+:8], sax_data_f[ 56+:8]
            };
        end else begin
            sax_payload_f = sax_data_f[0+:`PRGA_CCM_CACHELINE_WIDTH];
        end
    end

    reg     sax_rdy_candidates  [ID_R:ID_B];
    reg     sax_val_candidates  [ID_R:ID_B];

    always @* begin
        sax_val_candidates[ID_B] = 1'b0;
        sax_val_candidates[ID_R] = 1'b0;
        sax_rdy_p = 1'b0;

        if (sax_val_f) begin
            case (sax_msgtype_f)
                `PRGA_SAX_MSGTYPE_CCM_LOAD_ACK,
                `PRGA_SAX_MSGTYPE_CCM_LOAD_NC_ACK,
                `PRGA_SAX_MSGTYPE_CCM_AMO_ACK: begin
                    sax_val_candidates[ID_R] = 1'b1;
                    sax_rdy_p = sax_rdy_candidates[ID_R];
                end
                `PRGA_SAX_MSGTYPE_CCM_STORE_ACK,
                `PRGA_SAX_MSGTYPE_CCM_STORE_NC_ACK: begin
                    sax_val_candidates[ID_B] = 1'b1;
                    sax_rdy_p = sax_rdy_candidates[ID_B];
                end
            endcase
        end
    end

    // =======================================================================
    // -- B Channel Processing -----------------------------------------------
    // =======================================================================
    wire                                sax2b_valid     [`PRGA_AXI4_ID_COUNT-1:0];
    reg                                 sax2b_pending   [`PRGA_AXI4_ID_COUNT-1:0];
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    sax2b_left      [`PRGA_AXI4_ID_COUNT-1:0];

    reg                                 aw2b_valid, aw2b_ack;
    reg [`PRGA_AXI4_ID_WIDTH-1:0]       aw2b_id;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    aw2b_len;

    genvar ib;
    generate for (ib = 0; ib < `PRGA_AXI4_ID_COUNT; ib = ib + 1) begin: gb
        assign sax2b_valid[ib] = sax2b_pending[ib]
                                 && sax_val_candidates[ID_B]
                                 && sax_id_f == ib;

        always @(posedge clk) begin
            if (~(rst_n && app_en)) begin
                sax2b_pending[ib]   <= 1'b0;
                sax2b_left[ib]      <= {`PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            end else if (aw2b_valid && aw2b_ack && aw2b_id == ib) begin
                sax2b_pending[ib]   <= 1'b1;
                sax2b_left[ib]      <= aw2b_len;
            end else if (sax2b_valid[ib] && sax_rdy_candidates[ID_B]) begin
                if (sax2b_left[ib] == 0) begin
                    sax2b_pending[ib]   <= 1'b0;
                end else begin
                    sax2b_left[ib]  <= sax2b_left[ib] - 1;
                end
            end
        end
    end endgenerate

    reg                                 b_trx_timeout_f, b_trx_timer_en, b_trx_timer_rst;
    reg [`PRGA_PROT_TIMER_WIDTH-1:0]    b_trx_timer;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            b_trx_timeout_f <= 1'b0;
            b_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else if (b_trx_timer_rst) begin
            b_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else if (~b_trx_timeout_f && b_trx_timer_en) begin
            b_trx_timer <= b_trx_timer + 1;
            b_trx_timeout_f <= b_trx_timer > timeout_limit_f;
        end
    end

    always @* begin
        report_error[ID_B] = 1'b0;
        bvalid_p = 1'b0;
        bresp_p = `PRGA_AXI4_XRESP_OKAY;
        bid_p = sax_id_f;
        asx_val_candidates[ID_B] = 1'b0;
        asx_data_candidates[ID_B] = {`PRGA_ASX_DATA_WIDTH {1'b0} };
        sax_rdy_candidates[ID_B] = 1'b0;
        aw2b_ack = ~sax2b_pending[aw2b_id];
        b_trx_timer_en = 1'b0;
        b_trx_timer_rst = 1'b1;

        if (sax2b_valid[sax_id_f]) begin
            if (sax2b_left[sax_id_f] == 0) begin
                b_trx_timer_en = 1'b1;
                b_trx_timer_rst = 1'b0;

                if (b_trx_timeout_f) begin
                    asx_val_candidates[ID_B] = 1'b1;
                    asx_data_candidates[ID_B][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_B][`PRGA_EFLAGS_CCM_TIMEOUT] = 1'b1;

                    if (asx_rdy_candidates[ID_B]) begin
                        report_error[ID_B] = 1'b1;
                    end
                end else begin
                    bvalid_p = 1'b1;

                    if (bready_f) begin
                        sax_rdy_candidates[ID_B] = 1'b1;
                        b_trx_timer_en = 1'b0;
                        b_trx_timer_rst = 1'b1;
                    end
                end
            end else begin
                sax_rdy_candidates[ID_B] = 1'b1;
            end
        end
    end

    // =======================================================================
    // -- AW & W Channel Processing ------------------------------------------
    // =======================================================================
    localparam  AW_STATE_WIDTH  = 2;
    localparam  AW_STATE_RST    = 2'h0,
                AW_STATE_IDLE   = 2'h1,
                AW_STATE_DATA   = 2'h2,
                AW_STATE_ERR    = 2'h3;

    reg [AW_STATE_WIDTH-1:0]            aw_state, aw_state_next;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    aw_trx_cnt, aw_trx_cnt_next;
    reg [`PRGA_CCM_ADDR_WIDTH-1:0]      aw_trx_addr, aw_trx_addr_next;
    reg                                 aw_trx_timeout_f, aw_trx_timer_en, aw_trx_timer_rst;
    reg [`PRGA_PROT_TIMER_WIDTH-1:0]    aw_trx_timer;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            aw_state <= AW_STATE_RST;
            aw_trx_cnt <= {`PRGA_AXI4_AXLEN_WIDTH {1'b0} };
            aw_trx_addr <= {`PRGA_CCM_ADDR_WIDTH {1'b0} };
            aw_trx_timeout_f <= 1'b0;
            aw_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else begin
            aw_state <= aw_state_next;
            aw_trx_cnt <= aw_trx_cnt_next;
            aw_trx_addr <= aw_trx_addr_next;

            if (aw_trx_timer_rst) begin
                aw_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
            end else if (~aw_trx_timeout_f && aw_trx_timer_en) begin
                aw_trx_timer <= aw_trx_timer + 1;
                aw_trx_timeout_f <= aw_trx_timer > timeout_limit_f;
            end
        end
    end

    reg [`PRGA_CCM_DATA_WIDTH-1:0]      aw_trx_data;
    reg [`PRGA_CCM_SIZE_WIDTH-1:0]      aw_trx_size;

    //  We don't support arbitrary byte masking. WSTRB must be set for all byte
    //  lanes used. e.g. in a 2B-INCR burst, wstrb must be set in an
    //  8'h03-8'h0c-8'h30-8'hc0 cycle.
    reg [`PRGA_AXI4_DATA_BYTES-1:0]     expected_wstrb;

    always @* begin
        expected_wstrb = {`PRGA_AXI4_DATA_BYTES {1'b0} };
        aw_trx_data = wdata_f;
        aw_trx_size = `PRGA_CCM_SIZE_8B;

        case (awsize_f)
            `PRGA_AXI4_AXSIZE_1B: begin
                aw_trx_size = `PRGA_CCM_SIZE_1B;

                case (aw_trx_addr[2:0])
                    3'h0: begin
                        expected_wstrb = 8'b0000_0001;
                        aw_trx_data = {8 {wdata_f[ 0+: 8]} };
                    end
                    3'h1: begin
                        expected_wstrb = 8'b0000_0010; 
                        aw_trx_data = {8 {wdata_f[ 8+: 8]} };
                    end
                    3'h2: begin
                        expected_wstrb = 8'b0000_0100; 
                        aw_trx_data = {8 {wdata_f[16+: 8]} };
                    end
                    3'h3: begin
                        expected_wstrb = 8'b0000_1000; 
                        aw_trx_data = {8 {wdata_f[24+: 8]} };
                    end
                    3'h4: begin
                        expected_wstrb = 8'b0001_0000; 
                        aw_trx_data = {8 {wdata_f[32+: 8]} };
                    end
                    3'h5: begin
                        expected_wstrb = 8'b0010_0000; 
                        aw_trx_data = {8 {wdata_f[40+: 8]} };
                    end
                    3'h6: begin
                        expected_wstrb = 8'b0100_0000; 
                        aw_trx_data = {8 {wdata_f[48+: 8]} };
                    end
                    3'h7: begin
                        expected_wstrb = 8'b1000_0000; 
                        aw_trx_data = {8 {wdata_f[56+: 8]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_2B: begin
                aw_trx_size = `PRGA_CCM_SIZE_2B;

                case (aw_trx_addr[2:1])
                    2'h0: begin
                        expected_wstrb = 8'b0000_0011;
                        aw_trx_data = {4 {wdata_f[ 0+:16]} };
                    end
                    2'h1: begin
                        expected_wstrb = 8'b0000_1100;
                        aw_trx_data = {4 {wdata_f[16+:16]} };
                    end
                    2'h2: begin
                        expected_wstrb = 8'b0011_0000;
                        aw_trx_data = {4 {wdata_f[32+:16]} };
                    end
                    2'h3: begin
                        expected_wstrb = 8'b1100_0000;
                        aw_trx_data = {4 {wdata_f[48+:16]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_4B: begin
                aw_trx_size = `PRGA_CCM_SIZE_4B;

                case (aw_trx_addr[2])
                    1'b0: begin
                        expected_wstrb = 8'h0f;
                        aw_trx_data = {2 {wdata_f[ 0+:32]} };
                    end
                    1'b1: begin
                        expected_wstrb = 8'hf0;
                        aw_trx_data = {2 {wdata_f[32+:32]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_8B: begin
                aw_trx_size = `PRGA_CCM_SIZE_8B;

                expected_wstrb  = 8'hff;
                aw_trx_data = wdata_f;
            end
        endcase
    end

    always @* begin
        aw2b_valid = 1'b0;
        aw2b_id = awid_f;
        aw2b_len = awlen_f;
        aw_state_next = aw_state;
        aw_trx_cnt_next = aw_trx_cnt;
        aw_trx_addr_next = aw_trx_addr;
        aw_trx_timer_en = 1'b0;
        aw_trx_timer_rst = 1'b1;
        awready_p = 1'b0;
        wready_p = 1'b0;

        asx_val_candidates[ID_AW] = 1'b0;
        asx_data_candidates[ID_AW] = {`PRGA_ASX_DATA_WIDTH {1'b0} };
        report_error[ID_AW] = 1'b0;

        case (aw_state)
            AW_STATE_RST: begin
                aw_state_next = AW_STATE_IDLE;
            end
            AW_STATE_IDLE: if (awvalid_f) begin
                // ECC?
                if (awecc_fail) begin
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_ECC] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end

                // Invalid request?
                else if (awsize_inval) begin
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_INVAL_SIZE] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end

                else if (~(awburst_f == `PRGA_AXI4_AXBURST_FIXED || awburst_f == `PRGA_AXI4_AXBURST_INCR)) begin
                    // only INCR and FIXED burst are supported
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_INVAL_AXI4_TRX] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end

                // Accept AW request. Start processing data
                else begin
                    aw2b_valid = 1'b1;

                    if (aw2b_ack) begin
                        aw_state_next = AW_STATE_DATA;
                        aw_trx_cnt_next = {`PRGA_AXI4_AXLEN_WIDTH {1'b0} };
                        aw_trx_addr_next = awaddr_f;
                    end
                end
            end
            AW_STATE_DATA: if (wvalid_f) begin
                // ECC?
                if (wecc_fail) begin
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_ECC] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end

                // validate transaction: last flag, strb
                else if ((aw_trx_cnt == awlen_f && !wlast_f)
                    || (expected_wstrb != wstrb_f)) begin

                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_INVAL_AXI4_TRX] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end

                // send data
                else begin
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] =
                        (|awcache_f[3:2]) ? `PRGA_ASX_MSGTYPE_CCM_STORE : `PRGA_ASX_MSGTYPE_CCM_STORE_NC;
                    asx_data_candidates[ID_AW][`PRGA_ASX_THREADID_INDEX] = awid_f;
                    asx_data_candidates[ID_AW][`PRGA_ASX_SIZE_INDEX] = aw_trx_size;
                    asx_data_candidates[ID_AW][`PRGA_CCM_DATA_WIDTH+:`PRGA_CCM_ADDR_WIDTH] = aw_trx_addr;
                    
                    if (SWAP_ENDIANNESS) begin
                        asx_data_candidates[ID_AW][0+:`PRGA_CCM_DATA_WIDTH] = {
                            aw_trx_data[ 0+:8], aw_trx_data[ 8+:8], aw_trx_data[16+:8], aw_trx_data[24+:8],
                            aw_trx_data[32+:8], aw_trx_data[40+:8], aw_trx_data[48+:8], aw_trx_data[56+:8]
                        };
                    end else begin
                        asx_data_candidates[ID_AW][0+:`PRGA_CCM_DATA_WIDTH] = aw_trx_data;
                    end

                    if (asx_rdy_candidates[ID_AW]) begin
                        wready_p = 1'b1;

                        // last one?
                        if (aw_trx_cnt == awlen_f) begin
                            awready_p = 1'b1;
                            aw_state_next = AW_STATE_IDLE;
                        end

                        // update counter and address
                        else begin
                            aw_trx_cnt_next = aw_trx_cnt + 1;

                            if (awburst_f == `PRGA_AXI4_AXBURST_INCR) begin
                                case (awsize_f)
                                    `PRGA_AXI4_AXSIZE_1B: aw_trx_addr_next = aw_trx_addr + 1;
                                    `PRGA_AXI4_AXSIZE_2B: aw_trx_addr_next = aw_trx_addr + 2;
                                    `PRGA_AXI4_AXSIZE_4B: aw_trx_addr_next = aw_trx_addr + 4;
                                    `PRGA_AXI4_AXSIZE_8B: aw_trx_addr_next = aw_trx_addr + 8;
                                endcase
                            end
                        end
                    end
                end
            end else begin
                // timer
                aw_trx_timer_en = 1'b1;
                aw_trx_timer_rst = 1'b0;

                if (aw_trx_timeout_f) begin
                    asx_val_candidates[ID_AW] = 1'b1;
                    asx_data_candidates[ID_AW][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AW][`PRGA_EFLAGS_CCM_TIMEOUT] = 1'b1;

                    if (asx_rdy_candidates[ID_AW]) begin
                        report_error[ID_AW] = 1'b1;
                        aw_state_next = AW_STATE_ERR;
                    end
                end
            end
        endcase
    end

    // =======================================================================
    // -- R Channel Processing -----------------------------------------------
    // =======================================================================
    wire                                sax2r_valid     [`PRGA_AXI4_ID_COUNT-1:0];
    reg                                 sax2r_pending   [`PRGA_AXI4_ID_COUNT-1:0];
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    sax2r_left      [`PRGA_AXI4_ID_COUNT-1:0];
    reg [`PRGA_AXI4_AXSIZE_WIDTH-1:0]   sax2r_size      [`PRGA_AXI4_ID_COUNT-1:0];
    reg [`PRGA_AXI4_AXBURST_WIDTH-1:0]  sax2r_burst     [`PRGA_AXI4_ID_COUNT-1:0];
    reg [3:0]                           sax2r_offset    [`PRGA_AXI4_ID_COUNT-1:0];

    reg                                 ar2r_valid, ar2r_ack;

    genvar ir;
    generate for (ir = 0; ir < `PRGA_AXI4_ID_COUNT; ir = ir + 1) begin: gr
        assign sax2r_valid[ir] = sax2r_pending[ir]
                                 && sax_val_candidates[ID_R]
                                 && sax_id_f == ir;

        always @(posedge clk) begin
            if (~(rst_n && app_en)) begin
                sax2r_pending[ir]   <= 1'b0;
                sax2r_left[ir]      <= {`PRGA_AXI4_AXLEN_WIDTH {1'b0} };
                sax2r_size[ir]      <= `PRGA_AXI4_AXSIZE_8B;
                sax2r_burst[ir]     <= `PRGA_AXI4_AXBURST_INCR;
                sax2r_offset[ir]    <= 4'h0;
            end else if (ar2r_valid && ar2r_ack && arid_f == ir) begin
                sax2r_pending[ir]   <= 1'b1;
                sax2r_left[ir]      <= arlen_f;
                sax2r_size[ir]      <= arsize_f;
                sax2r_burst[ir]     <= arburst_f;
                sax2r_offset[ir]    <= araddr_f[3:0];
            end else if (sax2r_valid[ir] && sax_rdy_candidates[ID_R]) begin
                if (sax2r_left[ir] == 0) begin
                    sax2r_pending[ir]   <= 1'b0;
                end else begin
                    sax2r_left[ir]      <= sax2r_left[ir] - 1;

                    if (sax2r_burst[ir] == `PRGA_AXI4_AXBURST_INCR) begin
                        case (sax2r_size[ir])
                            `PRGA_AXI4_AXSIZE_1B: sax2r_offset[ir] <= sax2r_offset[ir] + 1;
                            `PRGA_AXI4_AXSIZE_2B: sax2r_offset[ir] <= sax2r_offset[ir] + 2;
                            `PRGA_AXI4_AXSIZE_4B: sax2r_offset[ir] <= sax2r_offset[ir] + 4;
                            `PRGA_AXI4_AXSIZE_8B: sax2r_offset[ir] <= sax2r_offset[ir] + 8;
                        endcase
                    end
                end
            end
        end
    end endgenerate

    reg                                 r_trx_timeout_f, r_trx_timer_en, r_trx_timer_rst;
    reg [`PRGA_PROT_TIMER_WIDTH-1:0]    r_trx_timer;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            r_trx_timeout_f <= 1'b0;
            r_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else if (r_trx_timer_rst) begin
            r_trx_timer <= {`PRGA_PROT_TIMER_WIDTH {1'b0} };
        end else if (~r_trx_timeout_f && r_trx_timer_en) begin
            r_trx_timer <= r_trx_timer + 1;
            r_trx_timeout_f <= r_trx_timer > timeout_limit_f;
        end
    end

    always @* begin
        rdata_p = sax_payload_f[0 +: `PRGA_AXI4_DATA_WIDTH];

        case (sax2r_size[sax_id_f])
            `PRGA_AXI4_AXSIZE_1B: case (sax2r_offset[sax_id_f][3:0])
                4'd0:   rdata_p = {8 {sax_payload_f[  0+: 8]} };
                4'd1:   rdata_p = {8 {sax_payload_f[  8+: 8]} };
                4'd2:   rdata_p = {8 {sax_payload_f[ 16+: 8]} };
                4'd3:   rdata_p = {8 {sax_payload_f[ 24+: 8]} };
                4'd4:   rdata_p = {8 {sax_payload_f[ 32+: 8]} };
                4'd5:   rdata_p = {8 {sax_payload_f[ 40+: 8]} };
                4'd6:   rdata_p = {8 {sax_payload_f[ 48+: 8]} };
                4'd7:   rdata_p = {8 {sax_payload_f[ 56+: 8]} };
                4'd8:   rdata_p = {8 {sax_payload_f[ 64+: 8]} };
                4'd9:   rdata_p = {8 {sax_payload_f[ 72+: 8]} };
                4'd10:  rdata_p = {8 {sax_payload_f[ 80+: 8]} };
                4'd11:  rdata_p = {8 {sax_payload_f[ 88+: 8]} };
                4'd12:  rdata_p = {8 {sax_payload_f[ 96+: 8]} };
                4'd13:  rdata_p = {8 {sax_payload_f[104+: 8]} };
                4'd14:  rdata_p = {8 {sax_payload_f[112+: 8]} };
                4'd15:  rdata_p = {8 {sax_payload_f[120+: 8]} };
            endcase
            `PRGA_AXI4_AXSIZE_2B: case (sax2r_offset[sax_id_f][3:1])
                3'd0:   rdata_p = {4 {sax_payload_f[  0+:16]} };
                3'd1:   rdata_p = {4 {sax_payload_f[ 16+:16]} };
                3'd2:   rdata_p = {4 {sax_payload_f[ 32+:16]} };
                3'd3:   rdata_p = {4 {sax_payload_f[ 48+:16]} };
                3'd4:   rdata_p = {4 {sax_payload_f[ 64+:16]} };
                3'd5:   rdata_p = {4 {sax_payload_f[ 80+:16]} };
                3'd6:   rdata_p = {4 {sax_payload_f[ 96+:16]} };
                3'd7:   rdata_p = {4 {sax_payload_f[112+:16]} };
            endcase
            `PRGA_AXI4_AXSIZE_4B: case (sax2r_offset[sax_id_f][3:2])
                2'd0:   rdata_p = {2 {sax_payload_f[  0+:32]} };
                2'd1:   rdata_p = {2 {sax_payload_f[ 32+:32]} };
                2'd2:   rdata_p = {2 {sax_payload_f[ 64+:32]} };
                2'd3:   rdata_p = {2 {sax_payload_f[ 96+:32]} };
            endcase
            `PRGA_AXI4_AXSIZE_8B: case (sax2r_offset[sax_id_f][3:3])
                1'd0:   rdata_p = sax_payload_f[ 0+:64];
                1'd1:   rdata_p = sax_payload_f[64+:64];
            endcase
        endcase
    end

    always @* begin
        report_error[ID_R] = 1'b0;
        rvalid_p = 1'b0;
        rresp_p = `PRGA_AXI4_XRESP_OKAY;
        rid_p = sax_id_f;
        rlast_p = sax2r_left[sax_id_f] == 0;
        asx_val_candidates[ID_R] = 1'b0;
        asx_data_candidates[ID_R] = {`PRGA_ASX_DATA_WIDTH {1'b0} };
        sax_rdy_candidates[ID_R] = 1'b0;
        ar2r_ack = ~sax2r_pending[arid_f];
        r_trx_timer_en = 1'b0;
        r_trx_timer_rst = 1'b1;

        if (sax2r_valid[sax_id_f]) begin
            r_trx_timer_en = 1'b1;
            r_trx_timer_rst = 1'b0;

            if (r_trx_timeout_f) begin
                asx_val_candidates[ID_R] = 1'b1;
                asx_data_candidates[ID_R][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                asx_data_candidates[ID_R][`PRGA_EFLAGS_CCM_TIMEOUT] = 1'b1;

                if (asx_rdy_candidates[ID_R]) begin
                    report_error[ID_R] = 1'b1;
                end
            end else begin
                rvalid_p = 1'b1;

                if (rready_f) begin
                    sax_rdy_candidates[ID_R] = 1'b1;
                    r_trx_timer_en = 1'b0;
                    r_trx_timer_rst = 1'b1;
                end
            end
        end
    end

    // =======================================================================
    // -- AR Channel Processing ----------------------------------------------
    // =======================================================================
    localparam  AR_STATE_WIDTH  = 2;
    localparam  AR_STATE_RST    = 2'h0,
                AR_STATE_IDLE   = 2'h1,
                AR_STATE_DATA   = 2'h2,
                AR_STATE_ERR    = 2'h3;

    reg [AR_STATE_WIDTH-1:0]            ar_state, ar_state_next;
    reg [`PRGA_AXI4_AXLEN_WIDTH-1:0]    ar_trx_cnt, ar_trx_cnt_next;
    reg [`PRGA_CCM_ADDR_WIDTH-1:0]      ar_trx_addr, ar_trx_addr_next;

    always @(posedge clk) begin
        if (~(rst_n && app_en)) begin
            ar_state    <= AR_STATE_RST;
            ar_trx_cnt  <= 8'h0;
            ar_trx_addr <= {`PRGA_CCM_ADDR_WIDTH {1'b0} };
        end else begin
            ar_state    <= ar_state_next;
            ar_trx_cnt  <= ar_trx_cnt_next;
            ar_trx_addr <= ar_trx_addr_next;
        end
    end

    reg [`PRGA_CCM_SIZE_WIDTH-1:0]      ar_trx_size;
    reg [`PRGA_CCM_DATA_WIDTH-1:0]      ar_trx_amodata;

    always @* begin
        ar_trx_size = `PRGA_CCM_SIZE_8B;
        ar_trx_amodata = aramodata_f;

        case (arsize_f)
            `PRGA_AXI4_AXSIZE_1B: begin
                ar_trx_size = `PRGA_CCM_SIZE_1B;

                case (ar_trx_addr[2:0])
                    3'h0: begin
                        ar_trx_amodata = {8 {aramodata_f[ 0+: 8]} };
                    end
                    3'h1: begin
                        ar_trx_amodata = {8 {aramodata_f[ 8+: 8]} };
                    end
                    3'h2: begin
                        ar_trx_amodata = {8 {aramodata_f[16+: 8]} };
                    end
                    3'h3: begin
                        ar_trx_amodata = {8 {aramodata_f[24+: 8]} };
                    end
                    3'h4: begin
                        ar_trx_amodata = {8 {aramodata_f[32+: 8]} };
                    end
                    3'h5: begin
                        ar_trx_amodata = {8 {aramodata_f[40+: 8]} };
                    end
                    3'h6: begin
                        ar_trx_amodata = {8 {aramodata_f[48+: 8]} };
                    end
                    3'h7: begin
                        ar_trx_amodata = {8 {aramodata_f[56+: 8]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_2B: begin
                ar_trx_size = `PRGA_CCM_SIZE_2B;

                case (ar_trx_addr[2:1])
                    2'h0: begin
                        ar_trx_amodata = {4 {aramodata_f[ 0+:16]} };
                    end
                    2'h1: begin
                        ar_trx_amodata = {4 {aramodata_f[16+:16]} };
                    end
                    2'h2: begin
                        ar_trx_amodata = {4 {aramodata_f[32+:16]} };
                    end
                    2'h3: begin
                        ar_trx_amodata = {4 {aramodata_f[48+:16]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_4B: begin
                ar_trx_size = `PRGA_CCM_SIZE_4B;

                case (ar_trx_addr[2])
                    1'h0: begin
                        ar_trx_amodata = {2 {aramodata_f[ 0+:32]} };
                    end
                    1'h1: begin
                        ar_trx_amodata = {2 {aramodata_f[32+:32]} };
                    end
                endcase
            end
            `PRGA_AXI4_AXSIZE_8B: begin
                ar_trx_size = `PRGA_CCM_SIZE_8B;
                ar_trx_amodata = aramodata_f;
            end
        endcase
    end

    always @* begin
        report_error[ID_AR] = 1'b0;
        arready_p = 1'b0;
        asx_val_candidates[ID_AR] = 1'b0;
        asx_data_candidates[ID_AR] = {`PRGA_ASX_DATA_WIDTH {1'b0} };
        ar2r_valid = 1'b0;
        ar_state_next = ar_state;
        ar_trx_cnt_next = ar_trx_cnt;
        ar_trx_addr_next = ar_trx_addr;

        case (ar_state)
            AR_STATE_RST: begin
                ar_state_next = AR_STATE_IDLE;
            end
            AR_STATE_IDLE: if (arvalid_f) begin
                // ECC?
                if (arecc_fail) begin
                    asx_val_candidates[ID_AR] = 1'b1;
                    asx_data_candidates[ID_AR][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AR][`PRGA_EFLAGS_CCM_ECC] = 1'b1;

                    if (asx_rdy_candidates[ID_AR]) begin
                        report_error[ID_AR] = 1'b1;
                        ar_state_next = AR_STATE_ERR;
                    end
                end

                // Invalid request?
                else if (arsize_inval) begin
                    asx_val_candidates[ID_AR] = 1'b1;
                    asx_data_candidates[ID_AR][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AR][`PRGA_EFLAGS_CCM_INVAL_SIZE] = 1'b1;

                    if (asx_rdy_candidates[ID_AR]) begin
                        report_error[ID_AR] = 1'b1;
                        ar_state_next = AR_STATE_ERR;
                    end
                end

                else if (aramo_inval) begin
                    asx_val_candidates[ID_AR] = 1'b1;
                    asx_data_candidates[ID_AR][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AR][`PRGA_EFLAGS_CCM_INVAL_AMO_OPCODE] = 1'b1;

                    if (asx_rdy_candidates[ID_AR]) begin
                        report_error[ID_AR] = 1'b1;
                        ar_state_next = AR_STATE_ERR;
                    end
                end

                else if (~(arburst_f == `PRGA_AXI4_AXBURST_FIXED || arburst_f == `PRGA_AXI4_AXBURST_INCR)) begin
                    // only INCR and FIXED burst are supported
                    asx_val_candidates[ID_AR] = 1'b1;
                    asx_data_candidates[ID_AR][`PRGA_ASX_MSGTYPE_INDEX] = `PRGA_ASX_MSGTYPE_ERR;
                    asx_data_candidates[ID_AR][`PRGA_EFLAGS_CCM_INVAL_AXI4_TRX] = 1'b1;

                    if (asx_rdy_candidates[ID_AR]) begin
                        report_error[ID_AR] = 1'b1;
                        ar_state_next = AR_STATE_ERR;
                    end
                end

                // Accept AR request. Start sending requests
                else begin
                    ar2r_valid = 1'b1;

                    if (ar2r_ack) begin
                        ar_state_next = AR_STATE_DATA;
                        ar_trx_cnt_next = {`PRGA_AXI4_AXLEN_WIDTH {1'b0} };
                        ar_trx_addr_next = araddr_f;
                    end
                end
            end
            AR_STATE_DATA: begin
                asx_val_candidates[ID_AR] = 1'b1;
                asx_data_candidates[ID_AR][`PRGA_ASX_MSGTYPE_INDEX] =
                    arlock_f            ? `PRGA_ASX_MSGTYPE_CCM_AMO       :
                    (|arcache_f[3:2])   ? `PRGA_ASX_MSGTYPE_CCM_LOAD      :
                                          `PRGA_ASX_MSGTYPE_CCM_LOAD_NC;
                asx_data_candidates[ID_AR][`PRGA_ASX_THREADID_INDEX] = arid_f;
                asx_data_candidates[ID_AR][`PRGA_ASX_SIZE_INDEX] = ar_trx_size;
                asx_data_candidates[ID_AR][`PRGA_ASX_AMO_OPCODE_INDEX] =
                    arlock_f    ? aramo_f : `PRGA_CCM_AMO_OPCODE_NONE;
                asx_data_candidates[ID_AR][`PRGA_CCM_DATA_WIDTH+:`PRGA_CCM_ADDR_WIDTH] = ar_trx_addr;

                if (SWAP_ENDIANNESS) begin
                    asx_data_candidates[ID_AR][0+:`PRGA_CCM_DATA_WIDTH] = {
                        ar_trx_amodata[ 0+:8], ar_trx_amodata[ 8+:8], ar_trx_amodata[16+:8], ar_trx_amodata[24+:8],
                        ar_trx_amodata[32+:8], ar_trx_amodata[40+:8], ar_trx_amodata[48+:8], ar_trx_amodata[56+:8]
                    };
                end else begin
                    asx_data_candidates[ID_AR][0+:`PRGA_CCM_DATA_WIDTH] = ar_trx_amodata;
                end

                if (asx_rdy_candidates[ID_AR]) begin
                    // last one?
                    if (ar_trx_cnt == arlen_f) begin
                        arready_p = 1'b1;
                        ar_state_next = AR_STATE_IDLE;
                    end

                    // update counter and address
                    else begin
                        ar_trx_cnt_next = ar_trx_cnt + 1;

                        if (arburst_f == `PRGA_AXI4_AXBURST_INCR) begin
                            case (arsize_f)
                                `PRGA_AXI4_AXSIZE_1B: ar_trx_addr_next = ar_trx_addr + 1;
                                `PRGA_AXI4_AXSIZE_2B: ar_trx_addr_next = ar_trx_addr + 2;
                                `PRGA_AXI4_AXSIZE_4B: ar_trx_addr_next = ar_trx_addr + 4;
                                `PRGA_AXI4_AXSIZE_8B: ar_trx_addr_next = ar_trx_addr + 8;
                            endcase
                        end
                    end
                end
            end
        endcase
    end

endmodule
