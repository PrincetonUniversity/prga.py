// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps

/*
* Transducer for OpenPiton TRI protocol.
*/

`include "l15.tmp.h"
`include "prga_system.vh"

`ifdef DEFAULT_NETTYPE_NONE
    `default_nettype none
`endif

module prga_l15_transducer (
    input wire                                  clk,
    input wire                                  rst_n,

    // == Transducer -> L15 ==================================================
    // Outputs
    output reg                                  transducer_l15_val,
    output reg [4:0]                            transducer_l15_rqtype,
    output reg [`L15_THREADID_MASK]             transducer_l15_threadid,
    output reg                                  transducer_l15_nc,
    output reg [2:0]                            transducer_l15_size,
    output reg [39:0]                           transducer_l15_address,
    output reg [63:0]                           transducer_l15_data,

    // ACK
    input wire                                  l15_transducer_ack,
    input wire                                  l15_transducer_header_ack,

    // Unused outputs
    output reg [`L15_AMO_OP_WIDTH-1:0]          transducer_l15_amo_op,
    output reg [1:0]                            transducer_l15_l1rplway,
    output reg                                  transducer_l15_prefetch,
    output reg                                  transducer_l15_invalidate_cacheline,    // L1 invalidation
    output reg                                  transducer_l15_blockstore,
    output reg                                  transducer_l15_blockinitstore,
    output reg [63:0]                           transducer_l15_data_next_entry, // unused (for CAS only)
    output reg [`TLB_CSM_WIDTH-1:0]             transducer_l15_csm_data,        // unused (for CDR only)

    // == L15 -> Transducer ==================================================
    // Inputs
    input wire                                  l15_transducer_val,
    input wire [3:0]                            l15_transducer_returntype,
    input wire [15:4]                           l15_transducer_inval_address_15_4,
    input wire                                  l15_transducer_noncacheable,
    input wire [`L15_THREADID_MASK]             l15_transducer_threadid,
    input wire [63:0]                           l15_transducer_data_0,
    input wire [63:0]                           l15_transducer_data_1,

    // ACK: Must be asserted in the same cycle when `l15_transducer_val` is asserted
    output reg                                  transducer_l15_req_ack,

    // == Transducer -> SAX ==================================================
    input wire                                  sax_rdy,
    output reg                                  sax_val,
    output reg [`PRGA_SAX_DATA_WIDTH-1:0]       sax_data,

    // == ASX -> Transducer ==================================================
    output reg                                  asx_rdy,
    input wire                                  asx_val,
    input wire [`PRGA_ASX_DATA_WIDTH-1:0]       asx_data
    );

    // =======================================================================
    // -- Forward Declarations -----------------------------------------------
    // =======================================================================

    // == MSHR ==
    reg [`L15_THREAD_ARRAY_MASK]    load_mshr, allocate_load_mshr, deallocate_load_mshr;
    reg [`L15_THREAD_ARRAY_MASK]    store_mshr, allocate_store_mshr, deallocate_store_mshr;

    always @(posedge clk) begin
        if (~rst_n) begin
            load_mshr   <= {`L15_NUM_THREADS{1'b0} };
            store_mshr  <= {`L15_NUM_THREADS{1'b0} };
        end else begin
            load_mshr   <= ~deallocate_load_mshr & (load_mshr | allocate_load_mshr);
            store_mshr  <= ~deallocate_store_mshr & (store_mshr | allocate_store_mshr);
        end
    end

    // =======================================================================
    // -- Handle ASX Requests ------------------------------------------------
    // =======================================================================

    // == Register ASX Output ==
    reg                             asx_val_f, asx_stall;
    reg [`PRGA_ASX_DATA_WIDTH-1:0]  asx_data_f;

    always @(posedge clk) begin
        if (~rst_n) begin
            asx_val_f   <= 1'b0;
            asx_data_f  <= {`PRGA_ASX_DATA_WIDTH {1'b0} };
        end else if (asx_val && asx_rdy) begin
            asx_val_f   <= 1'b1;
            asx_data_f  <= asx_data;
        end else if (~asx_stall) begin
            asx_val_f   <= 1'b0;
        end
    end

    always @* begin
        asx_rdy = ~asx_val_f || ~asx_stall;
    end

    // == Send L15 Request ==
    reg                             transducer_l15_stall, l15_transducer_header_ack_pending;
    reg                             transducer_l15_val_next;
    reg [4:0]                       transducer_l15_rqtype_next;
    reg                             transducer_l15_nc_next;
    reg [2:0]                       transducer_l15_size_next;
    reg [`L15_THREADID_MASK]        transducer_l15_threadid_next;
    reg [39:0]                      transducer_l15_address_next;
    reg [63:0]                      transducer_l15_data_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            l15_transducer_header_ack_pending   <= 1'b0;

            transducer_l15_val          <= 1'b0;
            transducer_l15_rqtype       <= 5'b0;
            transducer_l15_threadid     <= {`L15_THREADID_WIDTH {1'b0} };
            transducer_l15_nc           <= 1'b0;
            transducer_l15_size         <= 3'b0;
            transducer_l15_address      <= 40'b0;
            transducer_l15_data         <= 64'b0;
        end else if (~transducer_l15_stall) begin
            l15_transducer_header_ack_pending   <= transducer_l15_val_next;

            transducer_l15_val          <= transducer_l15_val_next;
            transducer_l15_rqtype       <= transducer_l15_rqtype_next;
            transducer_l15_threadid     <= transducer_l15_threadid_next;
            transducer_l15_nc           <= transducer_l15_nc_next;
            transducer_l15_size         <= transducer_l15_size_next;
            transducer_l15_address      <= transducer_l15_address_next;
            transducer_l15_data         <= transducer_l15_data_next;
        end else begin
            if (transducer_l15_val && l15_transducer_ack) begin
                transducer_l15_val <= 1'b0;
            end

            if (l15_transducer_header_ack_pending && l15_transducer_header_ack) begin
                l15_transducer_header_ack_pending <= 1'b0;
            end
        end
    end

    always @* begin
        transducer_l15_stall = (transducer_l15_val && ~l15_transducer_ack) ||
                               (l15_transducer_header_ack_pending && ~l15_transducer_header_ack);

        // Tie unused outputs to constant low
        transducer_l15_amo_op = `L15_AMO_OP_NONE;
        transducer_l15_l1rplway = 2'b0;     // no L1 cache
        transducer_l15_prefetch = 1'b0;
        transducer_l15_invalidate_cacheline = 1'b0;
        transducer_l15_blockstore = 1'b0;
        transducer_l15_blockinitstore = 1'b0;
        transducer_l15_data_next_entry = 64'b0;
        transducer_l15_csm_data = {`TLB_CSM_WIDTH{1'b0} };
    end

    // == Request State Machine ==
    localparam  ST_REQ_RST      = 1'h0,
                ST_REQ_ACTIVE   = 1'h1;
    
    reg [0:0] req_state, req_state_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            req_state   <= ST_REQ_RST;
        end else begin
            req_state   <= req_state_next;
        end
    end

    always @* begin
        req_state_next = req_state;
        asx_stall = 1'b1;
        allocate_load_mshr = {`L15_NUM_THREADS{1'b0} };
        allocate_store_mshr = {`L15_NUM_THREADS{1'b0} };
        transducer_l15_val_next = 1'b0;
        transducer_l15_rqtype_next = transducer_l15_rqtype;
        transducer_l15_threadid_next = transducer_l15_threadid;
        transducer_l15_nc_next = transducer_l15_nc;
        transducer_l15_size_next = transducer_l15_size;
        transducer_l15_address_next = transducer_l15_address;
        transducer_l15_data_next = transducer_l15_data;

        case (req_state)
            ST_REQ_RST: begin
                req_state_next = ST_REQ_ACTIVE;
            end
            ST_REQ_ACTIVE: if (asx_val_f) begin
                case (asx_data_f[`PRGA_ASX_MSGTYPE_INDEX])
                    `PRGA_ASX_MSGTYPE_CCM_LOAD,
                    `PRGA_ASX_MSGTYPE_CCM_LOAD_NC: begin
                        transducer_l15_rqtype_next = `PCX_REQTYPE_LOAD;
                        transducer_l15_size_next = asx_data_f[`PRGA_ASX_SIZE_INDEX];
                        transducer_l15_nc_next = asx_data_f[`PRGA_ASX_MSGTYPE_INDEX] == `PRGA_ASX_MSGTYPE_CCM_LOAD_NC;
                        transducer_l15_address_next = asx_data_f[`PRGA_CCM_DATA_WIDTH+:`PRGA_CCM_ADDR_WIDTH];
                        transducer_l15_data_next = {`PRGA_CCM_DATA_WIDTH {1'b0} };

                        allocate_load_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] = ~transducer_l15_stall;
                        transducer_l15_val_next = (~load_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] ||
                                                  deallocate_load_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]]);
                        asx_stall = (transducer_l15_stall || (load_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] &&
                                    ~deallocate_load_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]]));
                    end
                    `PRGA_ASX_MSGTYPE_CCM_STORE,
                    `PRGA_ASX_MSGTYPE_CCM_STORE_NC: begin
                        transducer_l15_rqtype_next = `PCX_REQTYPE_STORE;
                        transducer_l15_size_next = asx_data_f[`PRGA_ASX_SIZE_INDEX];
                        transducer_l15_nc_next = asx_data_f[`PRGA_ASX_MSGTYPE_INDEX] == `PRGA_ASX_MSGTYPE_CCM_STORE_NC;
                        transducer_l15_address_next = asx_data_f[`PRGA_CCM_DATA_WIDTH+:`PRGA_CCM_ADDR_WIDTH];
                        transducer_l15_data_next = asx_data_f[0+:`PRGA_CCM_DATA_WIDTH];

                        allocate_store_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] = ~transducer_l15_stall;
                        transducer_l15_val_next = (~store_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] ||
                                                  deallocate_store_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]]);
                        asx_stall = (transducer_l15_stall || (store_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]] &&
                                    ~deallocate_store_mshr[asx_data_f[`PRGA_ASX_THREAD_INDEX]]));
                    end
                    default: begin
                        // TODO: remove this ignorance of error messages. They
                        // should be routed somewhere else in the CDC crossbar
                        asx_stall = 1'b0;
                    end
                endcase
            end
        endcase
    end

    // =======================================================================
    // -- Send Reponses/Invalidations ----------------------------------------
    // =======================================================================

    // Response State Machine    
    localparam  ST_RESP_RST         = 1'h0,
                ST_RESP_ACTIVE      = 1'h1;

    reg [0:0] resp_state, resp_state_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            resp_state  <= ST_RESP_RST;
        end else begin
            resp_state  <= resp_state_next;
        end
    end

    always @* begin
        resp_state_next = resp_state;
        transducer_l15_req_ack = 1'b0;
        deallocate_load_mshr = {`L15_NUM_THREADS{1'b0} };
        deallocate_store_mshr = {`L15_NUM_THREADS{1'b0} };
        sax_val = 1'b0;
        sax_data = {`PRGA_SAX_DATA_WIDTH {1'b0} };

        case (resp_state)
            ST_RESP_RST: begin
                resp_state_next = ST_RESP_ACTIVE;
            end
            ST_RESP_ACTIVE: if (l15_transducer_val) begin
                case (l15_transducer_returntype)
                    `CPX_RESTYPE_LOAD: begin
                        sax_val = 1'b1;
                        sax_data[`PRGA_SAX_THREAD_INDEX] = l15_transducer_threadid;
                        sax_data[0+:`PRGA_CCM_CACHELINE_WIDTH] = {l15_transducer_data_1, l15_transducer_data_0};

                        if (l15_transducer_noncacheable) begin
                            sax_data[`PRGA_SAX_MSGTYPE_INDEX] = `PRGA_SAX_MSGTYPE_CCM_LOAD_NC_ACK;
                        end else begin
                            sax_data[`PRGA_SAX_MSGTYPE_INDEX] = `PRGA_SAX_MSGTYPE_CCM_LOAD_ACK;
                        end

                        if (sax_rdy) begin
                            deallocate_load_mshr[l15_transducer_threadid] = 1'b1;
                            transducer_l15_req_ack = 1'b1;
                        end
                    end
                    `CPX_RESTYPE_STORE_ACK: begin
                        sax_val = 1'b1;
                        sax_data[`PRGA_SAX_THREAD_INDEX] = l15_transducer_threadid;

                        if (l15_transducer_noncacheable) begin
                            sax_data[`PRGA_SAX_MSGTYPE_INDEX] = `PRGA_SAX_MSGTYPE_CCM_STORE_NC_ACK;
                        end else begin
                            sax_data[`PRGA_SAX_MSGTYPE_INDEX] = `PRGA_SAX_MSGTYPE_CCM_STORE_ACK;
                        end

                        if (sax_rdy) begin
                            deallocate_store_mshr[l15_transducer_threadid] = 1'b1;
                            transducer_l15_req_ack = 1'b1;
                        end
                    end
                    default: begin
                        // TODO
                        transducer_l15_req_ack = 1'b1;
                    end
                endcase
            end
        endcase
    end

endmodule
