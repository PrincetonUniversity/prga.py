// Automatically generated by PRGA's RTL generator
{%- macro onehot(width, encoded) -%}
    {{ width }}'b{% for i in range(width) %}{% if i == encoded %}1{% else %}0{% endif %}{% endfor %}
{%- endmacro %}
module fraclutram6 (
    // user-accessible ports
    input wire [0:0] clk,
    input wire [5:0] in,    // LUT inputs or RAM read address
    input wire [5:0] wa,    // RAM write address
    output reg [0:0] o6,    // LUT6, RAM64X1 & SR64X1 async read out, RAM32X2 & SR32X2 LSB async read out
    output reg [0:0] o5,    // LUT5 async read out, RAM32X2 & SR32X2 MSB async read out
    input wire [0:0] di0,   // RAM64X1 & SR64X1 write data, RAM32X2 & SR32X2 LSB write data
    input wire [0:0] di1,   // RAM32X2 & SR32X2 MSB write data
    input wire [0:0] we,    // RAM write enable, shift register endable
    output reg [0:0] so0,   // SR64X1 LSB last bit output
    output reg [0:0] so1,   // SR32X2 MSB last bit output

    // config ports
    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_e,
    input wire [0:0] cfg_we,
    input wire [0:0] cfg_i,
    output reg [0:0] cfg_o
    );

    // mode enum
    localparam MODE_LUT6X1      = 3'd0;
    localparam MODE_LUT5X2      = 3'd1;
    localparam MODE_SR64X1      = 3'd2;
    localparam MODE_SR32X2      = 3'd3;
    localparam MODE_SPRAM64X1   = 3'd4;
    localparam MODE_SPRAM32X2   = 3'd5;
    localparam MODE_DPRAM64X1   = 3'd6;
    localparam MODE_DPRAM32X2   = 3'd7;

    // prog bits
    reg [63:0] data;
    reg [2:0] mode;

    // internal clock
    wire internal_clk;
    assign internal_clk = cfg_e ? cfg_clk : clk;

    // lut5 output
    reg [1:0] internal_lut5;
    {%- for i in range(2) %}
    always @* begin
        case (in[4:0])  // synopsys infer_mux
            {%- for j in range(32) %}
            32'd{{ j }}: internal_lut5[{{ i }}] = data[{{ 32 * i + j }}];
            {%- endfor %}
        endcase
    end
    {%- endfor %}

    // combinational outputs
    always @* begin
        o5 = internal_lut5[1];
        o6 = internal_lut5[0];
        so0 = data[31];
        so1 = data[63];
        cfg_o = mode[2];
        case (mode)
            MODE_LUT6X1,
            MODE_SR64X1,
            MODE_DPRAM64X1,
            MODE_SPRAM64X1: begin
                case (in[5])
                    1'b0: begin
                        o6 = internal_lut5[0];
                    end
                    1'b1: begin
                        o6 = internal_lut5[1];
                    end
                endcase
            end
        endcase
    end

    always @(posedge internal_clk) begin
        if (cfg_e && cfg_we) begin  // configuring
            {mode, data} <= {mode, data, cfg_i};
        end else if (we) begin      // running implemented design
            case (mode)
                MODE_SR64X1: begin
                    data <= {data, di0};
                end
                MODE_SR32X2: begin
                    data[63:32] <= {data[63:32], di1};
                    data[31:0] <= {data[31:0], di0};
                end
                MODE_SPRAM64X1: begin
                    data[in] <= di0;
                end
                MODE_SPRAM32X2: begin
                    data[{1'b1, in[4:0]}] <= di1;
                    data[{1'b0, in[4:0]}] <= di0;
                end
                MODE_DPRAM64X1: begin
                    data[wa] <= di0;
                end
                MODE_DPRAM32X2: begin
                    data[{1'b1, wa[4:0]}] <= di1;
                    data[{1'b0, wa[4:0]}] <= di0;
                end
            endcase
        end
    end

endmodule
