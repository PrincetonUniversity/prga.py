// Automatically generated by PRGA's RTL generator
{%- set width = module.all_ports.cfg_pkt_data_i|length %}
module {{ module.name }} (
    input wire [0:0] cfg_clk,
    input wire [0:0] cfg_e,

    input wire [0:0] cfg_pkt_val_i,
    input wire [{{ width - 1 }}:0] cfg_pkt_data_i,

    output reg [0:0] cfg_pkt_val_o,
    output reg [{{ width - 1 }}:0] cfg_pkt_data_o,

    output reg [0:0] cfg_we, 
    output reg [{{ width - 1 }}:0] cfg_dout,
    input wire [{{ width - 1 }}:0] cfg_din
    );

    // ============================================================
    // Packet format:
    // ============================================================
    //  Header: 16 bits + [optional] 16 bits + [optional] 16 bits
    //       8b: MAGIC NUMBER FOR START OF PACKET
    //       8b: MESSAGE TYPE
    //      16b: [optional] HOP COUNT (minus 1 per controller, consumed where it reaches zero)
    //                  - for DATA, DATA_CHECK_HOC messages only
    //      16b: [optional] PAYLOAD SIZE (#bits - 1 excluding header)
    //                  - for DATA, DATA_CHECK_HOC messages only
    //  Payload: PAYLOAD bits for DATA message types

    localparam  CFG_WIDTH = {{ width }};        // configuration chain width
    localparam  MAGIC_SOP = 8'd{{ module.magic_sop }};      // magic number for start of packet

    localparam  MSG_TYPE_CFG_DATA = 8'h00,
                MSG_TYPE_CFG_DATA_CHECK_HOC = 8'h01,        // check Head Of Config (32 bit magic number)
                MSG_TYPE_EOP = 8'hFF,                       // end of programming
                MSG_TYPE_ERROR_HOC_MISMATCH = 8'h80,        // HOC mismatch
                MSG_TYPE_ERROR_SOP_MISMATCH = 8'h81,        // SOP mismatch when waiting for the next packet
                MSG_TYPE_ERROR_UNKNOWN_STATE = 8'h82;       // FSM trapped in an unknown state

    localparam  ST_IDLE                         = 4'h0,     // waiting for SOP MAGIC NUMBER
                ST_DATA_CHECK_HOC_HEADER        = 4'h1,     // reading the header of a DATA_CHECK_HOC message
                ST_DATA_HEADER                  = 4'h2,     // reading the header of a DATA message
                ST_DATA_CHECK_HOC               = 4'h3,     // processing payload of a DATA_CHECK_HOC message
                ST_DATA                         = 4'h4,     // processing payload of a DATA message
                ST_CHECK_HOC                    = 4'h5,     // checking HOC
                ST_PASSTHRU                     = 4'h6,     // processing a message passing through
                ST_PASSTHRU_WITH_PAYLOAD_HEADER = 4'h7,     // reading the header of a pass-thru message
                ST_FLUSH                        = 4'h8,     // flush buffer
                ST_TRAP                         = 4'h9,     // trapped after sending an error message
                ST_PASSTHRU_ERROR               = 4'hA;     // got an error message, transition to trap state

    // ============================================================
    // Phit Buffer
    // ============================================================
    // registers
    reg [{{ 32 // width - 1 }}:0] val;          // pipelined valid signal
    reg [31:0] buffer;                          // phits buffer

    // wires
    reg drain_buffer;                           // allow the first phit in buffer to leave at the upcoming rising edge
    reg en_output;                              // set `cfg_pkt_val_o` at the upcoming rising edge
    reg [31:0] buffer_next;                     // value to be used to update `buffer` (only used when `drain_buffer` is set)

    always @(posedge cfg_clk) begin
        if (~cfg_e) begin
            val <= {{ 32 // width }}'b0;
            buffer <= 32'b0;
            cfg_pkt_val_o <= 1'b0;
            cfg_pkt_data_o <= {{ width }}'b0;
        end else begin
            if (drain_buffer) begin
                buffer <= {{ '{' -}} buffer_next, cfg_pkt_data_i {{- '}' }};
                val <= {{ '{' -}} val, cfg_pkt_val_i {{- '}' }};
            end else begin
                {%- for i in range(1, 32 // width) %}
                if (~&val[{{ 32 // width - 1 }}:{{ i }}]) begin
                    buffer[{{ i * width }} +: CFG_WIDTH] <= buffer[{{ (i - 1) * width }} +: CFG_WIDTH];
                    val[{{ i }}] <= val[{{ i - 1 }}];
                end
                {%- endfor %}

                buffer[0 +: CFG_WIDTH] <= cfg_pkt_data_i;
                val[0] <= cfg_pkt_val_i;

                {#
                if (~val[{{ 32 // width - 1 }}]) begin
                    buffer[31 -: CFG_WIDTH] <= cfg_pkt_data_i;
                    val[{{ 32 // width - 1 }}] <= cfg_pkt_val_i;
                end
                {%- for i in reversed(range(32 // width - 1)) %}
                else if (~val[{{ i }}] && (&val[{{ 32 // width - 1 }}:{{ i + 1 }}])) begin
                    buffer[{{ i * width }} +: CFG_WIDTH] <= cfg_pkt_data_i;
                    val[{{ i }}] <= cfg_pkt_val_i;
                end
                #}
            end

            cfg_pkt_val_o <= en_output;
            cfg_pkt_data_o <= buffer_next[31 -: CFG_WIDTH];
        end
    end

    always @* begin
        #1;
        cfg_dout = buffer[0 +: CFG_WIDTH];
    end

    // ============================================================
    // FSM and Control Logic
    // ============================================================
    // registers
    reg [16:0] bit_count;                       // multi-purpose bit count
    reg [31:0] hoc;                             // head of config
    reg [3:0] state;

    // wires
    reg reset_bit_count;
    reg [16:0] bit_count_reset_value;
    reg [3:0] state_next;

    always @(posedge cfg_clk) begin
        if (~cfg_e) begin
            bit_count <= 16'b0;
            state <= ST_IDLE;
        end else begin
            if (reset_bit_count) begin
                if (drain_buffer) begin
                    bit_count <= bit_count_reset_value - CFG_WIDTH; // the first phit passes thru when this gets updated
                end else begin
                    bit_count <= bit_count_reset_value;             // the first phit is not ready when this gets updated
                end
            end else if (drain_buffer) begin
                bit_count <= bit_count - CFG_WIDTH;
            end

            state <= state_next;
        end
    end

    always @(posedge cfg_clk) begin
        if (cfg_we) begin
            hoc <= {{ '{' -}} hoc, cfg_din {{- '}' }};
        end
    end

    always @* begin
        #1;

        state_next = state;
        drain_buffer = 1'b0;
        en_output = 1'b0;
        buffer_next = buffer;
        reset_bit_count = 1'b0;
        bit_count_reset_value = 17'b0;
        cfg_we = 1'b0;

        case (state)
            ST_IDLE: begin
                if (&val[{{ 32 // width - 1 }}:{{ 16 // width }}]) begin    // high 16 bits in buffer are valid
                    if (buffer[24  +: 8] == MAGIC_SOP) begin                // SOP magic number matches
                        case (buffer[16 +: 8])
                            MSG_TYPE_EOP: begin                 // end of programming
                                drain_buffer = 1'b1;
                                en_output = 1'b1;
                                bit_count_reset_value = 17'd16;
                                reset_bit_count = 1'b1;
                                state_next = ST_PASSTHRU;
                            end
                            MSG_TYPE_ERROR_HOC_MISMATCH,
                            MSG_TYPE_ERROR_SOP_MISMATCH,
                            MSG_TYPE_ERROR_UNKNOWN_STATE: begin // error
                                drain_buffer = 1'b1;
                                en_output = 1'b1;
                                bit_count_reset_value = 17'd16;
                                reset_bit_count = 1'b1;
                                state_next = ST_PASSTHRU_ERROR;
                            end
                            MSG_TYPE_CFG_DATA,
                            MSG_TYPE_CFG_DATA_CHECK_HOC: begin
                                if (&val[{{ 16 // width - 1 }}:0]) begin    // low 16 bits in buffer are also valid
                                    if (buffer[15:0] == 0) begin    // this packet is detined here
                                        drain_buffer = 1'b1;        // drain buffer but don't enable output
                                        bit_count_reset_value = 17'd16;     // wait until we know payload size
                                        reset_bit_count = 1'b1;

                                        if (buffer[16 +: 8] == MSG_TYPE_CFG_DATA) begin
                                            state_next = ST_DATA_HEADER;
                                        end else begin
                                            state_next = ST_DATA_CHECK_HOC_HEADER;
                                        end
                                    end else begin                  // this packet is for someone after me
                                        drain_buffer = 1'b1;
                                        en_output = 1'b1;
                                        buffer_next = buffer - 1;
                                        bit_count_reset_value = 17'd16;     // wait until we know payload size
                                        reset_bit_count = 1'b1;
                                        state_next = ST_PASSTHRU_WITH_PAYLOAD_HEADER;
                                    end
                                end
                            end
                        endcase
                    end else begin                                          // SOP magic number mismatch
                        drain_buffer = 1'b1;
                        en_output = 1'b1;
                        buffer_next = {{ '{' -}} MAGIC_SOP, MSG_TYPE_ERROR_SOP_MISMATCH, 16'h0 {{- '}' }};
                        bit_count_reset_value = 17'd16;
                        reset_bit_count = 1'b1;
                        state_next = ST_PASSTHRU_ERROR;
                    end
                end
            end
            ST_PASSTHRU: begin
                if (val[{{ 32 // width - 1 }}]) begin                       // first phit is valid. let it pass thru
                    drain_buffer = 1'b1;
                    en_output = 1'b1;

                    if (bit_count == CFG_WIDTH) begin       // jump back to IDLE when the last phit leaves the buffer
                        state_next = ST_IDLE;
                    end
                end
            end
            ST_PASSTHRU_ERROR: begin
                if (val[{{ 32 // width - 1 }}]) begin                       // first phit is valid. let it pass thru
                    drain_buffer = 1'b1;
                    en_output = 1'b1;

                    if (bit_count == CFG_WIDTH) begin       // jump to TRAP when the last phit leaves the buffer
                        state_next = ST_TRAP;
                    end
                end
            end
            ST_PASSTHRU_WITH_PAYLOAD_HEADER: begin
                if (&val) begin
                    drain_buffer = 1'b1;
                    en_output = 1'b1;

                    if (bit_count == 0) begin               // first 16 bits of the header has already passed thru
                        bit_count_reset_value = buffer[15:0] + 33;
                        reset_bit_count = 1'b1;
                        state_next = ST_PASSTHRU;
                    end
                end
            end
            ST_DATA_HEADER: begin
                if (&val) begin
                    drain_buffer = 1'b1;

                    if (bit_count == 0) begin
                        bit_count_reset_value = buffer[15:0] + 33;
                        reset_bit_count = 1'b1;
                        state_next = ST_DATA;
                    end
                end
            end
            ST_DATA_CHECK_HOC_HEADER: begin
                if (&val) begin
                    drain_buffer = 1'b1;

                    if (bit_count == 0) begin
                        bit_count_reset_value = buffer[15:0] + 33;
                        reset_bit_count = 1'b1;
                        state_next = ST_DATA_CHECK_HOC;
                    end
                end
            end
            ST_DATA: begin
                if (&val) begin
                    drain_buffer = 1'b1;
                    cfg_we = 1'b1;

                    if (bit_count == 32) begin
                        state_next = ST_FLUSH;
                    end
                end
            end
            ST_DATA_CHECK_HOC: begin
                if (&val) begin
                    drain_buffer = 1'b1;
                    cfg_we = 1'b1;

                    if (bit_count == 64) begin
                        state_next = ST_CHECK_HOC;
                    end
                end
            end
            ST_CHECK_HOC: begin
                if (&val) begin
                    drain_buffer = 1'b1;

                    if (bit_count == 32) begin
                        if (hoc == buffer) begin            // config successful!
                            state_next = ST_FLUSH;
                        end else begin                      // HOC mismatch
                            en_output = 1'b1;
                            buffer_next = {{ '{' -}} MAGIC_SOP, MSG_TYPE_ERROR_HOC_MISMATCH, 16'h0 {{- '}' }};
                            bit_count_reset_value = 17'd16;
                            reset_bit_count = 1'b1;
                            state_next = ST_PASSTHRU_ERROR;
                        end
                    end
                end
            end
            ST_FLUSH: begin
                if (val[{{ 32 // width - 1 }}]) begin
                    drain_buffer = 1'b1;

                    if (bit_count == CFG_WIDTH) begin       // jump back to IDLE when the last phit leaves the buffer
                        state_next = ST_IDLE;
                    end
                end
            end
            ST_TRAP: begin
                state_next = ST_TRAP;
            end
            default: begin
                drain_buffer = 1'b1;
                en_output = 1'b1;
                buffer_next = {{ '{' -}} MAGIC_SOP, MSG_TYPE_ERROR_UNKNOWN_STATE, 16'h0 {{- '}' }};
                bit_count_reset_value = 17'd16;
                reset_bit_count = 1'b1;
                state_next = ST_PASSTHRU_ERROR;
            end
        endcase
    end

endmodule
