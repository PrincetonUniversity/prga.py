// Automatically generated by PRGA's RTL generator

`include "pktchain_system.vh"

module pktchain_ctrl (
    input wire                                      clk
    , input wire                                    rst_n

    , output reg                                    frame_i_rd
    , input wire                                    frame_i_empty
    , input [`PRGA_PKTCHAIN_FRAME_SIZE-1:0]         frame_i

    , output reg                                    err_resp_inval
    , output reg                                    err_bitstream_corrupted
    , output reg                                    err_bitstream_incomplete
    , output reg                                    err_bitstream_redundant

    // == PROG <-> FABRIC =====================================================
    , output reg                                    prog_rst
    , output reg                                    prog_done

    // configuration output
    , input wire                                    phit_o_full
    , output wire                                   phit_o_wr
    , output wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0] phit_o

    // configuration input
    , output wire                                   phit_i_full
    , input wire                                    phit_i_wr
    , input wire [`PRGA_PKTCHAIN_PHIT_WIDTH - 1:0]  phit_i
    );

    // =======================================================================
    // -- Error Flags --------------------------------------------------------
    // =======================================================================

    reg err_resp_inval_set;
    reg err_bitstream_corrupted_set;
    reg err_bitstream_incomplete_set;
    reg err_bitstream_redundant_set;

    always @(posedge clk) begin
        if (~rst_n) begin
            err_resp_inval              <= 1'b0;
            err_bitstream_corrupted     <= 1'b0;
            err_bitstream_incomplete    <= 1'b0;
            err_bitstream_redundant     <= 1'b0;
        end else begin
            err_resp_inval              <= err_resp_inval || err_resp_inval_set;
            err_bitstream_corrupted     <= err_bitstream_corrupted || err_bitstream_corrupted_set;
            err_bitstream_incomplete    <= err_bitstream_incomplete || err_bitstream_incomplete_set;
            err_bitstream_redundant     <= err_bitstream_redundant || err_bitstream_redundant_set;
        end
    end

    wire any_err;
    assign any_err = err_resp_inval || err_bitstream_corrupted || err_bitstream_incomplete || err_bitstream_redundant;

    // =======================================================================
    // -- Tile Status Tracker Array ------------------------------------------
    // =======================================================================

    localparam  TILE_STATUS_WIDTH           = 2;
    localparam  TILE_STATUS_RESET           = 2'h0,     // the tile is not programmed yet
                TILE_STATUS_PROGRAMMING     = 2'h1,     // init packet sent to the tile
                TILE_STATUS_PENDING         = 2'h2,     // checksum packet sent to the tile
                TILE_STATUS_DONE            = 2'h3;     // the tile is successfully programmed

    localparam  TILE_STATUS_OP_WIDTH    = 2;
    localparam  TILE_STATUS_OP_INVAL    = 2'h0,
                TILE_STATUS_OP_CLEAR    = 2'h1,
                TILE_STATUS_OP_UPDATE   = 2'h2;

    localparam  LOG2_PKTCHAIN_NUM_BRANCHES  = `PRGA_CLOG2(`PRGA_PKTCHAIN_NUM_BRANCHES),
                LOG2_PKTCHAIN_NUM_LEAVES    = `PRGA_CLOG2(`PRGA_PKTCHAIN_NUM_LEAVES);

    reg [TILE_STATUS_OP_WIDTH-1:0]      tile_status_op;
    reg [LOG2_PKTCHAIN_NUM_BRANCHES - 1:0]   tile_status_rd_xpos,
                                        tile_status_rd_xpos_f;
    reg [LOG2_PKTCHAIN_NUM_LEAVES - 1:0]   tile_status_rd_ypos,
                                        tile_status_rd_ypos_f;
    wire [`PRGA_PKTCHAIN_NUM_LEAVES * TILE_STATUS_WIDTH - 1:0] tile_status_col_dout;
    reg [`PRGA_PKTCHAIN_NUM_LEAVES * TILE_STATUS_WIDTH - 1:0] tile_status_col_din;
    reg [TILE_STATUS_WIDTH-1:0]         tile_status_dout, tile_status_din;

    prga_ram_1r1w_byp #(
        .DATA_WIDTH                     (`PRGA_PKTCHAIN_NUM_LEAVES * TILE_STATUS_WIDTH)
        ,.ADDR_WIDTH                    (LOG2_PKTCHAIN_NUM_BRANCHES)
        ,.RAM_ROWS                      (`PRGA_PKTCHAIN_NUM_BRANCHES)
    ) i_tile_status (
        .clk                            (clk)
        ,.rst                           (~rst_n)
        ,.re                            (1'b1)
        ,.raddr                         (tile_status_rd_xpos)
        ,.dout                          (tile_status_col_dout)
        ,.we                            (tile_status_op == TILE_STATUS_OP_CLEAR || tile_status_op == TILE_STATUS_OP_UPDATE)
        ,.waddr                         (tile_status_rd_xpos_f)
        ,.din                           (tile_status_col_din)
        ,.bw                            ({(`PRGA_PKTCHAIN_NUM_LEAVES * TILE_STATUS_WIDTH) {1'b1} })
        );

    always @(posedge clk) begin
        if (~rst_n) begin
            tile_status_rd_xpos_f <= {LOG2_PKTCHAIN_NUM_BRANCHES {1'b0} };
            tile_status_rd_ypos_f <= {LOG2_PKTCHAIN_NUM_LEAVES {1'b0} };
        end else begin
            tile_status_rd_xpos_f <= tile_status_rd_xpos;
            tile_status_rd_ypos_f <= tile_status_rd_ypos;
        end
    end

    always @* begin
        tile_status_dout = tile_status_col_dout[tile_status_rd_ypos_f * TILE_STATUS_WIDTH +: TILE_STATUS_WIDTH];
        tile_status_col_din = tile_status_col_dout;

        case (tile_status_op)
            TILE_STATUS_OP_CLEAR: begin
                tile_status_col_din = {`PRGA_PKTCHAIN_NUM_LEAVES {TILE_STATUS_RESET} };
            end
            TILE_STATUS_OP_UPDATE: begin
                tile_status_col_din[tile_status_rd_ypos_f * TILE_STATUS_WIDTH +: TILE_STATUS_WIDTH] = tile_status_din;
            end
        endcase
    end

    // =======================================================================
    // -- Bitstream Frame output ---------------------------------------------
    // =======================================================================

    wire frame_o_stall;
    reg frame_o_val;

    pktchain_frame_disassemble #(
        .DEPTH_LOG2             (1)
    ) i_frameq (
        .prog_clk               (clk)
        ,.prog_rst              (prog_rst)
        ,.frame_full            (frame_o_stall)
        ,.frame_wr              (frame_o_val)
        ,.frame_i               (frame_i)
        ,.phit_wr               (phit_o_wr)
        ,.phit_full             (phit_o_full)
        ,.phit_o                (phit_o)
        );

    // =======================================================================
    // -- Bitstream Response Input -------------------------------------------
    // =======================================================================

    wire brespq_empty, bresp_val;
    reg bresp_stall;
    wire [`PRGA_PKTCHAIN_FRAME_SIZE - 1:0] bresp;

    pktchain_frame_assemble #(
        .DEPTH_LOG2             (1)
    ) i_brespq (
        .prog_clk               (clk)
        ,.prog_rst              (prog_rst)
        ,.phit_full             (phit_i_full)
        ,.phit_wr               (phit_i_wr)
        ,.phit_i                (phit_i)
        ,.frame_empty           (brespq_empty)
        ,.frame_rd              (~bresp_stall)
        ,.frame_o               (bresp)
        );

    assign bresp_val = ~brespq_empty;

    // =======================================================================
    // -- Bitstream Loading --------------------------------------------------
    // =======================================================================

    // == FSM States ==
    localparam  ST_BL_WIDTH                     = 3;
    localparam  ST_BL_RST                       = 3'h0,
                ST_BL_CLR_TILE_STATUS           = 3'h1,
                ST_BL_STANDBY                   = 3'h2,
                ST_BL_PROG                      = 3'h3,
                ST_BL_STBLIZ                    = 3'h4,
                ST_BL_SUCCESS                   = 3'h5,
                ST_BL_FAIL                      = 3'h6;

    reg [ST_BL_WIDTH-1:0]                           bl_state, bl_state_next;
    reg [`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2 - 1:0]   init_tiles, init_tiles_next, pending_tiles, pending_tiles_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            bl_state                <= ST_BL_RST;
            init_tiles              <= {(`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2) {1'b0} };
            pending_tiles           <= {(`PRGA_PKTCHAIN_CHAIN_ID_WIDTH * 2) {1'b0} };
        end else begin
            bl_state                <= bl_state_next;
            init_tiles              <= init_tiles_next;
            pending_tiles           <= pending_tiles_next;
        end
    end

    // == Resource Arbitration ==
    localparam  ARB_WIDTH   = 1;
    localparam  ARB_MAIN    = 1'b0,
                ARB_PKT     = 1'b1;

    reg [ARB_WIDTH-1:0] resource_arb;

    // tile status array
    reg [TILE_STATUS_OP_WIDTH-1:0]  tile_status_op_candidate            [0:1];  // PKT or MAIN
    reg [LOG2_PKTCHAIN_NUM_BRANCHES-1:0] tile_status_rd_xpos_candidate       [0:1];  // PKT or MAIN

    // init_tiles
    reg [`PRGA_PKTCHAIN_CHAIN_ID_WIDTH*2-1:0] init_tiles_next_candidate      [0:1];  // PKT or MAIN
    reg [`PRGA_PKTCHAIN_CHAIN_ID_WIDTH*2-1:0] pending_tiles_next_candidate   [0:1];  // PKT or MAIN

    always @* begin
        tile_status_op = tile_status_op_candidate[resource_arb];
        tile_status_rd_xpos = tile_status_rd_xpos_candidate[resource_arb];
        init_tiles_next = init_tiles_next_candidate[resource_arb];
        pending_tiles_next = pending_tiles_next_candidate[resource_arb];
    end

    // == Main FSM ==
    // transition triggers
    reg pkt_sob, pkt_eob;

    always @* begin
        prog_rst = 1'b0;
        prog_done = 1'b0;
        bl_state_next = bl_state;
        resource_arb = ARB_PKT;
        tile_status_op_candidate[ARB_MAIN]      = TILE_STATUS_OP_INVAL;
        tile_status_rd_xpos_candidate[ARB_MAIN] = {LOG2_PKTCHAIN_NUM_BRANCHES {1'b0} };
        init_tiles_next_candidate[ARB_MAIN]     = {(`PRGA_PKTCHAIN_CHAIN_ID_WIDTH*2) {1'b0} };
        pending_tiles_next_candidate[ARB_MAIN]  = {(`PRGA_PKTCHAIN_CHAIN_ID_WIDTH*2) {1'b0} };

        case (bl_state)
            ST_BL_RST: begin
                prog_rst = 1'b1;
                bl_state_next = ST_BL_CLR_TILE_STATUS;
                resource_arb = ARB_MAIN;
            end
            ST_BL_CLR_TILE_STATUS: begin
                prog_rst = 1'b1;
                resource_arb = ARB_MAIN;
                tile_status_op_candidate[ARB_MAIN] = TILE_STATUS_OP_CLEAR;
                tile_status_rd_xpos_candidate[ARB_MAIN] = tile_status_rd_xpos_f + 1;

                if (tile_status_rd_xpos_f + 1 == `PRGA_PKTCHAIN_NUM_BRANCHES) begin
                    bl_state_next = ST_BL_STANDBY;
                end
            end
            ST_BL_STANDBY: begin
                // error?
                if (any_err) begin
                    bl_state_next = ST_BL_FAIL;
                end

                // start of bitstream?
                else if (pkt_sob) begin
                    bl_state_next = ST_BL_PROG;
                end
            end
            ST_BL_PROG: begin

                // error?
                if (any_err) begin
                    bl_state_next = ST_BL_FAIL;
                end

                // end of bitstream?
                else if (pkt_eob) begin
                    bl_state_next = ST_BL_STBLIZ;
                end
            end
            ST_BL_STBLIZ: begin
                // error?
                if (any_err) begin
                    bl_state_next = ST_BL_FAIL;
                end 

                // finished?
                else if (pending_tiles == 0) begin
                    bl_state_next = ST_BL_SUCCESS;
                end
            end
            ST_BL_SUCCESS: begin
                prog_done = 1'b1;
            end
        endcase
    end

    // == Packet Input/Output FSM ==
    localparam  ST_PKT_WIDTH                    = 2;
    localparam  ST_PKT_IDLE                     = 2'h0,
                ST_PKT_HDR                      = 2'h1,
                ST_PKT_PLD_DUMP                 = 2'h2,
                ST_PKT_PLD_FWD                  = 2'h3;

    reg [ST_PKT_WIDTH-1:0]                      pkt_o_state, pkt_o_state_next;
    reg [`PRGA_PKTCHAIN_PAYLOAD_WIDTH-1:0]      pkt_o_payload, pkt_o_payload_next;

    reg [ST_PKT_WIDTH-1:0]                      pkt_i_state, pkt_i_state_next;
    reg [`PRGA_PKTCHAIN_PAYLOAD_WIDTH-1:0]      pkt_i_payload, pkt_i_payload_next;

    always @(posedge clk) begin
        if (~rst_n) begin
            pkt_o_state             <= ST_PKT_IDLE;
            pkt_o_payload           <= {`PRGA_PKTCHAIN_PAYLOAD_WIDTH {1'b0} };
            pkt_i_state             <= ST_PKT_IDLE;
            pkt_i_payload           <= {`PRGA_PKTCHAIN_PAYLOAD_WIDTH {1'b0} };
        end else begin
            pkt_o_state             <= pkt_o_state_next;
            pkt_o_payload           <= pkt_o_payload_next;
            pkt_i_state             <= pkt_i_state_next;
            pkt_i_payload           <= pkt_i_payload_next;
        end
    end

    // temporary variable:
    reg tile_status_busy;

    always @* begin
        tile_status_busy = 1'b0;

        // Prioritize response handling
        pkt_i_state_next = pkt_i_state;
        pkt_i_payload_next = pkt_i_payload;
        bresp_stall = 1'b1;
        err_resp_inval_set = 1'b0;
        err_bitstream_corrupted_set = 1'b0;
        err_bitstream_incomplete_set = 1'b0;
        err_bitstream_redundant_set = 1'b0;
        tile_status_op_candidate[ARB_PKT]       = TILE_STATUS_OP_INVAL;
        tile_status_rd_xpos_candidate[ARB_PKT]  = tile_status_rd_xpos_f;
        tile_status_rd_ypos                     = tile_status_rd_ypos_f;
        tile_status_din                         = {TILE_STATUS_WIDTH {1'b0} };
        init_tiles_next_candidate[ARB_PKT]      = init_tiles;
        pending_tiles_next_candidate[ARB_PKT]   = pending_tiles;

        case (pkt_i_state)
            ST_PKT_IDLE: if ((bl_state == ST_BL_PROG || bl_state == ST_BL_STBLIZ) && bresp_val) begin
                if (bresp[`PRGA_PKTCHAIN_BRANCH_ID_INDEX] < `PRGA_PKTCHAIN_NUM_BRANCHES &&
                    bresp[`PRGA_PKTCHAIN_LEAF_ID_INDEX] < `PRGA_PKTCHAIN_NUM_LEAVES &&
                    bresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] == 0
                ) begin
                    case (bresp[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                        `PRGA_PKTCHAIN_MSG_TYPE_DATA_ACK: begin
                            pkt_i_state_next = ST_PKT_HDR;
                            tile_status_rd_xpos_candidate[ARB_PKT] = bresp[`PRGA_PKTCHAIN_BRANCH_ID_INDEX];
                            tile_status_rd_ypos = `PRGA_PKTCHAIN_NUM_LEAVES - 1 - bresp[`PRGA_PKTCHAIN_LEAF_ID_INDEX];
                            tile_status_busy = 1'b1;
                        end
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_UNKNOWN_MSG_TYPE,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_ECHO_MISMATCH,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_CHECKSUM_MISMATCH,
                        `PRGA_PKTCHAIN_MSG_TYPE_ERROR_FEEDTHRU_PACKET: begin
                            err_bitstream_corrupted_set = 1'b1;
                            bresp_stall = 1'b0;
                        end
                        default: begin
                            err_resp_inval_set = 1'b1;
                            bresp_stall = 1'b0;
                        end
                    endcase
                end else begin
                    err_resp_inval_set = 1'b1;
                    bresp_stall = 1'b0;

                    if (bresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                        pkt_i_payload_next = bresp[`PRGA_PKTCHAIN_PAYLOAD_INDEX] - 1;
                        pkt_i_state_next = ST_PKT_PLD_DUMP;
                    end
                end
            end
            ST_PKT_HDR: if (tile_status_dout == TILE_STATUS_PENDING) begin
                pkt_i_state_next = ST_PKT_IDLE;
                tile_status_op_candidate[ARB_PKT] = TILE_STATUS_OP_UPDATE;
                tile_status_din = TILE_STATUS_DONE;
                pending_tiles_next_candidate[ARB_PKT] = pending_tiles - 1;
                bresp_stall = 1'b0;
            end else begin
                pkt_i_state_next = ST_PKT_IDLE;
                err_resp_inval_set = 1'b1;
                bresp_stall = 1'b0;
            end
            ST_PKT_PLD_DUMP: begin
                bresp_stall = 1'b0;

                if (bresp_val) begin

                    if (pkt_i_payload == 0) begin
                        pkt_i_state_next = ST_PKT_IDLE;
                    end else begin
                        pkt_i_payload_next = pkt_i_payload - 1;
                    end
                end
            end
        endcase

        // handle bitstream output packets
        pkt_o_state_next = pkt_o_state;
        pkt_o_payload_next = pkt_o_payload;
        frame_i_rd = 1'b0;
        frame_o_val = 1'b0;
        pkt_sob = 1'b0;
        pkt_eob = 1'b0;

        case (pkt_o_state)
            ST_PKT_IDLE: if (~frame_i_empty) begin
                case (bl_state)
                    ST_BL_STANDBY: if (frame_i == {
                        `PRGA_PKTCHAIN_MSG_TYPE_SOB,
                        {`PRGA_PKTCHAIN_CHAIN_ID_WIDTH {1'b0} },
                        {`PRGA_PKTCHAIN_CHAIN_ID_WIDTH {1'b0} },
                        {`PRGA_PKTCHAIN_PAYLOAD_WIDTH {1'b0} }
                    }) begin
                        pkt_sob = 1'b1;
                        frame_i_rd = 1'b1;
                    end else begin
                        err_bitstream_incomplete_set = 1'b1;
                        frame_i_rd = 1'b1;

                        if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            pkt_o_payload_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] - 1;
                            pkt_o_state_next = ST_PKT_PLD_DUMP;
                        end
                    end
                    ST_BL_PROG: if (frame_i == {
                        `PRGA_PKTCHAIN_MSG_TYPE_EOB,
                        {`PRGA_PKTCHAIN_CHAIN_ID_WIDTH {1'b0} },
                        {`PRGA_PKTCHAIN_CHAIN_ID_WIDTH {1'b0} },
                        {`PRGA_PKTCHAIN_PAYLOAD_WIDTH {1'b0} }
                    }) begin
                        frame_i_rd = 1'b1;

                        if (init_tiles) begin
                            err_bitstream_corrupted_set = 1'b1;
                        end else begin
                            pkt_eob = 1'b1;
                        end
                    end else if (frame_i[`PRGA_PKTCHAIN_BRANCH_ID_INDEX] < `PRGA_PKTCHAIN_NUM_BRANCHES &&
                        frame_i[`PRGA_PKTCHAIN_LEAF_ID_INDEX] < `PRGA_PKTCHAIN_NUM_LEAVES && (
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM ||
                            frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX] == `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM)
                    ) begin
                        if (~tile_status_busy) begin
                            tile_status_rd_xpos_candidate[ARB_PKT] = frame_i[`PRGA_PKTCHAIN_BRANCH_ID_INDEX];
                            tile_status_rd_ypos = frame_i[`PRGA_PKTCHAIN_LEAF_ID_INDEX];
                            pkt_o_state_next = ST_PKT_HDR;
                        end
                    end else begin
                        err_bitstream_corrupted_set = 1'b1;
                        frame_i_rd = 1'b1;

                        if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            pkt_o_payload_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] - 1;
                            pkt_o_state_next = ST_PKT_PLD_DUMP;
                        end
                    end
                    ST_BL_SUCCESS,
                    ST_BL_FAIL: begin
                        err_bitstream_redundant_set = 1'b1;
                        frame_i_rd = 1'b1;

                        if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            pkt_o_payload_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] - 1;
                            pkt_o_state_next = ST_PKT_PLD_DUMP;
                        end
                    end
                endcase
            end
            ST_PKT_HDR: begin
                case (tile_status_dout)
                    TILE_STATUS_RESET: begin
                        case (frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT: begin
                                init_tiles_next_candidate[ARB_PKT] = init_tiles + 1;
                                tile_status_din = TILE_STATUS_PROGRAMMING;
                                tile_status_op_candidate[ARB_PKT] = TILE_STATUS_OP_UPDATE;
                                frame_o_val = 1'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_INIT_CHECKSUM: begin
                                pending_tiles_next_candidate[ARB_PKT] = pending_tiles + 1;
                                tile_status_din = TILE_STATUS_PENDING;
                                tile_status_op_candidate[ARB_PKT] = TILE_STATUS_OP_UPDATE;
                                frame_o_val = 1'b1;
                            end
                            default: begin
                                err_bitstream_corrupted_set = 1'b1;
                            end
                        endcase
                    end
                    TILE_STATUS_PROGRAMMING: begin
                        case (frame_i[`PRGA_PKTCHAIN_MSG_TYPE_INDEX])
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA: begin
                                frame_o_val = 1'b1;
                            end
                            `PRGA_PKTCHAIN_MSG_TYPE_DATA_CHECKSUM: begin
                                init_tiles_next_candidate[ARB_PKT] = init_tiles - 1;
                                pending_tiles_next_candidate[ARB_PKT] = pending_tiles + 1;
                                tile_status_din = TILE_STATUS_PENDING;
                                tile_status_op_candidate[ARB_PKT] = TILE_STATUS_OP_UPDATE;
                                frame_o_val = 1'b1;
                            end
                            default: begin
                                err_bitstream_corrupted_set = 1'b1;
                            end
                        endcase
                    end
                    default: begin
                        err_bitstream_corrupted_set = 1'b1;
                    end
                endcase

                if (frame_o_val) begin
                    if (frame_o_stall) begin
                        pkt_o_payload_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX];
                        pkt_o_state_next = ST_PKT_PLD_FWD;
                    end else begin
                        frame_i_rd = 1'b1;

                        if (frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] > 0) begin
                            pkt_o_payload_next = frame_i[`PRGA_PKTCHAIN_PAYLOAD_INDEX] - 1;
                            pkt_o_state_next = ST_PKT_PLD_FWD;
                        end else begin
                            pkt_o_state_next = ST_PKT_IDLE;
                        end
                    end
                end else begin
                    frame_i_rd = 1'b1;
                    pkt_o_state_next = ST_PKT_IDLE;
                end
            end
            ST_PKT_PLD_FWD: if (~frame_i_empty) begin
                frame_o_val = 1'b1;

                if (~frame_o_stall) begin
                    frame_i_rd = 1'b1;

                    if (pkt_o_payload == 0) begin
                        pkt_o_state_next = ST_PKT_IDLE;
                    end else begin
                        pkt_o_payload_next = pkt_o_payload - 1;
                    end
                end
            end
            ST_PKT_PLD_DUMP: if (~frame_i_empty) begin
                frame_i_rd = 1'b1;

                if (pkt_o_payload == 0) begin
                    pkt_o_state_next = ST_PKT_IDLE;
                end else begin
                    pkt_o_payload_next = pkt_o_payload - 1;
                end
            end
        endcase
    end

endmodule
