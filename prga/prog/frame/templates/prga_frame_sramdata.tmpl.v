// Automatically generated by PRGA's RTL generator
`timescale 1ns/1ps
module {{ module.name }} #(
    parameter   ADDR_WIDTH = {{ module.ports.prog_addr|length }}
    , parameter WORD_WIDTH = {{ module.ports.prog_din|length }}
    , parameter DATA_WIDTH = {{ module.ports.prog_data_o|length }}
) (
    input wire prog_clk
    , input wire prog_rst
    , input wire prog_done

    , input wire [ADDR_WIDTH-1:0]   prog_addr
    , input wire [WORD_WIDTH-1:0]   prog_din
    , input wire                    prog_ce     // clock enable
    , input wire                    prog_we     // write enable

    , output wire [DATA_WIDTH-1:0]  prog_data_o
    , output reg [WORD_WIDTH-1:0]   prog_dout   // data read-back. one cycle latency (similar to an SRAM IP)
    );

    localparam  WORDS = DATA_WIDTH / WORD_WIDTH + (DATA_WIDTH % WORD_WIDTH > 0 ? 1 : 0);

    reg [WORD_WIDTH-1:0]            prog_words [0:WORDS-1];
    wire [WORD_WIDTH*WORDS-1:0]     prog_data_aligned;

    genvar i;
    generate for (i = 0; i < WORDS; i = i + 1) begin
        always @(posedge prog_clk) begin
            if (prog_rst) begin
                prog_words[i] <= { WORD_WIDTH {1'b0} };
            end else if (~prog_done && prog_ce && prog_we && prog_addr == i) begin
                prog_words[i] <= prog_din;
            end
        end

        assign prog_data_aligned[i*WORD_WIDTH +: WORD_WIDTH] = prog_words[i];
    end endgenerate

    assign prog_data_o = prog_data_aligned[0 +: DATA_WIDTH];

    always @(posedge prog_clk) begin
        if (prog_rst) begin
            prog_dout <= { WORD_WIDTH {1'b0} };
        end else if (~prog_done && prog_ce) begin
            prog_dout <= prog_we ? prog_din : prog_words[prog_addr];
        end
    end

endmodule
